"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@reduxjs";
exports.ids = ["vendor-chunks/@reduxjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/query/react/rtk-query-react.modern.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/query/react/rtk-query-react.modern.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiProvider: () => (/* binding */ ApiProvider),\n/* harmony export */   QueryStatus: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__.QueryStatus),\n/* harmony export */   UNINITIALIZED_VALUE: () => (/* binding */ UNINITIALIZED_VALUE),\n/* harmony export */   _NEVER: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__._NEVER),\n/* harmony export */   buildCreateApi: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__.buildCreateApi),\n/* harmony export */   copyWithStructuralSharing: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__.copyWithStructuralSharing),\n/* harmony export */   coreModule: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__.coreModule),\n/* harmony export */   coreModuleName: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__.coreModuleName),\n/* harmony export */   createApi: () => (/* binding */ createApi),\n/* harmony export */   defaultSerializeQueryArgs: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__.defaultSerializeQueryArgs),\n/* harmony export */   fakeBaseQuery: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__.fakeBaseQuery),\n/* harmony export */   fetchBaseQuery: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__.fetchBaseQuery),\n/* harmony export */   reactHooksModule: () => (/* binding */ reactHooksModule),\n/* harmony export */   reactHooksModuleName: () => (/* binding */ reactHooksModuleName),\n/* harmony export */   retry: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__.retry),\n/* harmony export */   setupListeners: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__.setupListeners),\n/* harmony export */   skipToken: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__.skipToken)\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @reduxjs/toolkit/query */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-redux */ \"(ssr)/./node_modules/react-redux/dist/react-redux.mjs\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/reselect.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n// src/query/react/index.ts\n\n\n// src/query/react/module.ts\n\n\n\n\n// src/query/utils/capitalize.ts\nfunction capitalize(str) {\n  return str.replace(str[0], str[0].toUpperCase());\n}\n\n// src/query/utils/countObjectKeys.ts\nfunction countObjectKeys(obj) {\n  let count = 0;\n  for (const _key in obj) {\n    count++;\n  }\n  return count;\n}\n\n// src/query/endpointDefinitions.ts\nfunction isQueryDefinition(e) {\n  return e.type === \"query\" /* query */;\n}\nfunction isMutationDefinition(e) {\n  return e.type === \"mutation\" /* mutation */;\n}\nfunction isInfiniteQueryDefinition(e) {\n  return e.type === \"infinitequery\" /* infinitequery */;\n}\n\n// src/query/tsHelpers.ts\nfunction safeAssign(target, ...args) {\n  return Object.assign(target, ...args);\n}\n\n// src/query/react/buildHooks.ts\n\n\n\n\n\n// src/query/react/constants.ts\nvar UNINITIALIZED_VALUE = Symbol();\n\n// src/query/react/useSerializedStableValue.ts\n\nfunction useStableQueryArgs(queryArgs, serialize, endpointDefinition, endpointName) {\n  const incoming = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n    queryArgs,\n    serialized: typeof queryArgs == \"object\" ? serialize({\n      queryArgs,\n      endpointDefinition,\n      endpointName\n    }) : queryArgs\n  }), [queryArgs, serialize, endpointDefinition, endpointName]);\n  const cache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(incoming);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (cache.current.serialized !== incoming.serialized) {\n      cache.current = incoming;\n    }\n  }, [incoming]);\n  return cache.current.serialized === incoming.serialized ? cache.current.queryArgs : queryArgs;\n}\n\n// src/query/react/useShallowStableValue.ts\n\n\nfunction useShallowStableValue(value) {\n  const cache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!(0,react_redux__WEBPACK_IMPORTED_MODULE_1__.shallowEqual)(cache.current, value)) {\n      cache.current = value;\n    }\n  }, [value]);\n  return (0,react_redux__WEBPACK_IMPORTED_MODULE_1__.shallowEqual)(cache.current, value) ? cache.current : value;\n}\n\n// src/query/react/buildHooks.ts\nvar canUseDOM = () => !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\nvar isDOM = /* @__PURE__ */ canUseDOM();\nvar isRunningInReactNative = () => typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\";\nvar isReactNative = /* @__PURE__ */ isRunningInReactNative();\nvar getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar useIsomorphicLayoutEffect = /* @__PURE__ */ getUseIsomorphicLayoutEffect();\nvar noPendingQueryStateSelector = (selected) => {\n  if (selected.isUninitialized) {\n    return {\n      ...selected,\n      isUninitialized: false,\n      isFetching: true,\n      isLoading: selected.data !== void 0 ? false : true,\n      status: _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__.QueryStatus.pending\n    };\n  }\n  return selected;\n};\nfunction pick(obj, ...keys) {\n  const ret = {};\n  keys.forEach((key) => {\n    ret[key] = obj[key];\n  });\n  return ret;\n}\nvar COMMON_HOOK_DEBUG_FIELDS = [\"data\", \"status\", \"isLoading\", \"isSuccess\", \"isError\", \"error\"];\nfunction buildHooks({\n  api,\n  moduleOptions: {\n    batch,\n    hooks: {\n      useDispatch,\n      useSelector,\n      useStore\n    },\n    unstable__sideEffectsInRender,\n    createSelector\n  },\n  serializeQueryArgs,\n  context\n}) {\n  const usePossiblyImmediateEffect = unstable__sideEffectsInRender ? (cb) => cb() : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n  return {\n    buildQueryHooks,\n    buildInfiniteQueryHooks,\n    buildMutationHook,\n    usePrefetch\n  };\n  function queryStatePreSelector(currentState, lastResult, queryArgs) {\n    if (lastResult?.endpointName && currentState.isUninitialized) {\n      const {\n        endpointName\n      } = lastResult;\n      const endpointDefinition = context.endpointDefinitions[endpointName];\n      if (queryArgs !== _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__.skipToken && serializeQueryArgs({\n        queryArgs: lastResult.originalArgs,\n        endpointDefinition,\n        endpointName\n      }) === serializeQueryArgs({\n        queryArgs,\n        endpointDefinition,\n        endpointName\n      })) lastResult = void 0;\n    }\n    let data = currentState.isSuccess ? currentState.data : lastResult?.data;\n    if (data === void 0) data = currentState.data;\n    const hasData = data !== void 0;\n    const isFetching = currentState.isLoading;\n    const isLoading = (!lastResult || lastResult.isLoading || lastResult.isUninitialized) && !hasData && isFetching;\n    const isSuccess = currentState.isSuccess || hasData && (isFetching && !lastResult?.isError || currentState.isUninitialized);\n    return {\n      ...currentState,\n      data,\n      currentData: currentState.data,\n      isFetching,\n      isLoading,\n      isSuccess\n    };\n  }\n  function infiniteQueryStatePreSelector(currentState, lastResult, queryArgs) {\n    if (lastResult?.endpointName && currentState.isUninitialized) {\n      const {\n        endpointName\n      } = lastResult;\n      const endpointDefinition = context.endpointDefinitions[endpointName];\n      if (serializeQueryArgs({\n        queryArgs: lastResult.originalArgs,\n        endpointDefinition,\n        endpointName\n      }) === serializeQueryArgs({\n        queryArgs,\n        endpointDefinition,\n        endpointName\n      })) lastResult = void 0;\n    }\n    let data = currentState.isSuccess ? currentState.data : lastResult?.data;\n    if (data === void 0) data = currentState.data;\n    const hasData = data !== void 0;\n    const isFetching = currentState.isLoading;\n    const isLoading = (!lastResult || lastResult.isLoading || lastResult.isUninitialized) && !hasData && isFetching;\n    const isSuccess = currentState.isSuccess || isFetching && hasData;\n    return {\n      ...currentState,\n      data,\n      currentData: currentState.data,\n      isFetching,\n      isLoading,\n      isSuccess\n    };\n  }\n  function usePrefetch(endpointName, defaultOptions) {\n    const dispatch = useDispatch();\n    const stableDefaultOptions = useShallowStableValue(defaultOptions);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((arg, options) => dispatch(api.util.prefetch(endpointName, arg, {\n      ...stableDefaultOptions,\n      ...options\n    })), [endpointName, dispatch, stableDefaultOptions]);\n  }\n  function useQuerySubscriptionCommonImpl(endpointName, arg, {\n    refetchOnReconnect,\n    refetchOnFocus,\n    refetchOnMountOrArgChange,\n    skip = false,\n    pollingInterval = 0,\n    skipPollingIfUnfocused = false,\n    ...rest\n  } = {}) {\n    const {\n      initiate\n    } = api.endpoints[endpointName];\n    const dispatch = useDispatch();\n    const subscriptionSelectorsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);\n    if (!subscriptionSelectorsRef.current) {\n      const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());\n      if (true) {\n        if (typeof returnedValue !== \"object\" || typeof returnedValue?.type === \"string\") {\n          throw new Error( false ? 0 : `Warning: Middleware for RTK-Query API at reducerPath \"${api.reducerPath}\" has not been added to the store.\n    You must add the middleware for RTK-Query to function correctly!`);\n        }\n      }\n      subscriptionSelectorsRef.current = returnedValue;\n    }\n    const stableArg = useStableQueryArgs(\n      skip ? _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__.skipToken : arg,\n      // Even if the user provided a per-endpoint `serializeQueryArgs` with\n      // a consistent return value, _here_ we want to use the default behavior\n      // so we can tell if _anything_ actually changed. Otherwise, we can end up\n      // with a case where the query args did change but the serialization doesn't,\n      // and then we never try to initiate a refetch.\n      _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__.defaultSerializeQueryArgs,\n      context.endpointDefinitions[endpointName],\n      endpointName\n    );\n    const stableSubscriptionOptions = useShallowStableValue({\n      refetchOnReconnect,\n      refetchOnFocus,\n      pollingInterval,\n      skipPollingIfUnfocused\n    });\n    const lastRenderHadSubscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const initialPageParam = rest.initialPageParam;\n    const stableInitialPageParam = useShallowStableValue(initialPageParam);\n    const promiseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);\n    let {\n      queryCacheKey,\n      requestId\n    } = promiseRef.current || {};\n    let currentRenderHasSubscription = false;\n    if (queryCacheKey && requestId) {\n      currentRenderHasSubscription = subscriptionSelectorsRef.current.isRequestSubscribed(queryCacheKey, requestId);\n    }\n    const subscriptionRemoved = !currentRenderHasSubscription && lastRenderHadSubscription.current;\n    usePossiblyImmediateEffect(() => {\n      lastRenderHadSubscription.current = currentRenderHasSubscription;\n    });\n    usePossiblyImmediateEffect(() => {\n      if (subscriptionRemoved) {\n        promiseRef.current = void 0;\n      }\n    }, [subscriptionRemoved]);\n    usePossiblyImmediateEffect(() => {\n      const lastPromise = promiseRef.current;\n      if (typeof process !== \"undefined\" && \"development\" === \"removeMeOnCompilation\") {}\n      if (stableArg === _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__.skipToken) {\n        lastPromise?.unsubscribe();\n        promiseRef.current = void 0;\n        return;\n      }\n      const lastSubscriptionOptions = promiseRef.current?.subscriptionOptions;\n      if (!lastPromise || lastPromise.arg !== stableArg) {\n        lastPromise?.unsubscribe();\n        const promise = dispatch(initiate(stableArg, {\n          subscriptionOptions: stableSubscriptionOptions,\n          forceRefetch: refetchOnMountOrArgChange,\n          ...isInfiniteQueryDefinition(context.endpointDefinitions[endpointName]) ? {\n            initialPageParam: stableInitialPageParam\n          } : {}\n        }));\n        promiseRef.current = promise;\n      } else if (stableSubscriptionOptions !== lastSubscriptionOptions) {\n        lastPromise.updateSubscriptionOptions(stableSubscriptionOptions);\n      }\n    }, [dispatch, initiate, refetchOnMountOrArgChange, stableArg, stableSubscriptionOptions, subscriptionRemoved, stableInitialPageParam, endpointName]);\n    return [promiseRef, dispatch, initiate, stableSubscriptionOptions];\n  }\n  function buildUseQueryState(endpointName, preSelector) {\n    const useQueryState = (arg, {\n      skip = false,\n      selectFromResult\n    } = {}) => {\n      const {\n        select\n      } = api.endpoints[endpointName];\n      const stableArg = useStableQueryArgs(skip ? _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__.skipToken : arg, serializeQueryArgs, context.endpointDefinitions[endpointName], endpointName);\n      const lastValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);\n      const selectDefaultResult = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (\n        // Normally ts-ignores are bad and should be avoided, but we're\n        // already casting this selector to be `Selector<any>` anyway,\n        // so the inconsistencies don't matter here\n        // @ts-ignore\n        createSelector([\n          // @ts-ignore\n          select(stableArg),\n          (_, lastResult) => lastResult,\n          (_) => stableArg\n        ], preSelector, {\n          memoizeOptions: {\n            resultEqualityCheck: react_redux__WEBPACK_IMPORTED_MODULE_1__.shallowEqual\n          }\n        })\n      ), [select, stableArg]);\n      const querySelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => selectFromResult ? createSelector([selectDefaultResult], selectFromResult, {\n        devModeChecks: {\n          identityFunctionCheck: \"never\"\n        }\n      }) : selectDefaultResult, [selectDefaultResult, selectFromResult]);\n      const currentState = useSelector((state) => querySelector(state, lastValue.current), react_redux__WEBPACK_IMPORTED_MODULE_1__.shallowEqual);\n      const store = useStore();\n      const newLastValue = selectDefaultResult(store.getState(), lastValue.current);\n      useIsomorphicLayoutEffect(() => {\n        lastValue.current = newLastValue;\n      }, [newLastValue]);\n      return currentState;\n    };\n    return useQueryState;\n  }\n  function usePromiseRefUnsubscribeOnUnmount(promiseRef) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      return () => {\n        promiseRef.current?.unsubscribe?.();\n        promiseRef.current = void 0;\n      };\n    }, [promiseRef]);\n  }\n  function refetchOrErrorIfUnmounted(promiseRef) {\n    if (!promiseRef.current) throw new Error( false ? 0 : \"Cannot refetch a query that has not been started yet.\");\n    return promiseRef.current.refetch();\n  }\n  function buildQueryHooks(endpointName) {\n    const useQuerySubscription = (arg, options = {}) => {\n      const [promiseRef] = useQuerySubscriptionCommonImpl(endpointName, arg, options);\n      usePromiseRefUnsubscribeOnUnmount(promiseRef);\n      return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n        /**\n         * A method to manually refetch data for the query\n         */\n        refetch: () => refetchOrErrorIfUnmounted(promiseRef)\n      }), [promiseRef]);\n    };\n    const useLazyQuerySubscription = ({\n      refetchOnReconnect,\n      refetchOnFocus,\n      pollingInterval = 0,\n      skipPollingIfUnfocused = false\n    } = {}) => {\n      const {\n        initiate\n      } = api.endpoints[endpointName];\n      const dispatch = useDispatch();\n      const [arg, setArg] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(UNINITIALIZED_VALUE);\n      const promiseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);\n      const stableSubscriptionOptions = useShallowStableValue({\n        refetchOnReconnect,\n        refetchOnFocus,\n        pollingInterval,\n        skipPollingIfUnfocused\n      });\n      usePossiblyImmediateEffect(() => {\n        const lastSubscriptionOptions = promiseRef.current?.subscriptionOptions;\n        if (stableSubscriptionOptions !== lastSubscriptionOptions) {\n          promiseRef.current?.updateSubscriptionOptions(stableSubscriptionOptions);\n        }\n      }, [stableSubscriptionOptions]);\n      const subscriptionOptionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(stableSubscriptionOptions);\n      usePossiblyImmediateEffect(() => {\n        subscriptionOptionsRef.current = stableSubscriptionOptions;\n      }, [stableSubscriptionOptions]);\n      const trigger = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(arg2, preferCacheValue = false) {\n        let promise;\n        batch(() => {\n          promiseRef.current?.unsubscribe();\n          promiseRef.current = promise = dispatch(initiate(arg2, {\n            subscriptionOptions: subscriptionOptionsRef.current,\n            forceRefetch: !preferCacheValue\n          }));\n          setArg(arg2);\n        });\n        return promise;\n      }, [dispatch, initiate]);\n      const reset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        if (promiseRef.current?.queryCacheKey) {\n          dispatch(api.internalActions.removeQueryResult({\n            queryCacheKey: promiseRef.current?.queryCacheKey\n          }));\n        }\n      }, [dispatch]);\n      (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        return () => {\n          promiseRef?.current?.unsubscribe();\n        };\n      }, []);\n      (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (arg !== UNINITIALIZED_VALUE && !promiseRef.current) {\n          trigger(arg, true);\n        }\n      }, [arg, trigger]);\n      return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => [trigger, arg, {\n        reset\n      }], [trigger, arg, reset]);\n    };\n    const useQueryState = buildUseQueryState(endpointName, queryStatePreSelector);\n    return {\n      useQueryState,\n      useQuerySubscription,\n      useLazyQuerySubscription,\n      useLazyQuery(options) {\n        const [trigger, arg, {\n          reset\n        }] = useLazyQuerySubscription(options);\n        const queryStateResults = useQueryState(arg, {\n          ...options,\n          skip: arg === UNINITIALIZED_VALUE\n        });\n        const info = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n          lastArg: arg\n        }), [arg]);\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => [trigger, {\n          ...queryStateResults,\n          reset\n        }, info], [trigger, queryStateResults, reset, info]);\n      },\n      useQuery(arg, options) {\n        const querySubscriptionResults = useQuerySubscription(arg, options);\n        const queryStateResults = useQueryState(arg, {\n          selectFromResult: arg === _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__.skipToken || options?.skip ? void 0 : noPendingQueryStateSelector,\n          ...options\n        });\n        const debugValue = pick(queryStateResults, ...COMMON_HOOK_DEBUG_FIELDS);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(debugValue);\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n          ...queryStateResults,\n          ...querySubscriptionResults\n        }), [queryStateResults, querySubscriptionResults]);\n      }\n    };\n  }\n  function buildInfiniteQueryHooks(endpointName) {\n    const useInfiniteQuerySubscription = (arg, options = {}) => {\n      const [promiseRef, dispatch, initiate, stableSubscriptionOptions] = useQuerySubscriptionCommonImpl(endpointName, arg, options);\n      const subscriptionOptionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(stableSubscriptionOptions);\n      usePossiblyImmediateEffect(() => {\n        subscriptionOptionsRef.current = stableSubscriptionOptions;\n      }, [stableSubscriptionOptions]);\n      const trigger = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(arg2, direction) {\n        let promise;\n        batch(() => {\n          promiseRef.current?.unsubscribe();\n          promiseRef.current = promise = dispatch(initiate(arg2, {\n            subscriptionOptions: subscriptionOptionsRef.current,\n            direction\n          }));\n        });\n        return promise;\n      }, [promiseRef, dispatch, initiate]);\n      usePromiseRefUnsubscribeOnUnmount(promiseRef);\n      return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        const fetchNextPage = () => {\n          return trigger(arg, \"forward\");\n        };\n        const fetchPreviousPage = () => {\n          return trigger(arg, \"backward\");\n        };\n        return {\n          trigger,\n          /**\n           * A method to manually refetch data for the query\n           */\n          refetch: () => refetchOrErrorIfUnmounted(promiseRef),\n          fetchNextPage,\n          fetchPreviousPage\n        };\n      }, [promiseRef, trigger, arg]);\n    };\n    const useInfiniteQueryState = buildUseQueryState(endpointName, infiniteQueryStatePreSelector);\n    return {\n      useInfiniteQueryState,\n      useInfiniteQuerySubscription,\n      useInfiniteQuery(arg, options) {\n        const {\n          refetch,\n          fetchNextPage,\n          fetchPreviousPage\n        } = useInfiniteQuerySubscription(arg, options);\n        const queryStateResults = useInfiniteQueryState(arg, {\n          selectFromResult: arg === _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__.skipToken || options?.skip ? void 0 : noPendingQueryStateSelector,\n          ...options\n        });\n        const debugValue = pick(queryStateResults, ...COMMON_HOOK_DEBUG_FIELDS, \"hasNextPage\", \"hasPreviousPage\");\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(debugValue);\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n          ...queryStateResults,\n          fetchNextPage,\n          fetchPreviousPage,\n          refetch\n        }), [queryStateResults, fetchNextPage, fetchPreviousPage, refetch]);\n      }\n    };\n  }\n  function buildMutationHook(name) {\n    return ({\n      selectFromResult,\n      fixedCacheKey\n    } = {}) => {\n      const {\n        select,\n        initiate\n      } = api.endpoints[name];\n      const dispatch = useDispatch();\n      const [promise, setPromise] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n      (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => () => {\n        if (!promise?.arg.fixedCacheKey) {\n          promise?.reset();\n        }\n      }, [promise]);\n      const triggerMutation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(arg) {\n        const promise2 = dispatch(initiate(arg, {\n          fixedCacheKey\n        }));\n        setPromise(promise2);\n        return promise2;\n      }, [dispatch, initiate, fixedCacheKey]);\n      const {\n        requestId\n      } = promise || {};\n      const selectDefaultResult = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => select({\n        fixedCacheKey,\n        requestId: promise?.requestId\n      }), [fixedCacheKey, promise, select]);\n      const mutationSelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => selectFromResult ? createSelector([selectDefaultResult], selectFromResult) : selectDefaultResult, [selectFromResult, selectDefaultResult]);\n      const currentState = useSelector(mutationSelector, react_redux__WEBPACK_IMPORTED_MODULE_1__.shallowEqual);\n      const originalArgs = fixedCacheKey == null ? promise?.arg.originalArgs : void 0;\n      const reset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        batch(() => {\n          if (promise) {\n            setPromise(void 0);\n          }\n          if (fixedCacheKey) {\n            dispatch(api.internalActions.removeMutationResult({\n              requestId,\n              fixedCacheKey\n            }));\n          }\n        });\n      }, [dispatch, fixedCacheKey, promise, requestId]);\n      const debugValue = pick(currentState, ...COMMON_HOOK_DEBUG_FIELDS, \"endpointName\");\n      (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(debugValue);\n      const finalState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n        ...currentState,\n        originalArgs,\n        reset\n      }), [currentState, originalArgs, reset]);\n      return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => [triggerMutation, finalState], [triggerMutation, finalState]);\n    };\n  }\n}\n\n// src/query/react/module.ts\nvar reactHooksModuleName = /* @__PURE__ */ Symbol();\nvar reactHooksModule = ({\n  batch = react_redux__WEBPACK_IMPORTED_MODULE_1__.batch,\n  hooks = {\n    useDispatch: react_redux__WEBPACK_IMPORTED_MODULE_1__.useDispatch,\n    useSelector: react_redux__WEBPACK_IMPORTED_MODULE_1__.useSelector,\n    useStore: react_redux__WEBPACK_IMPORTED_MODULE_1__.useStore\n  },\n  createSelector = reselect__WEBPACK_IMPORTED_MODULE_3__.createSelector,\n  unstable__sideEffectsInRender = false,\n  ...rest\n} = {}) => {\n  if (true) {\n    const hookNames = [\"useDispatch\", \"useSelector\", \"useStore\"];\n    let warned = false;\n    for (const hookName of hookNames) {\n      if (countObjectKeys(rest) > 0) {\n        if (rest[hookName]) {\n          if (!warned) {\n            console.warn(\"As of RTK 2.0, the hooks now need to be specified as one object, provided under a `hooks` key:\\n`reactHooksModule({ hooks: { useDispatch, useSelector, useStore } })`\");\n            warned = true;\n          }\n        }\n        hooks[hookName] = rest[hookName];\n      }\n      if (typeof hooks[hookName] !== \"function\") {\n        throw new Error( false ? 0 : `When using custom hooks for context, all ${hookNames.length} hooks need to be provided: ${hookNames.join(\", \")}.\nHook ${hookName} was either not provided or not a function.`);\n      }\n    }\n  }\n  return {\n    name: reactHooksModuleName,\n    init(api, {\n      serializeQueryArgs\n    }, context) {\n      const anyApi = api;\n      const {\n        buildQueryHooks,\n        buildInfiniteQueryHooks,\n        buildMutationHook,\n        usePrefetch\n      } = buildHooks({\n        api,\n        moduleOptions: {\n          batch,\n          hooks,\n          unstable__sideEffectsInRender,\n          createSelector\n        },\n        serializeQueryArgs,\n        context\n      });\n      safeAssign(anyApi, {\n        usePrefetch\n      });\n      safeAssign(context, {\n        batch\n      });\n      return {\n        injectEndpoint(endpointName, definition) {\n          if (isQueryDefinition(definition)) {\n            const {\n              useQuery,\n              useLazyQuery,\n              useLazyQuerySubscription,\n              useQueryState,\n              useQuerySubscription\n            } = buildQueryHooks(endpointName);\n            safeAssign(anyApi.endpoints[endpointName], {\n              useQuery,\n              useLazyQuery,\n              useLazyQuerySubscription,\n              useQueryState,\n              useQuerySubscription\n            });\n            api[`use${capitalize(endpointName)}Query`] = useQuery;\n            api[`useLazy${capitalize(endpointName)}Query`] = useLazyQuery;\n          }\n          if (isMutationDefinition(definition)) {\n            const useMutation = buildMutationHook(endpointName);\n            safeAssign(anyApi.endpoints[endpointName], {\n              useMutation\n            });\n            api[`use${capitalize(endpointName)}Mutation`] = useMutation;\n          } else if (isInfiniteQueryDefinition(definition)) {\n            const {\n              useInfiniteQuery,\n              useInfiniteQuerySubscription,\n              useInfiniteQueryState\n            } = buildInfiniteQueryHooks(endpointName);\n            safeAssign(anyApi.endpoints[endpointName], {\n              useInfiniteQuery,\n              useInfiniteQuerySubscription,\n              useInfiniteQueryState\n            });\n            api[`use${capitalize(endpointName)}InfiniteQuery`] = useInfiniteQuery;\n          }\n        }\n      };\n    }\n  };\n};\n\n// src/query/react/index.ts\n\n\n// src/query/react/ApiProvider.tsx\n\n\n\n\n\n\nfunction ApiProvider(props) {\n  const context = props.context || react_redux__WEBPACK_IMPORTED_MODULE_1__.ReactReduxContext;\n  const existingContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(context);\n  if (existingContext) {\n    throw new Error( false ? 0 : \"Existing Redux context detected. If you already have a store set up, please use the traditional Redux setup.\");\n  }\n  const [store] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_4__.configureStore)({\n    reducer: {\n      [props.api.reducerPath]: props.api.reducer\n    },\n    middleware: (gDM) => gDM().concat(props.api.middleware)\n  }));\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => props.setupListeners === false ? void 0 : (0,_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__.setupListeners)(store.dispatch, props.setupListeners), [props.setupListeners, store.dispatch]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_redux__WEBPACK_IMPORTED_MODULE_1__.Provider, { store, context }, props.children);\n}\n\n// src/query/react/index.ts\nvar createApi = /* @__PURE__ */ (0,_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__.buildCreateApi)((0,_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_2__.coreModule)(), reactHooksModule());\n\n//# sourceMappingURL=rtk-query-react.modern.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3F1ZXJ5L3JlYWN0L3J0ay1xdWVyeS1yZWFjdC5tb2Rlcm4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNvRTs7QUFFcEU7QUFDc0Y7QUFDNkM7QUFDdEU7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDeUk7QUFDOUM7QUFDb0Q7QUFDbkY7O0FBRTVEO0FBQ0E7O0FBRUE7QUFDbUQ7QUFDbkQ7QUFDQSxtQkFBbUIsOENBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsZ0JBQWdCLDZDQUFNO0FBQ3RCLEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNtRTtBQUN4QjtBQUMzQztBQUNBLGdCQUFnQiw2Q0FBTztBQUN2QixFQUFFLGdEQUFVO0FBQ1osU0FBUyx5REFBWTtBQUNyQjtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMseURBQVk7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxrREFBZSxHQUFHLDRDQUFVO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtEQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0ZB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akI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQix5QkFBeUI7QUFDL0MsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQix5QkFBeUI7QUFDL0MsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3VDOztBQUV2QztBQUNzRztBQUNuRTtBQUNhO0FBQ2pCO0FBQzJCO0FBQ0Y7QUFDeEQ7QUFDQSxtQ0FBbUMsMERBQWlCO0FBQ3BELDBCQUEwQixpREFBVTtBQUNwQztBQUNBLG9CQUFvQixNQUFxQyxHQUFHLENBQTRCO0FBQ3hGO0FBQ0Esa0JBQWtCLDJDQUFjLE9BQU8sZ0VBQWM7QUFDckQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFVLGlEQUFpRCxzRUFBYztBQUMzRSx5QkFBeUIsZ0RBQW1CLENBQUMsaURBQVEsSUFBSSxnQkFBZ0I7QUFDekU7O0FBRUE7QUFDQSxnQ0FBZ0Msc0VBQWMsQ0FBQyxrRUFBVTtBQU92RDtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFRMZXZlbCAtIE9yZVxcZmxvd2Rlc2tcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAcmVkdXhqc1xcdG9vbGtpdFxcZGlzdFxccXVlcnlcXHJlYWN0XFxydGstcXVlcnktcmVhY3QubW9kZXJuLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcXVlcnkvcmVhY3QvaW5kZXgudHNcbmltcG9ydCB7IGJ1aWxkQ3JlYXRlQXBpLCBjb3JlTW9kdWxlIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXQvcXVlcnlcIjtcblxuLy8gc3JjL3F1ZXJ5L3JlYWN0L21vZHVsZS50c1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHsgYmF0Y2ggYXMgcnJCYXRjaCwgdXNlRGlzcGF0Y2ggYXMgcnJVc2VEaXNwYXRjaCwgdXNlU2VsZWN0b3IgYXMgcnJVc2VTZWxlY3RvciwgdXNlU3RvcmUgYXMgcnJVc2VTdG9yZSB9IGZyb20gXCJyZWFjdC1yZWR1eFwiO1xuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IgYXMgX2NyZWF0ZVNlbGVjdG9yIH0gZnJvbSBcInJlc2VsZWN0XCI7XG5cbi8vIHNyYy9xdWVyeS91dGlscy9jYXBpdGFsaXplLnRzXG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2Uoc3RyWzBdLCBzdHJbMF0udG9VcHBlckNhc2UoKSk7XG59XG5cbi8vIHNyYy9xdWVyeS91dGlscy9jb3VudE9iamVjdEtleXMudHNcbmZ1bmN0aW9uIGNvdW50T2JqZWN0S2V5cyhvYmopIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChjb25zdCBfa2V5IGluIG9iaikge1xuICAgIGNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuXG4vLyBzcmMvcXVlcnkvZW5kcG9pbnREZWZpbml0aW9ucy50c1xuZnVuY3Rpb24gaXNRdWVyeURlZmluaXRpb24oZSkge1xuICByZXR1cm4gZS50eXBlID09PSBcInF1ZXJ5XCIgLyogcXVlcnkgKi87XG59XG5mdW5jdGlvbiBpc011dGF0aW9uRGVmaW5pdGlvbihlKSB7XG4gIHJldHVybiBlLnR5cGUgPT09IFwibXV0YXRpb25cIiAvKiBtdXRhdGlvbiAqLztcbn1cbmZ1bmN0aW9uIGlzSW5maW5pdGVRdWVyeURlZmluaXRpb24oZSkge1xuICByZXR1cm4gZS50eXBlID09PSBcImluZmluaXRlcXVlcnlcIiAvKiBpbmZpbml0ZXF1ZXJ5ICovO1xufVxuXG4vLyBzcmMvcXVlcnkvdHNIZWxwZXJzLnRzXG5mdW5jdGlvbiBzYWZlQXNzaWduKHRhcmdldCwgLi4uYXJncykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih0YXJnZXQsIC4uLmFyZ3MpO1xufVxuXG4vLyBzcmMvcXVlcnkvcmVhY3QvYnVpbGRIb29rcy50c1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSwgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHsgZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncywgUXVlcnlTdGF0dXMsIHNraXBUb2tlbiB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0L3F1ZXJ5XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRGVidWdWYWx1ZSwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDMsIHVzZUxheW91dEVmZmVjdCwgdXNlTWVtbyBhcyB1c2VNZW1vMiwgdXNlUmVmIGFzIHVzZVJlZjMsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzaGFsbG93RXF1YWwgYXMgc2hhbGxvd0VxdWFsMiB9IGZyb20gXCJyZWFjdC1yZWR1eFwiO1xuXG4vLyBzcmMvcXVlcnkvcmVhY3QvY29uc3RhbnRzLnRzXG52YXIgVU5JTklUSUFMSVpFRF9WQUxVRSA9IFN5bWJvbCgpO1xuXG4vLyBzcmMvcXVlcnkvcmVhY3QvdXNlU2VyaWFsaXplZFN0YWJsZVZhbHVlLnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlTWVtbyB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlU3RhYmxlUXVlcnlBcmdzKHF1ZXJ5QXJncywgc2VyaWFsaXplLCBlbmRwb2ludERlZmluaXRpb24sIGVuZHBvaW50TmFtZSkge1xuICBjb25zdCBpbmNvbWluZyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBxdWVyeUFyZ3MsXG4gICAgc2VyaWFsaXplZDogdHlwZW9mIHF1ZXJ5QXJncyA9PSBcIm9iamVjdFwiID8gc2VyaWFsaXplKHtcbiAgICAgIHF1ZXJ5QXJncyxcbiAgICAgIGVuZHBvaW50RGVmaW5pdGlvbixcbiAgICAgIGVuZHBvaW50TmFtZVxuICAgIH0pIDogcXVlcnlBcmdzXG4gIH0pLCBbcXVlcnlBcmdzLCBzZXJpYWxpemUsIGVuZHBvaW50RGVmaW5pdGlvbiwgZW5kcG9pbnROYW1lXSk7XG4gIGNvbnN0IGNhY2hlID0gdXNlUmVmKGluY29taW5nKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY2FjaGUuY3VycmVudC5zZXJpYWxpemVkICE9PSBpbmNvbWluZy5zZXJpYWxpemVkKSB7XG4gICAgICBjYWNoZS5jdXJyZW50ID0gaW5jb21pbmc7XG4gICAgfVxuICB9LCBbaW5jb21pbmddKTtcbiAgcmV0dXJuIGNhY2hlLmN1cnJlbnQuc2VyaWFsaXplZCA9PT0gaW5jb21pbmcuc2VyaWFsaXplZCA/IGNhY2hlLmN1cnJlbnQucXVlcnlBcmdzIDogcXVlcnlBcmdzO1xufVxuXG4vLyBzcmMvcXVlcnkvcmVhY3QvdXNlU2hhbGxvd1N0YWJsZVZhbHVlLnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MiwgdXNlUmVmIGFzIHVzZVJlZjIgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHNoYWxsb3dFcXVhbCB9IGZyb20gXCJyZWFjdC1yZWR1eFwiO1xuZnVuY3Rpb24gdXNlU2hhbGxvd1N0YWJsZVZhbHVlKHZhbHVlKSB7XG4gIGNvbnN0IGNhY2hlID0gdXNlUmVmMih2YWx1ZSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIGlmICghc2hhbGxvd0VxdWFsKGNhY2hlLmN1cnJlbnQsIHZhbHVlKSkge1xuICAgICAgY2FjaGUuY3VycmVudCA9IHZhbHVlO1xuICAgIH1cbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiBzaGFsbG93RXF1YWwoY2FjaGUuY3VycmVudCwgdmFsdWUpID8gY2FjaGUuY3VycmVudCA6IHZhbHVlO1xufVxuXG4vLyBzcmMvcXVlcnkvcmVhY3QvYnVpbGRIb29rcy50c1xudmFyIGNhblVzZURPTSA9ICgpID0+ICEhKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIpO1xudmFyIGlzRE9NID0gLyogQF9fUFVSRV9fICovIGNhblVzZURPTSgpO1xudmFyIGlzUnVubmluZ0luUmVhY3ROYXRpdmUgPSAoKSA9PiB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSBcIlJlYWN0TmF0aXZlXCI7XG52YXIgaXNSZWFjdE5hdGl2ZSA9IC8qIEBfX1BVUkVfXyAqLyBpc1J1bm5pbmdJblJlYWN0TmF0aXZlKCk7XG52YXIgZ2V0VXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9ICgpID0+IGlzRE9NIHx8IGlzUmVhY3ROYXRpdmUgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3QzO1xudmFyIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSAvKiBAX19QVVJFX18gKi8gZ2V0VXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgpO1xudmFyIG5vUGVuZGluZ1F1ZXJ5U3RhdGVTZWxlY3RvciA9IChzZWxlY3RlZCkgPT4ge1xuICBpZiAoc2VsZWN0ZWQuaXNVbmluaXRpYWxpemVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnNlbGVjdGVkLFxuICAgICAgaXNVbmluaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgIGlzRmV0Y2hpbmc6IHRydWUsXG4gICAgICBpc0xvYWRpbmc6IHNlbGVjdGVkLmRhdGEgIT09IHZvaWQgMCA/IGZhbHNlIDogdHJ1ZSxcbiAgICAgIHN0YXR1czogUXVlcnlTdGF0dXMucGVuZGluZ1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHNlbGVjdGVkO1xufTtcbmZ1bmN0aW9uIHBpY2sob2JqLCAuLi5rZXlzKSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIHJldFtrZXldID0gb2JqW2tleV07XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxudmFyIENPTU1PTl9IT09LX0RFQlVHX0ZJRUxEUyA9IFtcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJpc0xvYWRpbmdcIiwgXCJpc1N1Y2Nlc3NcIiwgXCJpc0Vycm9yXCIsIFwiZXJyb3JcIl07XG5mdW5jdGlvbiBidWlsZEhvb2tzKHtcbiAgYXBpLFxuICBtb2R1bGVPcHRpb25zOiB7XG4gICAgYmF0Y2gsXG4gICAgaG9va3M6IHtcbiAgICAgIHVzZURpc3BhdGNoLFxuICAgICAgdXNlU2VsZWN0b3IsXG4gICAgICB1c2VTdG9yZVxuICAgIH0sXG4gICAgdW5zdGFibGVfX3NpZGVFZmZlY3RzSW5SZW5kZXIsXG4gICAgY3JlYXRlU2VsZWN0b3JcbiAgfSxcbiAgc2VyaWFsaXplUXVlcnlBcmdzLFxuICBjb250ZXh0XG59KSB7XG4gIGNvbnN0IHVzZVBvc3NpYmx5SW1tZWRpYXRlRWZmZWN0ID0gdW5zdGFibGVfX3NpZGVFZmZlY3RzSW5SZW5kZXIgPyAoY2IpID0+IGNiKCkgOiB1c2VFZmZlY3QzO1xuICByZXR1cm4ge1xuICAgIGJ1aWxkUXVlcnlIb29rcyxcbiAgICBidWlsZEluZmluaXRlUXVlcnlIb29rcyxcbiAgICBidWlsZE11dGF0aW9uSG9vayxcbiAgICB1c2VQcmVmZXRjaFxuICB9O1xuICBmdW5jdGlvbiBxdWVyeVN0YXRlUHJlU2VsZWN0b3IoY3VycmVudFN0YXRlLCBsYXN0UmVzdWx0LCBxdWVyeUFyZ3MpIHtcbiAgICBpZiAobGFzdFJlc3VsdD8uZW5kcG9pbnROYW1lICYmIGN1cnJlbnRTdGF0ZS5pc1VuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9ID0gbGFzdFJlc3VsdDtcbiAgICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdO1xuICAgICAgaWYgKHF1ZXJ5QXJncyAhPT0gc2tpcFRva2VuICYmIHNlcmlhbGl6ZVF1ZXJ5QXJncyh7XG4gICAgICAgIHF1ZXJ5QXJnczogbGFzdFJlc3VsdC5vcmlnaW5hbEFyZ3MsXG4gICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbixcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9KSA9PT0gc2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgICAgcXVlcnlBcmdzLFxuICAgICAgICBlbmRwb2ludERlZmluaXRpb24sXG4gICAgICAgIGVuZHBvaW50TmFtZVxuICAgICAgfSkpIGxhc3RSZXN1bHQgPSB2b2lkIDA7XG4gICAgfVxuICAgIGxldCBkYXRhID0gY3VycmVudFN0YXRlLmlzU3VjY2VzcyA/IGN1cnJlbnRTdGF0ZS5kYXRhIDogbGFzdFJlc3VsdD8uZGF0YTtcbiAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSBkYXRhID0gY3VycmVudFN0YXRlLmRhdGE7XG4gICAgY29uc3QgaGFzRGF0YSA9IGRhdGEgIT09IHZvaWQgMDtcbiAgICBjb25zdCBpc0ZldGNoaW5nID0gY3VycmVudFN0YXRlLmlzTG9hZGluZztcbiAgICBjb25zdCBpc0xvYWRpbmcgPSAoIWxhc3RSZXN1bHQgfHwgbGFzdFJlc3VsdC5pc0xvYWRpbmcgfHwgbGFzdFJlc3VsdC5pc1VuaW5pdGlhbGl6ZWQpICYmICFoYXNEYXRhICYmIGlzRmV0Y2hpbmc7XG4gICAgY29uc3QgaXNTdWNjZXNzID0gY3VycmVudFN0YXRlLmlzU3VjY2VzcyB8fCBoYXNEYXRhICYmIChpc0ZldGNoaW5nICYmICFsYXN0UmVzdWx0Py5pc0Vycm9yIHx8IGN1cnJlbnRTdGF0ZS5pc1VuaW5pdGlhbGl6ZWQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jdXJyZW50U3RhdGUsXG4gICAgICBkYXRhLFxuICAgICAgY3VycmVudERhdGE6IGN1cnJlbnRTdGF0ZS5kYXRhLFxuICAgICAgaXNGZXRjaGluZyxcbiAgICAgIGlzTG9hZGluZyxcbiAgICAgIGlzU3VjY2Vzc1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gaW5maW5pdGVRdWVyeVN0YXRlUHJlU2VsZWN0b3IoY3VycmVudFN0YXRlLCBsYXN0UmVzdWx0LCBxdWVyeUFyZ3MpIHtcbiAgICBpZiAobGFzdFJlc3VsdD8uZW5kcG9pbnROYW1lICYmIGN1cnJlbnRTdGF0ZS5pc1VuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9ID0gbGFzdFJlc3VsdDtcbiAgICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdO1xuICAgICAgaWYgKHNlcmlhbGl6ZVF1ZXJ5QXJncyh7XG4gICAgICAgIHF1ZXJ5QXJnczogbGFzdFJlc3VsdC5vcmlnaW5hbEFyZ3MsXG4gICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbixcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9KSA9PT0gc2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgICAgcXVlcnlBcmdzLFxuICAgICAgICBlbmRwb2ludERlZmluaXRpb24sXG4gICAgICAgIGVuZHBvaW50TmFtZVxuICAgICAgfSkpIGxhc3RSZXN1bHQgPSB2b2lkIDA7XG4gICAgfVxuICAgIGxldCBkYXRhID0gY3VycmVudFN0YXRlLmlzU3VjY2VzcyA/IGN1cnJlbnRTdGF0ZS5kYXRhIDogbGFzdFJlc3VsdD8uZGF0YTtcbiAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSBkYXRhID0gY3VycmVudFN0YXRlLmRhdGE7XG4gICAgY29uc3QgaGFzRGF0YSA9IGRhdGEgIT09IHZvaWQgMDtcbiAgICBjb25zdCBpc0ZldGNoaW5nID0gY3VycmVudFN0YXRlLmlzTG9hZGluZztcbiAgICBjb25zdCBpc0xvYWRpbmcgPSAoIWxhc3RSZXN1bHQgfHwgbGFzdFJlc3VsdC5pc0xvYWRpbmcgfHwgbGFzdFJlc3VsdC5pc1VuaW5pdGlhbGl6ZWQpICYmICFoYXNEYXRhICYmIGlzRmV0Y2hpbmc7XG4gICAgY29uc3QgaXNTdWNjZXNzID0gY3VycmVudFN0YXRlLmlzU3VjY2VzcyB8fCBpc0ZldGNoaW5nICYmIGhhc0RhdGE7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmN1cnJlbnRTdGF0ZSxcbiAgICAgIGRhdGEsXG4gICAgICBjdXJyZW50RGF0YTogY3VycmVudFN0YXRlLmRhdGEsXG4gICAgICBpc0ZldGNoaW5nLFxuICAgICAgaXNMb2FkaW5nLFxuICAgICAgaXNTdWNjZXNzXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB1c2VQcmVmZXRjaChlbmRwb2ludE5hbWUsIGRlZmF1bHRPcHRpb25zKSB7XG4gICAgY29uc3QgZGlzcGF0Y2ggPSB1c2VEaXNwYXRjaCgpO1xuICAgIGNvbnN0IHN0YWJsZURlZmF1bHRPcHRpb25zID0gdXNlU2hhbGxvd1N0YWJsZVZhbHVlKGRlZmF1bHRPcHRpb25zKTtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKGFyZywgb3B0aW9ucykgPT4gZGlzcGF0Y2goYXBpLnV0aWwucHJlZmV0Y2goZW5kcG9pbnROYW1lLCBhcmcsIHtcbiAgICAgIC4uLnN0YWJsZURlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pKSwgW2VuZHBvaW50TmFtZSwgZGlzcGF0Y2gsIHN0YWJsZURlZmF1bHRPcHRpb25zXSk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlUXVlcnlTdWJzY3JpcHRpb25Db21tb25JbXBsKGVuZHBvaW50TmFtZSwgYXJnLCB7XG4gICAgcmVmZXRjaE9uUmVjb25uZWN0LFxuICAgIHJlZmV0Y2hPbkZvY3VzLFxuICAgIHJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2UsXG4gICAgc2tpcCA9IGZhbHNlLFxuICAgIHBvbGxpbmdJbnRlcnZhbCA9IDAsXG4gICAgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZCA9IGZhbHNlLFxuICAgIC4uLnJlc3RcbiAgfSA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW5pdGlhdGVcbiAgICB9ID0gYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdO1xuICAgIGNvbnN0IGRpc3BhdGNoID0gdXNlRGlzcGF0Y2goKTtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25TZWxlY3RvcnNSZWYgPSB1c2VSZWYzKHZvaWQgMCk7XG4gICAgaWYgKCFzdWJzY3JpcHRpb25TZWxlY3RvcnNSZWYuY3VycmVudCkge1xuICAgICAgY29uc3QgcmV0dXJuZWRWYWx1ZSA9IGRpc3BhdGNoKGFwaS5pbnRlcm5hbEFjdGlvbnMuaW50ZXJuYWxfZ2V0UlRLUVN1YnNjcmlwdGlvbnMoKSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmV0dXJuZWRWYWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgcmV0dXJuZWRWYWx1ZT8udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzNykgOiBgV2FybmluZzogTWlkZGxld2FyZSBmb3IgUlRLLVF1ZXJ5IEFQSSBhdCByZWR1Y2VyUGF0aCBcIiR7YXBpLnJlZHVjZXJQYXRofVwiIGhhcyBub3QgYmVlbiBhZGRlZCB0byB0aGUgc3RvcmUuXG4gICAgWW91IG11c3QgYWRkIHRoZSBtaWRkbGV3YXJlIGZvciBSVEstUXVlcnkgdG8gZnVuY3Rpb24gY29ycmVjdGx5IWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdWJzY3JpcHRpb25TZWxlY3RvcnNSZWYuY3VycmVudCA9IHJldHVybmVkVmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHN0YWJsZUFyZyA9IHVzZVN0YWJsZVF1ZXJ5QXJncyhcbiAgICAgIHNraXAgPyBza2lwVG9rZW4gOiBhcmcsXG4gICAgICAvLyBFdmVuIGlmIHRoZSB1c2VyIHByb3ZpZGVkIGEgcGVyLWVuZHBvaW50IGBzZXJpYWxpemVRdWVyeUFyZ3NgIHdpdGhcbiAgICAgIC8vIGEgY29uc2lzdGVudCByZXR1cm4gdmFsdWUsIF9oZXJlXyB3ZSB3YW50IHRvIHVzZSB0aGUgZGVmYXVsdCBiZWhhdmlvclxuICAgICAgLy8gc28gd2UgY2FuIHRlbGwgaWYgX2FueXRoaW5nXyBhY3R1YWxseSBjaGFuZ2VkLiBPdGhlcndpc2UsIHdlIGNhbiBlbmQgdXBcbiAgICAgIC8vIHdpdGggYSBjYXNlIHdoZXJlIHRoZSBxdWVyeSBhcmdzIGRpZCBjaGFuZ2UgYnV0IHRoZSBzZXJpYWxpemF0aW9uIGRvZXNuJ3QsXG4gICAgICAvLyBhbmQgdGhlbiB3ZSBuZXZlciB0cnkgdG8gaW5pdGlhdGUgYSByZWZldGNoLlxuICAgICAgZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncyxcbiAgICAgIGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdLFxuICAgICAgZW5kcG9pbnROYW1lXG4gICAgKTtcbiAgICBjb25zdCBzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zID0gdXNlU2hhbGxvd1N0YWJsZVZhbHVlKHtcbiAgICAgIHJlZmV0Y2hPblJlY29ubmVjdCxcbiAgICAgIHJlZmV0Y2hPbkZvY3VzLFxuICAgICAgcG9sbGluZ0ludGVydmFsLFxuICAgICAgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZFxuICAgIH0pO1xuICAgIGNvbnN0IGxhc3RSZW5kZXJIYWRTdWJzY3JpcHRpb24gPSB1c2VSZWYzKGZhbHNlKTtcbiAgICBjb25zdCBpbml0aWFsUGFnZVBhcmFtID0gcmVzdC5pbml0aWFsUGFnZVBhcmFtO1xuICAgIGNvbnN0IHN0YWJsZUluaXRpYWxQYWdlUGFyYW0gPSB1c2VTaGFsbG93U3RhYmxlVmFsdWUoaW5pdGlhbFBhZ2VQYXJhbSk7XG4gICAgY29uc3QgcHJvbWlzZVJlZiA9IHVzZVJlZjModm9pZCAwKTtcbiAgICBsZXQge1xuICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgIHJlcXVlc3RJZFxuICAgIH0gPSBwcm9taXNlUmVmLmN1cnJlbnQgfHwge307XG4gICAgbGV0IGN1cnJlbnRSZW5kZXJIYXNTdWJzY3JpcHRpb24gPSBmYWxzZTtcbiAgICBpZiAocXVlcnlDYWNoZUtleSAmJiByZXF1ZXN0SWQpIHtcbiAgICAgIGN1cnJlbnRSZW5kZXJIYXNTdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb25TZWxlY3RvcnNSZWYuY3VycmVudC5pc1JlcXVlc3RTdWJzY3JpYmVkKHF1ZXJ5Q2FjaGVLZXksIHJlcXVlc3RJZCk7XG4gICAgfVxuICAgIGNvbnN0IHN1YnNjcmlwdGlvblJlbW92ZWQgPSAhY3VycmVudFJlbmRlckhhc1N1YnNjcmlwdGlvbiAmJiBsYXN0UmVuZGVySGFkU3Vic2NyaXB0aW9uLmN1cnJlbnQ7XG4gICAgdXNlUG9zc2libHlJbW1lZGlhdGVFZmZlY3QoKCkgPT4ge1xuICAgICAgbGFzdFJlbmRlckhhZFN1YnNjcmlwdGlvbi5jdXJyZW50ID0gY3VycmVudFJlbmRlckhhc1N1YnNjcmlwdGlvbjtcbiAgICB9KTtcbiAgICB1c2VQb3NzaWJseUltbWVkaWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoc3Vic2NyaXB0aW9uUmVtb3ZlZCkge1xuICAgICAgICBwcm9taXNlUmVmLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfSwgW3N1YnNjcmlwdGlvblJlbW92ZWRdKTtcbiAgICB1c2VQb3NzaWJseUltbWVkaWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBsYXN0UHJvbWlzZSA9IHByb21pc2VSZWYuY3VycmVudDtcbiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJyZW1vdmVNZU9uQ29tcGlsYXRpb25cIikge1xuICAgICAgICBjb25zb2xlLmxvZyhzdWJzY3JpcHRpb25SZW1vdmVkKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFibGVBcmcgPT09IHNraXBUb2tlbikge1xuICAgICAgICBsYXN0UHJvbWlzZT8udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgcHJvbWlzZVJlZi5jdXJyZW50ID0gdm9pZCAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsYXN0U3Vic2NyaXB0aW9uT3B0aW9ucyA9IHByb21pc2VSZWYuY3VycmVudD8uc3Vic2NyaXB0aW9uT3B0aW9ucztcbiAgICAgIGlmICghbGFzdFByb21pc2UgfHwgbGFzdFByb21pc2UuYXJnICE9PSBzdGFibGVBcmcpIHtcbiAgICAgICAgbGFzdFByb21pc2U/LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBkaXNwYXRjaChpbml0aWF0ZShzdGFibGVBcmcsIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb25PcHRpb25zOiBzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zLFxuICAgICAgICAgIGZvcmNlUmVmZXRjaDogcmVmZXRjaE9uTW91bnRPckFyZ0NoYW5nZSxcbiAgICAgICAgICAuLi5pc0luZmluaXRlUXVlcnlEZWZpbml0aW9uKGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdKSA/IHtcbiAgICAgICAgICAgIGluaXRpYWxQYWdlUGFyYW06IHN0YWJsZUluaXRpYWxQYWdlUGFyYW1cbiAgICAgICAgICB9IDoge31cbiAgICAgICAgfSkpO1xuICAgICAgICBwcm9taXNlUmVmLmN1cnJlbnQgPSBwcm9taXNlO1xuICAgICAgfSBlbHNlIGlmIChzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zICE9PSBsYXN0U3Vic2NyaXB0aW9uT3B0aW9ucykge1xuICAgICAgICBsYXN0UHJvbWlzZS51cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zKHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sIFtkaXNwYXRjaCwgaW5pdGlhdGUsIHJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2UsIHN0YWJsZUFyZywgc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucywgc3Vic2NyaXB0aW9uUmVtb3ZlZCwgc3RhYmxlSW5pdGlhbFBhZ2VQYXJhbSwgZW5kcG9pbnROYW1lXSk7XG4gICAgcmV0dXJuIFtwcm9taXNlUmVmLCBkaXNwYXRjaCwgaW5pdGlhdGUsIHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnNdO1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkVXNlUXVlcnlTdGF0ZShlbmRwb2ludE5hbWUsIHByZVNlbGVjdG9yKSB7XG4gICAgY29uc3QgdXNlUXVlcnlTdGF0ZSA9IChhcmcsIHtcbiAgICAgIHNraXAgPSBmYWxzZSxcbiAgICAgIHNlbGVjdEZyb21SZXN1bHRcbiAgICB9ID0ge30pID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2VsZWN0XG4gICAgICB9ID0gYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdO1xuICAgICAgY29uc3Qgc3RhYmxlQXJnID0gdXNlU3RhYmxlUXVlcnlBcmdzKHNraXAgPyBza2lwVG9rZW4gOiBhcmcsIHNlcmlhbGl6ZVF1ZXJ5QXJncywgY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZV0sIGVuZHBvaW50TmFtZSk7XG4gICAgICBjb25zdCBsYXN0VmFsdWUgPSB1c2VSZWYzKHZvaWQgMCk7XG4gICAgICBjb25zdCBzZWxlY3REZWZhdWx0UmVzdWx0ID0gdXNlTWVtbzIoKCkgPT4gKFxuICAgICAgICAvLyBOb3JtYWxseSB0cy1pZ25vcmVzIGFyZSBiYWQgYW5kIHNob3VsZCBiZSBhdm9pZGVkLCBidXQgd2UncmVcbiAgICAgICAgLy8gYWxyZWFkeSBjYXN0aW5nIHRoaXMgc2VsZWN0b3IgdG8gYmUgYFNlbGVjdG9yPGFueT5gIGFueXdheSxcbiAgICAgICAgLy8gc28gdGhlIGluY29uc2lzdGVuY2llcyBkb24ndCBtYXR0ZXIgaGVyZVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNyZWF0ZVNlbGVjdG9yKFtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgc2VsZWN0KHN0YWJsZUFyZyksXG4gICAgICAgICAgKF8sIGxhc3RSZXN1bHQpID0+IGxhc3RSZXN1bHQsXG4gICAgICAgICAgKF8pID0+IHN0YWJsZUFyZ1xuICAgICAgICBdLCBwcmVTZWxlY3Rvciwge1xuICAgICAgICAgIG1lbW9pemVPcHRpb25zOiB7XG4gICAgICAgICAgICByZXN1bHRFcXVhbGl0eUNoZWNrOiBzaGFsbG93RXF1YWwyXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKSwgW3NlbGVjdCwgc3RhYmxlQXJnXSk7XG4gICAgICBjb25zdCBxdWVyeVNlbGVjdG9yID0gdXNlTWVtbzIoKCkgPT4gc2VsZWN0RnJvbVJlc3VsdCA/IGNyZWF0ZVNlbGVjdG9yKFtzZWxlY3REZWZhdWx0UmVzdWx0XSwgc2VsZWN0RnJvbVJlc3VsdCwge1xuICAgICAgICBkZXZNb2RlQ2hlY2tzOiB7XG4gICAgICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiBcIm5ldmVyXCJcbiAgICAgICAgfVxuICAgICAgfSkgOiBzZWxlY3REZWZhdWx0UmVzdWx0LCBbc2VsZWN0RGVmYXVsdFJlc3VsdCwgc2VsZWN0RnJvbVJlc3VsdF0pO1xuICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gdXNlU2VsZWN0b3IoKHN0YXRlKSA9PiBxdWVyeVNlbGVjdG9yKHN0YXRlLCBsYXN0VmFsdWUuY3VycmVudCksIHNoYWxsb3dFcXVhbDIpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZSgpO1xuICAgICAgY29uc3QgbmV3TGFzdFZhbHVlID0gc2VsZWN0RGVmYXVsdFJlc3VsdChzdG9yZS5nZXRTdGF0ZSgpLCBsYXN0VmFsdWUuY3VycmVudCk7XG4gICAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGFzdFZhbHVlLmN1cnJlbnQgPSBuZXdMYXN0VmFsdWU7XG4gICAgICB9LCBbbmV3TGFzdFZhbHVlXSk7XG4gICAgICByZXR1cm4gY3VycmVudFN0YXRlO1xuICAgIH07XG4gICAgcmV0dXJuIHVzZVF1ZXJ5U3RhdGU7XG4gIH1cbiAgZnVuY3Rpb24gdXNlUHJvbWlzZVJlZlVuc3Vic2NyaWJlT25Vbm1vdW50KHByb21pc2VSZWYpIHtcbiAgICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHByb21pc2VSZWYuY3VycmVudD8udW5zdWJzY3JpYmU/LigpO1xuICAgICAgICBwcm9taXNlUmVmLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICB9O1xuICAgIH0sIFtwcm9taXNlUmVmXSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVmZXRjaE9yRXJyb3JJZlVubW91bnRlZChwcm9taXNlUmVmKSB7XG4gICAgaWYgKCFwcm9taXNlUmVmLmN1cnJlbnQpIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIoMzgpIDogXCJDYW5ub3QgcmVmZXRjaCBhIHF1ZXJ5IHRoYXQgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQgeWV0LlwiKTtcbiAgICByZXR1cm4gcHJvbWlzZVJlZi5jdXJyZW50LnJlZmV0Y2goKTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZFF1ZXJ5SG9va3MoZW5kcG9pbnROYW1lKSB7XG4gICAgY29uc3QgdXNlUXVlcnlTdWJzY3JpcHRpb24gPSAoYXJnLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIGNvbnN0IFtwcm9taXNlUmVmXSA9IHVzZVF1ZXJ5U3Vic2NyaXB0aW9uQ29tbW9uSW1wbChlbmRwb2ludE5hbWUsIGFyZywgb3B0aW9ucyk7XG4gICAgICB1c2VQcm9taXNlUmVmVW5zdWJzY3JpYmVPblVubW91bnQocHJvbWlzZVJlZik7XG4gICAgICByZXR1cm4gdXNlTWVtbzIoKCkgPT4gKHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWV0aG9kIHRvIG1hbnVhbGx5IHJlZmV0Y2ggZGF0YSBmb3IgdGhlIHF1ZXJ5XG4gICAgICAgICAqL1xuICAgICAgICByZWZldGNoOiAoKSA9PiByZWZldGNoT3JFcnJvcklmVW5tb3VudGVkKHByb21pc2VSZWYpXG4gICAgICB9KSwgW3Byb21pc2VSZWZdKTtcbiAgICB9O1xuICAgIGNvbnN0IHVzZUxhenlRdWVyeVN1YnNjcmlwdGlvbiA9ICh7XG4gICAgICByZWZldGNoT25SZWNvbm5lY3QsXG4gICAgICByZWZldGNoT25Gb2N1cyxcbiAgICAgIHBvbGxpbmdJbnRlcnZhbCA9IDAsXG4gICAgICBza2lwUG9sbGluZ0lmVW5mb2N1c2VkID0gZmFsc2VcbiAgICB9ID0ge30pID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaW5pdGlhdGVcbiAgICAgIH0gPSBhcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV07XG4gICAgICBjb25zdCBkaXNwYXRjaCA9IHVzZURpc3BhdGNoKCk7XG4gICAgICBjb25zdCBbYXJnLCBzZXRBcmddID0gdXNlU3RhdGUoVU5JTklUSUFMSVpFRF9WQUxVRSk7XG4gICAgICBjb25zdCBwcm9taXNlUmVmID0gdXNlUmVmMyh2b2lkIDApO1xuICAgICAgY29uc3Qgc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucyA9IHVzZVNoYWxsb3dTdGFibGVWYWx1ZSh7XG4gICAgICAgIHJlZmV0Y2hPblJlY29ubmVjdCxcbiAgICAgICAgcmVmZXRjaE9uRm9jdXMsXG4gICAgICAgIHBvbGxpbmdJbnRlcnZhbCxcbiAgICAgICAgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZFxuICAgICAgfSk7XG4gICAgICB1c2VQb3NzaWJseUltbWVkaWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhc3RTdWJzY3JpcHRpb25PcHRpb25zID0gcHJvbWlzZVJlZi5jdXJyZW50Py5zdWJzY3JpcHRpb25PcHRpb25zO1xuICAgICAgICBpZiAoc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucyAhPT0gbGFzdFN1YnNjcmlwdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgICBwcm9taXNlUmVmLmN1cnJlbnQ/LnVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnMoc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0sIFtzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zXSk7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb25PcHRpb25zUmVmID0gdXNlUmVmMyhzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zKTtcbiAgICAgIHVzZVBvc3NpYmx5SW1tZWRpYXRlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3Vic2NyaXB0aW9uT3B0aW9uc1JlZi5jdXJyZW50ID0gc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucztcbiAgICAgIH0sIFtzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zXSk7XG4gICAgICBjb25zdCB0cmlnZ2VyID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24oYXJnMiwgcHJlZmVyQ2FjaGVWYWx1ZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBwcm9taXNlO1xuICAgICAgICBiYXRjaCgoKSA9PiB7XG4gICAgICAgICAgcHJvbWlzZVJlZi5jdXJyZW50Py51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHByb21pc2VSZWYuY3VycmVudCA9IHByb21pc2UgPSBkaXNwYXRjaChpbml0aWF0ZShhcmcyLCB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25PcHRpb25zOiBzdWJzY3JpcHRpb25PcHRpb25zUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBmb3JjZVJlZmV0Y2g6ICFwcmVmZXJDYWNoZVZhbHVlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHNldEFyZyhhcmcyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgfSwgW2Rpc3BhdGNoLCBpbml0aWF0ZV0pO1xuICAgICAgY29uc3QgcmVzZXQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChwcm9taXNlUmVmLmN1cnJlbnQ/LnF1ZXJ5Q2FjaGVLZXkpIHtcbiAgICAgICAgICBkaXNwYXRjaChhcGkuaW50ZXJuYWxBY3Rpb25zLnJlbW92ZVF1ZXJ5UmVzdWx0KHtcbiAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXk6IHByb21pc2VSZWYuY3VycmVudD8ucXVlcnlDYWNoZUtleVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBwcm9taXNlUmVmPy5jdXJyZW50Py51bnN1YnNjcmliZSgpO1xuICAgICAgICB9O1xuICAgICAgfSwgW10pO1xuICAgICAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgICAgIGlmIChhcmcgIT09IFVOSU5JVElBTElaRURfVkFMVUUgJiYgIXByb21pc2VSZWYuY3VycmVudCkge1xuICAgICAgICAgIHRyaWdnZXIoYXJnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSwgW2FyZywgdHJpZ2dlcl0pO1xuICAgICAgcmV0dXJuIHVzZU1lbW8yKCgpID0+IFt0cmlnZ2VyLCBhcmcsIHtcbiAgICAgICAgcmVzZXRcbiAgICAgIH1dLCBbdHJpZ2dlciwgYXJnLCByZXNldF0pO1xuICAgIH07XG4gICAgY29uc3QgdXNlUXVlcnlTdGF0ZSA9IGJ1aWxkVXNlUXVlcnlTdGF0ZShlbmRwb2ludE5hbWUsIHF1ZXJ5U3RhdGVQcmVTZWxlY3Rvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZVF1ZXJ5U3RhdGUsXG4gICAgICB1c2VRdWVyeVN1YnNjcmlwdGlvbixcbiAgICAgIHVzZUxhenlRdWVyeVN1YnNjcmlwdGlvbixcbiAgICAgIHVzZUxhenlRdWVyeShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IFt0cmlnZ2VyLCBhcmcsIHtcbiAgICAgICAgICByZXNldFxuICAgICAgICB9XSA9IHVzZUxhenlRdWVyeVN1YnNjcmlwdGlvbihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcXVlcnlTdGF0ZVJlc3VsdHMgPSB1c2VRdWVyeVN0YXRlKGFyZywge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgc2tpcDogYXJnID09PSBVTklOSVRJQUxJWkVEX1ZBTFVFXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpbmZvID0gdXNlTWVtbzIoKCkgPT4gKHtcbiAgICAgICAgICBsYXN0QXJnOiBhcmdcbiAgICAgICAgfSksIFthcmddKTtcbiAgICAgICAgcmV0dXJuIHVzZU1lbW8yKCgpID0+IFt0cmlnZ2VyLCB7XG4gICAgICAgICAgLi4ucXVlcnlTdGF0ZVJlc3VsdHMsXG4gICAgICAgICAgcmVzZXRcbiAgICAgICAgfSwgaW5mb10sIFt0cmlnZ2VyLCBxdWVyeVN0YXRlUmVzdWx0cywgcmVzZXQsIGluZm9dKTtcbiAgICAgIH0sXG4gICAgICB1c2VRdWVyeShhcmcsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcXVlcnlTdWJzY3JpcHRpb25SZXN1bHRzID0gdXNlUXVlcnlTdWJzY3JpcHRpb24oYXJnLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcXVlcnlTdGF0ZVJlc3VsdHMgPSB1c2VRdWVyeVN0YXRlKGFyZywge1xuICAgICAgICAgIHNlbGVjdEZyb21SZXN1bHQ6IGFyZyA9PT0gc2tpcFRva2VuIHx8IG9wdGlvbnM/LnNraXAgPyB2b2lkIDAgOiBub1BlbmRpbmdRdWVyeVN0YXRlU2VsZWN0b3IsXG4gICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGVidWdWYWx1ZSA9IHBpY2socXVlcnlTdGF0ZVJlc3VsdHMsIC4uLkNPTU1PTl9IT09LX0RFQlVHX0ZJRUxEUyk7XG4gICAgICAgIHVzZURlYnVnVmFsdWUoZGVidWdWYWx1ZSk7XG4gICAgICAgIHJldHVybiB1c2VNZW1vMigoKSA9PiAoe1xuICAgICAgICAgIC4uLnF1ZXJ5U3RhdGVSZXN1bHRzLFxuICAgICAgICAgIC4uLnF1ZXJ5U3Vic2NyaXB0aW9uUmVzdWx0c1xuICAgICAgICB9KSwgW3F1ZXJ5U3RhdGVSZXN1bHRzLCBxdWVyeVN1YnNjcmlwdGlvblJlc3VsdHNdKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkSW5maW5pdGVRdWVyeUhvb2tzKGVuZHBvaW50TmFtZSkge1xuICAgIGNvbnN0IHVzZUluZmluaXRlUXVlcnlTdWJzY3JpcHRpb24gPSAoYXJnLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIGNvbnN0IFtwcm9taXNlUmVmLCBkaXNwYXRjaCwgaW5pdGlhdGUsIHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnNdID0gdXNlUXVlcnlTdWJzY3JpcHRpb25Db21tb25JbXBsKGVuZHBvaW50TmFtZSwgYXJnLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbk9wdGlvbnNSZWYgPSB1c2VSZWYzKHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnMpO1xuICAgICAgdXNlUG9zc2libHlJbW1lZGlhdGVFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdWJzY3JpcHRpb25PcHRpb25zUmVmLmN1cnJlbnQgPSBzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zO1xuICAgICAgfSwgW3N0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnNdKTtcbiAgICAgIGNvbnN0IHRyaWdnZXIgPSB1c2VDYWxsYmFjayhmdW5jdGlvbihhcmcyLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgbGV0IHByb21pc2U7XG4gICAgICAgIGJhdGNoKCgpID0+IHtcbiAgICAgICAgICBwcm9taXNlUmVmLmN1cnJlbnQ/LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgcHJvbWlzZVJlZi5jdXJyZW50ID0gcHJvbWlzZSA9IGRpc3BhdGNoKGluaXRpYXRlKGFyZzIsIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbk9wdGlvbnM6IHN1YnNjcmlwdGlvbk9wdGlvbnNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGRpcmVjdGlvblxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgfSwgW3Byb21pc2VSZWYsIGRpc3BhdGNoLCBpbml0aWF0ZV0pO1xuICAgICAgdXNlUHJvbWlzZVJlZlVuc3Vic2NyaWJlT25Vbm1vdW50KHByb21pc2VSZWYpO1xuICAgICAgcmV0dXJuIHVzZU1lbW8yKCgpID0+IHtcbiAgICAgICAgY29uc3QgZmV0Y2hOZXh0UGFnZSA9ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gdHJpZ2dlcihhcmcsIFwiZm9yd2FyZFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmV0Y2hQcmV2aW91c1BhZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRyaWdnZXIoYXJnLCBcImJhY2t3YXJkXCIpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyaWdnZXIsXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQSBtZXRob2QgdG8gbWFudWFsbHkgcmVmZXRjaCBkYXRhIGZvciB0aGUgcXVlcnlcbiAgICAgICAgICAgKi9cbiAgICAgICAgICByZWZldGNoOiAoKSA9PiByZWZldGNoT3JFcnJvcklmVW5tb3VudGVkKHByb21pc2VSZWYpLFxuICAgICAgICAgIGZldGNoTmV4dFBhZ2UsXG4gICAgICAgICAgZmV0Y2hQcmV2aW91c1BhZ2VcbiAgICAgICAgfTtcbiAgICAgIH0sIFtwcm9taXNlUmVmLCB0cmlnZ2VyLCBhcmddKTtcbiAgICB9O1xuICAgIGNvbnN0IHVzZUluZmluaXRlUXVlcnlTdGF0ZSA9IGJ1aWxkVXNlUXVlcnlTdGF0ZShlbmRwb2ludE5hbWUsIGluZmluaXRlUXVlcnlTdGF0ZVByZVNlbGVjdG9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgdXNlSW5maW5pdGVRdWVyeVN0YXRlLFxuICAgICAgdXNlSW5maW5pdGVRdWVyeVN1YnNjcmlwdGlvbixcbiAgICAgIHVzZUluZmluaXRlUXVlcnkoYXJnLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICByZWZldGNoLFxuICAgICAgICAgIGZldGNoTmV4dFBhZ2UsXG4gICAgICAgICAgZmV0Y2hQcmV2aW91c1BhZ2VcbiAgICAgICAgfSA9IHVzZUluZmluaXRlUXVlcnlTdWJzY3JpcHRpb24oYXJnLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcXVlcnlTdGF0ZVJlc3VsdHMgPSB1c2VJbmZpbml0ZVF1ZXJ5U3RhdGUoYXJnLCB7XG4gICAgICAgICAgc2VsZWN0RnJvbVJlc3VsdDogYXJnID09PSBza2lwVG9rZW4gfHwgb3B0aW9ucz8uc2tpcCA/IHZvaWQgMCA6IG5vUGVuZGluZ1F1ZXJ5U3RhdGVTZWxlY3RvcixcbiAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkZWJ1Z1ZhbHVlID0gcGljayhxdWVyeVN0YXRlUmVzdWx0cywgLi4uQ09NTU9OX0hPT0tfREVCVUdfRklFTERTLCBcImhhc05leHRQYWdlXCIsIFwiaGFzUHJldmlvdXNQYWdlXCIpO1xuICAgICAgICB1c2VEZWJ1Z1ZhbHVlKGRlYnVnVmFsdWUpO1xuICAgICAgICByZXR1cm4gdXNlTWVtbzIoKCkgPT4gKHtcbiAgICAgICAgICAuLi5xdWVyeVN0YXRlUmVzdWx0cyxcbiAgICAgICAgICBmZXRjaE5leHRQYWdlLFxuICAgICAgICAgIGZldGNoUHJldmlvdXNQYWdlLFxuICAgICAgICAgIHJlZmV0Y2hcbiAgICAgICAgfSksIFtxdWVyeVN0YXRlUmVzdWx0cywgZmV0Y2hOZXh0UGFnZSwgZmV0Y2hQcmV2aW91c1BhZ2UsIHJlZmV0Y2hdKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkTXV0YXRpb25Ib29rKG5hbWUpIHtcbiAgICByZXR1cm4gKHtcbiAgICAgIHNlbGVjdEZyb21SZXN1bHQsXG4gICAgICBmaXhlZENhY2hlS2V5XG4gICAgfSA9IHt9KSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNlbGVjdCxcbiAgICAgICAgaW5pdGlhdGVcbiAgICAgIH0gPSBhcGkuZW5kcG9pbnRzW25hbWVdO1xuICAgICAgY29uc3QgZGlzcGF0Y2ggPSB1c2VEaXNwYXRjaCgpO1xuICAgICAgY29uc3QgW3Byb21pc2UsIHNldFByb21pc2VdID0gdXNlU3RhdGUoKTtcbiAgICAgIHVzZUVmZmVjdDMoKCkgPT4gKCkgPT4ge1xuICAgICAgICBpZiAoIXByb21pc2U/LmFyZy5maXhlZENhY2hlS2V5KSB7XG4gICAgICAgICAgcHJvbWlzZT8ucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfSwgW3Byb21pc2VdKTtcbiAgICAgIGNvbnN0IHRyaWdnZXJNdXRhdGlvbiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uKGFyZykge1xuICAgICAgICBjb25zdCBwcm9taXNlMiA9IGRpc3BhdGNoKGluaXRpYXRlKGFyZywge1xuICAgICAgICAgIGZpeGVkQ2FjaGVLZXlcbiAgICAgICAgfSkpO1xuICAgICAgICBzZXRQcm9taXNlKHByb21pc2UyKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2UyO1xuICAgICAgfSwgW2Rpc3BhdGNoLCBpbml0aWF0ZSwgZml4ZWRDYWNoZUtleV0pO1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXF1ZXN0SWRcbiAgICAgIH0gPSBwcm9taXNlIHx8IHt9O1xuICAgICAgY29uc3Qgc2VsZWN0RGVmYXVsdFJlc3VsdCA9IHVzZU1lbW8yKCgpID0+IHNlbGVjdCh7XG4gICAgICAgIGZpeGVkQ2FjaGVLZXksXG4gICAgICAgIHJlcXVlc3RJZDogcHJvbWlzZT8ucmVxdWVzdElkXG4gICAgICB9KSwgW2ZpeGVkQ2FjaGVLZXksIHByb21pc2UsIHNlbGVjdF0pO1xuICAgICAgY29uc3QgbXV0YXRpb25TZWxlY3RvciA9IHVzZU1lbW8yKCgpID0+IHNlbGVjdEZyb21SZXN1bHQgPyBjcmVhdGVTZWxlY3Rvcihbc2VsZWN0RGVmYXVsdFJlc3VsdF0sIHNlbGVjdEZyb21SZXN1bHQpIDogc2VsZWN0RGVmYXVsdFJlc3VsdCwgW3NlbGVjdEZyb21SZXN1bHQsIHNlbGVjdERlZmF1bHRSZXN1bHRdKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHVzZVNlbGVjdG9yKG11dGF0aW9uU2VsZWN0b3IsIHNoYWxsb3dFcXVhbDIpO1xuICAgICAgY29uc3Qgb3JpZ2luYWxBcmdzID0gZml4ZWRDYWNoZUtleSA9PSBudWxsID8gcHJvbWlzZT8uYXJnLm9yaWdpbmFsQXJncyA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IHJlc2V0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBiYXRjaCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHByb21pc2UpIHtcbiAgICAgICAgICAgIHNldFByb21pc2Uodm9pZCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZpeGVkQ2FjaGVLZXkpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKGFwaS5pbnRlcm5hbEFjdGlvbnMucmVtb3ZlTXV0YXRpb25SZXN1bHQoe1xuICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgIGZpeGVkQ2FjaGVLZXlcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSwgW2Rpc3BhdGNoLCBmaXhlZENhY2hlS2V5LCBwcm9taXNlLCByZXF1ZXN0SWRdKTtcbiAgICAgIGNvbnN0IGRlYnVnVmFsdWUgPSBwaWNrKGN1cnJlbnRTdGF0ZSwgLi4uQ09NTU9OX0hPT0tfREVCVUdfRklFTERTLCBcImVuZHBvaW50TmFtZVwiKTtcbiAgICAgIHVzZURlYnVnVmFsdWUoZGVidWdWYWx1ZSk7XG4gICAgICBjb25zdCBmaW5hbFN0YXRlID0gdXNlTWVtbzIoKCkgPT4gKHtcbiAgICAgICAgLi4uY3VycmVudFN0YXRlLFxuICAgICAgICBvcmlnaW5hbEFyZ3MsXG4gICAgICAgIHJlc2V0XG4gICAgICB9KSwgW2N1cnJlbnRTdGF0ZSwgb3JpZ2luYWxBcmdzLCByZXNldF0pO1xuICAgICAgcmV0dXJuIHVzZU1lbW8yKCgpID0+IFt0cmlnZ2VyTXV0YXRpb24sIGZpbmFsU3RhdGVdLCBbdHJpZ2dlck11dGF0aW9uLCBmaW5hbFN0YXRlXSk7XG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvcXVlcnkvcmVhY3QvbW9kdWxlLnRzXG52YXIgcmVhY3RIb29rc01vZHVsZU5hbWUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKCk7XG52YXIgcmVhY3RIb29rc01vZHVsZSA9ICh7XG4gIGJhdGNoID0gcnJCYXRjaCxcbiAgaG9va3MgPSB7XG4gICAgdXNlRGlzcGF0Y2g6IHJyVXNlRGlzcGF0Y2gsXG4gICAgdXNlU2VsZWN0b3I6IHJyVXNlU2VsZWN0b3IsXG4gICAgdXNlU3RvcmU6IHJyVXNlU3RvcmVcbiAgfSxcbiAgY3JlYXRlU2VsZWN0b3IgPSBfY3JlYXRlU2VsZWN0b3IsXG4gIHVuc3RhYmxlX19zaWRlRWZmZWN0c0luUmVuZGVyID0gZmFsc2UsXG4gIC4uLnJlc3Rcbn0gPSB7fSkgPT4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3QgaG9va05hbWVzID0gW1widXNlRGlzcGF0Y2hcIiwgXCJ1c2VTZWxlY3RvclwiLCBcInVzZVN0b3JlXCJdO1xuICAgIGxldCB3YXJuZWQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGhvb2tOYW1lIG9mIGhvb2tOYW1lcykge1xuICAgICAgaWYgKGNvdW50T2JqZWN0S2V5cyhyZXN0KSA+IDApIHtcbiAgICAgICAgaWYgKHJlc3RbaG9va05hbWVdKSB7XG4gICAgICAgICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkFzIG9mIFJUSyAyLjAsIHRoZSBob29rcyBub3cgbmVlZCB0byBiZSBzcGVjaWZpZWQgYXMgb25lIG9iamVjdCwgcHJvdmlkZWQgdW5kZXIgYSBgaG9va3NgIGtleTpcXG5gcmVhY3RIb29rc01vZHVsZSh7IGhvb2tzOiB7IHVzZURpc3BhdGNoLCB1c2VTZWxlY3RvciwgdXNlU3RvcmUgfSB9KWBcIik7XG4gICAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBob29rc1tob29rTmFtZV0gPSByZXN0W2hvb2tOYW1lXTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaG9va3NbaG9va05hbWVdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMygzNikgOiBgV2hlbiB1c2luZyBjdXN0b20gaG9va3MgZm9yIGNvbnRleHQsIGFsbCAke2hvb2tOYW1lcy5sZW5ndGh9IGhvb2tzIG5lZWQgdG8gYmUgcHJvdmlkZWQ6ICR7aG9va05hbWVzLmpvaW4oXCIsIFwiKX0uXG5Ib29rICR7aG9va05hbWV9IHdhcyBlaXRoZXIgbm90IHByb3ZpZGVkIG9yIG5vdCBhIGZ1bmN0aW9uLmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6IHJlYWN0SG9va3NNb2R1bGVOYW1lLFxuICAgIGluaXQoYXBpLCB7XG4gICAgICBzZXJpYWxpemVRdWVyeUFyZ3NcbiAgICB9LCBjb250ZXh0KSB7XG4gICAgICBjb25zdCBhbnlBcGkgPSBhcGk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGJ1aWxkUXVlcnlIb29rcyxcbiAgICAgICAgYnVpbGRJbmZpbml0ZVF1ZXJ5SG9va3MsXG4gICAgICAgIGJ1aWxkTXV0YXRpb25Ib29rLFxuICAgICAgICB1c2VQcmVmZXRjaFxuICAgICAgfSA9IGJ1aWxkSG9va3Moe1xuICAgICAgICBhcGksXG4gICAgICAgIG1vZHVsZU9wdGlvbnM6IHtcbiAgICAgICAgICBiYXRjaCxcbiAgICAgICAgICBob29rcyxcbiAgICAgICAgICB1bnN0YWJsZV9fc2lkZUVmZmVjdHNJblJlbmRlcixcbiAgICAgICAgICBjcmVhdGVTZWxlY3RvclxuICAgICAgICB9LFxuICAgICAgICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pO1xuICAgICAgc2FmZUFzc2lnbihhbnlBcGksIHtcbiAgICAgICAgdXNlUHJlZmV0Y2hcbiAgICAgIH0pO1xuICAgICAgc2FmZUFzc2lnbihjb250ZXh0LCB7XG4gICAgICAgIGJhdGNoXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluamVjdEVuZHBvaW50KGVuZHBvaW50TmFtZSwgZGVmaW5pdGlvbikge1xuICAgICAgICAgIGlmIChpc1F1ZXJ5RGVmaW5pdGlvbihkZWZpbml0aW9uKSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICB1c2VRdWVyeSxcbiAgICAgICAgICAgICAgdXNlTGF6eVF1ZXJ5LFxuICAgICAgICAgICAgICB1c2VMYXp5UXVlcnlTdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgIHVzZVF1ZXJ5U3RhdGUsXG4gICAgICAgICAgICAgIHVzZVF1ZXJ5U3Vic2NyaXB0aW9uXG4gICAgICAgICAgICB9ID0gYnVpbGRRdWVyeUhvb2tzKGVuZHBvaW50TmFtZSk7XG4gICAgICAgICAgICBzYWZlQXNzaWduKGFueUFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXSwge1xuICAgICAgICAgICAgICB1c2VRdWVyeSxcbiAgICAgICAgICAgICAgdXNlTGF6eVF1ZXJ5LFxuICAgICAgICAgICAgICB1c2VMYXp5UXVlcnlTdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgIHVzZVF1ZXJ5U3RhdGUsXG4gICAgICAgICAgICAgIHVzZVF1ZXJ5U3Vic2NyaXB0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFwaVtgdXNlJHtjYXBpdGFsaXplKGVuZHBvaW50TmFtZSl9UXVlcnlgXSA9IHVzZVF1ZXJ5O1xuICAgICAgICAgICAgYXBpW2B1c2VMYXp5JHtjYXBpdGFsaXplKGVuZHBvaW50TmFtZSl9UXVlcnlgXSA9IHVzZUxhenlRdWVyeTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzTXV0YXRpb25EZWZpbml0aW9uKGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VNdXRhdGlvbiA9IGJ1aWxkTXV0YXRpb25Ib29rKGVuZHBvaW50TmFtZSk7XG4gICAgICAgICAgICBzYWZlQXNzaWduKGFueUFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXSwge1xuICAgICAgICAgICAgICB1c2VNdXRhdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhcGlbYHVzZSR7Y2FwaXRhbGl6ZShlbmRwb2ludE5hbWUpfU11dGF0aW9uYF0gPSB1c2VNdXRhdGlvbjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzSW5maW5pdGVRdWVyeURlZmluaXRpb24oZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgdXNlSW5maW5pdGVRdWVyeSxcbiAgICAgICAgICAgICAgdXNlSW5maW5pdGVRdWVyeVN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgdXNlSW5maW5pdGVRdWVyeVN0YXRlXG4gICAgICAgICAgICB9ID0gYnVpbGRJbmZpbml0ZVF1ZXJ5SG9va3MoZW5kcG9pbnROYW1lKTtcbiAgICAgICAgICAgIHNhZmVBc3NpZ24oYW55QXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdLCB7XG4gICAgICAgICAgICAgIHVzZUluZmluaXRlUXVlcnksXG4gICAgICAgICAgICAgIHVzZUluZmluaXRlUXVlcnlTdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgIHVzZUluZmluaXRlUXVlcnlTdGF0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhcGlbYHVzZSR7Y2FwaXRhbGl6ZShlbmRwb2ludE5hbWUpfUluZmluaXRlUXVlcnlgXSA9IHVzZUluZmluaXRlUXVlcnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIHNyYy9xdWVyeS9yZWFjdC9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcIkByZWR1eGpzL3Rvb2xraXQvcXVlcnlcIjtcblxuLy8gc3JjL3F1ZXJ5L3JlYWN0L0FwaVByb3ZpZGVyLnRzeFxuaW1wb3J0IHsgY29uZmlndXJlU3RvcmUsIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U0IH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFByb3ZpZGVyLCBSZWFjdFJlZHV4Q29udGV4dCB9IGZyb20gXCJyZWFjdC1yZWR1eFwiO1xuaW1wb3J0IHsgc2V0dXBMaXN0ZW5lcnMgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdC9xdWVyeVwiO1xuZnVuY3Rpb24gQXBpUHJvdmlkZXIocHJvcHMpIHtcbiAgY29uc3QgY29udGV4dCA9IHByb3BzLmNvbnRleHQgfHwgUmVhY3RSZWR1eENvbnRleHQ7XG4gIGNvbnN0IGV4aXN0aW5nQ29udGV4dCA9IHVzZUNvbnRleHQoY29udGV4dCk7XG4gIGlmIChleGlzdGluZ0NvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U0KDM1KSA6IFwiRXhpc3RpbmcgUmVkdXggY29udGV4dCBkZXRlY3RlZC4gSWYgeW91IGFscmVhZHkgaGF2ZSBhIHN0b3JlIHNldCB1cCwgcGxlYXNlIHVzZSB0aGUgdHJhZGl0aW9uYWwgUmVkdXggc2V0dXAuXCIpO1xuICB9XG4gIGNvbnN0IFtzdG9yZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBjb25maWd1cmVTdG9yZSh7XG4gICAgcmVkdWNlcjoge1xuICAgICAgW3Byb3BzLmFwaS5yZWR1Y2VyUGF0aF06IHByb3BzLmFwaS5yZWR1Y2VyXG4gICAgfSxcbiAgICBtaWRkbGV3YXJlOiAoZ0RNKSA9PiBnRE0oKS5jb25jYXQocHJvcHMuYXBpLm1pZGRsZXdhcmUpXG4gIH0pKTtcbiAgdXNlRWZmZWN0NCgoKSA9PiBwcm9wcy5zZXR1cExpc3RlbmVycyA9PT0gZmFsc2UgPyB2b2lkIDAgOiBzZXR1cExpc3RlbmVycyhzdG9yZS5kaXNwYXRjaCwgcHJvcHMuc2V0dXBMaXN0ZW5lcnMpLCBbcHJvcHMuc2V0dXBMaXN0ZW5lcnMsIHN0b3JlLmRpc3BhdGNoXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChQcm92aWRlciwgeyBzdG9yZSwgY29udGV4dCB9LCBwcm9wcy5jaGlsZHJlbik7XG59XG5cbi8vIHNyYy9xdWVyeS9yZWFjdC9pbmRleC50c1xudmFyIGNyZWF0ZUFwaSA9IC8qIEBfX1BVUkVfXyAqLyBidWlsZENyZWF0ZUFwaShjb3JlTW9kdWxlKCksIHJlYWN0SG9va3NNb2R1bGUoKSk7XG5leHBvcnQge1xuICBBcGlQcm92aWRlcixcbiAgVU5JTklUSUFMSVpFRF9WQUxVRSxcbiAgY3JlYXRlQXBpLFxuICByZWFjdEhvb2tzTW9kdWxlLFxuICByZWFjdEhvb2tzTW9kdWxlTmFtZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ0ay1xdWVyeS1yZWFjdC5tb2Rlcm4ubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/query/react/rtk-query-react.modern.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryStatus: () => (/* binding */ QueryStatus),\n/* harmony export */   _NEVER: () => (/* binding */ _NEVER),\n/* harmony export */   buildCreateApi: () => (/* binding */ buildCreateApi),\n/* harmony export */   copyWithStructuralSharing: () => (/* binding */ copyWithStructuralSharing),\n/* harmony export */   coreModule: () => (/* binding */ coreModule),\n/* harmony export */   coreModuleName: () => (/* binding */ coreModuleName),\n/* harmony export */   createApi: () => (/* binding */ createApi),\n/* harmony export */   defaultSerializeQueryArgs: () => (/* binding */ defaultSerializeQueryArgs),\n/* harmony export */   fakeBaseQuery: () => (/* binding */ fakeBaseQuery),\n/* harmony export */   fetchBaseQuery: () => (/* binding */ fetchBaseQuery),\n/* harmony export */   retry: () => (/* binding */ retry),\n/* harmony export */   setupListeners: () => (/* binding */ setupListeners),\n/* harmony export */   skipToken: () => (/* binding */ skipToken)\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.mjs\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/reselect.mjs\");\n// src/query/core/apiState.ts\nvar QueryStatus = /* @__PURE__ */ ((QueryStatus2) => {\n  QueryStatus2[\"uninitialized\"] = \"uninitialized\";\n  QueryStatus2[\"pending\"] = \"pending\";\n  QueryStatus2[\"fulfilled\"] = \"fulfilled\";\n  QueryStatus2[\"rejected\"] = \"rejected\";\n  return QueryStatus2;\n})(QueryStatus || {});\nfunction getRequestStatusFlags(status) {\n  return {\n    status,\n    isUninitialized: status === \"uninitialized\" /* uninitialized */,\n    isLoading: status === \"pending\" /* pending */,\n    isSuccess: status === \"fulfilled\" /* fulfilled */,\n    isError: status === \"rejected\" /* rejected */\n  };\n}\n\n// src/query/core/rtkImports.ts\n\n\n// src/query/utils/copyWithStructuralSharing.ts\nvar isPlainObject2 = _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject;\nfunction copyWithStructuralSharing(oldObj, newObj) {\n  if (oldObj === newObj || !(isPlainObject2(oldObj) && isPlainObject2(newObj) || Array.isArray(oldObj) && Array.isArray(newObj))) {\n    return newObj;\n  }\n  const newKeys = Object.keys(newObj);\n  const oldKeys = Object.keys(oldObj);\n  let isSameObject = newKeys.length === oldKeys.length;\n  const mergeObj = Array.isArray(newObj) ? [] : {};\n  for (const key of newKeys) {\n    mergeObj[key] = copyWithStructuralSharing(oldObj[key], newObj[key]);\n    if (isSameObject) isSameObject = oldObj[key] === mergeObj[key];\n  }\n  return isSameObject ? oldObj : mergeObj;\n}\n\n// src/query/utils/countObjectKeys.ts\nfunction countObjectKeys(obj) {\n  let count = 0;\n  for (const _key in obj) {\n    count++;\n  }\n  return count;\n}\n\n// src/query/utils/flatten.ts\nvar flatten = (arr) => [].concat(...arr);\n\n// src/query/utils/isAbsoluteUrl.ts\nfunction isAbsoluteUrl(url) {\n  return new RegExp(`(^|:)//`).test(url);\n}\n\n// src/query/utils/isDocumentVisible.ts\nfunction isDocumentVisible() {\n  if (typeof document === \"undefined\") {\n    return true;\n  }\n  return document.visibilityState !== \"hidden\";\n}\n\n// src/query/utils/isNotNullish.ts\nfunction isNotNullish(v) {\n  return v != null;\n}\n\n// src/query/utils/isOnline.ts\nfunction isOnline() {\n  return typeof navigator === \"undefined\" ? true : navigator.onLine === void 0 ? true : navigator.onLine;\n}\n\n// src/query/utils/joinUrls.ts\nvar withoutTrailingSlash = (url) => url.replace(/\\/$/, \"\");\nvar withoutLeadingSlash = (url) => url.replace(/^\\//, \"\");\nfunction joinUrls(base, url) {\n  if (!base) {\n    return url;\n  }\n  if (!url) {\n    return base;\n  }\n  if (isAbsoluteUrl(url)) {\n    return url;\n  }\n  const delimiter = base.endsWith(\"/\") || !url.startsWith(\"?\") ? \"/\" : \"\";\n  base = withoutTrailingSlash(base);\n  url = withoutLeadingSlash(url);\n  return `${base}${delimiter}${url}`;\n}\n\n// src/query/utils/getOrInsert.ts\nfunction getOrInsert(map, key, value) {\n  if (map.has(key)) return map.get(key);\n  return map.set(key, value).get(key);\n}\n\n// src/query/fetchBaseQuery.ts\nvar defaultFetchFn = (...args) => fetch(...args);\nvar defaultValidateStatus = (response) => response.status >= 200 && response.status <= 299;\nvar defaultIsJsonContentType = (headers) => (\n  /*applicat*/\n  /ion\\/(vnd\\.api\\+)?json/.test(headers.get(\"content-type\") || \"\")\n);\nfunction stripUndefined(obj) {\n  if (!(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(obj)) {\n    return obj;\n  }\n  const copy = {\n    ...obj\n  };\n  for (const [k, v] of Object.entries(copy)) {\n    if (v === void 0) delete copy[k];\n  }\n  return copy;\n}\nfunction fetchBaseQuery({\n  baseUrl,\n  prepareHeaders = (x) => x,\n  fetchFn = defaultFetchFn,\n  paramsSerializer,\n  isJsonContentType = defaultIsJsonContentType,\n  jsonContentType = \"application/json\",\n  jsonReplacer,\n  timeout: defaultTimeout,\n  responseHandler: globalResponseHandler,\n  validateStatus: globalValidateStatus,\n  ...baseFetchOptions\n} = {}) {\n  if (typeof fetch === \"undefined\" && fetchFn === defaultFetchFn) {\n    console.warn(\"Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.\");\n  }\n  return async (arg, api, extraOptions) => {\n    const {\n      getState,\n      extra,\n      endpoint,\n      forced,\n      type\n    } = api;\n    let meta;\n    let {\n      url,\n      headers = new Headers(baseFetchOptions.headers),\n      params = void 0,\n      responseHandler = globalResponseHandler ?? \"json\",\n      validateStatus = globalValidateStatus ?? defaultValidateStatus,\n      timeout = defaultTimeout,\n      ...rest\n    } = typeof arg == \"string\" ? {\n      url: arg\n    } : arg;\n    let abortController, signal = api.signal;\n    if (timeout) {\n      abortController = new AbortController();\n      api.signal.addEventListener(\"abort\", abortController.abort);\n      signal = abortController.signal;\n    }\n    let config = {\n      ...baseFetchOptions,\n      signal,\n      ...rest\n    };\n    headers = new Headers(stripUndefined(headers));\n    config.headers = await prepareHeaders(headers, {\n      getState,\n      arg,\n      extra,\n      endpoint,\n      forced,\n      type,\n      extraOptions\n    }) || headers;\n    const isJsonifiable = (body) => typeof body === \"object\" && ((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(body) || Array.isArray(body) || typeof body.toJSON === \"function\");\n    if (!config.headers.has(\"content-type\") && isJsonifiable(config.body)) {\n      config.headers.set(\"content-type\", jsonContentType);\n    }\n    if (isJsonifiable(config.body) && isJsonContentType(config.headers)) {\n      config.body = JSON.stringify(config.body, jsonReplacer);\n    }\n    if (params) {\n      const divider = ~url.indexOf(\"?\") ? \"&\" : \"?\";\n      const query = paramsSerializer ? paramsSerializer(params) : new URLSearchParams(stripUndefined(params));\n      url += divider + query;\n    }\n    url = joinUrls(baseUrl, url);\n    const request = new Request(url, config);\n    const requestClone = new Request(url, config);\n    meta = {\n      request: requestClone\n    };\n    let response, timedOut = false, timeoutId = abortController && setTimeout(() => {\n      timedOut = true;\n      abortController.abort();\n    }, timeout);\n    try {\n      response = await fetchFn(request);\n    } catch (e) {\n      return {\n        error: {\n          status: timedOut ? \"TIMEOUT_ERROR\" : \"FETCH_ERROR\",\n          error: String(e)\n        },\n        meta\n      };\n    } finally {\n      if (timeoutId) clearTimeout(timeoutId);\n      abortController?.signal.removeEventListener(\"abort\", abortController.abort);\n    }\n    const responseClone = response.clone();\n    meta.response = responseClone;\n    let resultData;\n    let responseText = \"\";\n    try {\n      let handleResponseError;\n      await Promise.all([\n        handleResponse(response, responseHandler).then((r) => resultData = r, (e) => handleResponseError = e),\n        // see https://github.com/node-fetch/node-fetch/issues/665#issuecomment-538995182\n        // we *have* to \"use up\" both streams at the same time or they will stop running in node-fetch scenarios\n        responseClone.text().then((r) => responseText = r, () => {\n        })\n      ]);\n      if (handleResponseError) throw handleResponseError;\n    } catch (e) {\n      return {\n        error: {\n          status: \"PARSING_ERROR\",\n          originalStatus: response.status,\n          data: responseText,\n          error: String(e)\n        },\n        meta\n      };\n    }\n    return validateStatus(response, resultData) ? {\n      data: resultData,\n      meta\n    } : {\n      error: {\n        status: response.status,\n        data: resultData\n      },\n      meta\n    };\n  };\n  async function handleResponse(response, responseHandler) {\n    if (typeof responseHandler === \"function\") {\n      return responseHandler(response);\n    }\n    if (responseHandler === \"content-type\") {\n      responseHandler = isJsonContentType(response.headers) ? \"json\" : \"text\";\n    }\n    if (responseHandler === \"json\") {\n      const text = await response.text();\n      return text.length ? JSON.parse(text) : null;\n    }\n    return response.text();\n  }\n}\n\n// src/query/HandledError.ts\nvar HandledError = class {\n  constructor(value, meta = void 0) {\n    this.value = value;\n    this.meta = meta;\n  }\n};\n\n// src/query/retry.ts\nasync function defaultBackoff(attempt = 0, maxRetries = 5) {\n  const attempts = Math.min(attempt, maxRetries);\n  const timeout = ~~((Math.random() + 0.4) * (300 << attempts));\n  await new Promise((resolve) => setTimeout((res) => resolve(res), timeout));\n}\nfunction fail(error, meta) {\n  throw Object.assign(new HandledError({\n    error,\n    meta\n  }), {\n    throwImmediately: true\n  });\n}\nvar EMPTY_OPTIONS = {};\nvar retryWithBackoff = (baseQuery, defaultOptions) => async (args, api, extraOptions) => {\n  const possibleMaxRetries = [5, (defaultOptions || EMPTY_OPTIONS).maxRetries, (extraOptions || EMPTY_OPTIONS).maxRetries].filter((x) => x !== void 0);\n  const [maxRetries] = possibleMaxRetries.slice(-1);\n  const defaultRetryCondition = (_, __, {\n    attempt\n  }) => attempt <= maxRetries;\n  const options = {\n    maxRetries,\n    backoff: defaultBackoff,\n    retryCondition: defaultRetryCondition,\n    ...defaultOptions,\n    ...extraOptions\n  };\n  let retry2 = 0;\n  while (true) {\n    try {\n      const result = await baseQuery(args, api, extraOptions);\n      if (result.error) {\n        throw new HandledError(result);\n      }\n      return result;\n    } catch (e) {\n      retry2++;\n      if (e.throwImmediately) {\n        if (e instanceof HandledError) {\n          return e.value;\n        }\n        throw e;\n      }\n      if (e instanceof HandledError && !options.retryCondition(e.value.error, args, {\n        attempt: retry2,\n        baseQueryApi: api,\n        extraOptions\n      })) {\n        return e.value;\n      }\n      await options.backoff(retry2, options.maxRetries);\n    }\n  }\n};\nvar retry = /* @__PURE__ */ Object.assign(retryWithBackoff, {\n  fail\n});\n\n// src/query/core/setupListeners.ts\nvar onFocus = /* @__PURE__ */ (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(\"__rtkq/focused\");\nvar onFocusLost = /* @__PURE__ */ (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(\"__rtkq/unfocused\");\nvar onOnline = /* @__PURE__ */ (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(\"__rtkq/online\");\nvar onOffline = /* @__PURE__ */ (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(\"__rtkq/offline\");\nvar initialized = false;\nfunction setupListeners(dispatch, customHandler) {\n  function defaultHandler() {\n    const handleFocus = () => dispatch(onFocus());\n    const handleFocusLost = () => dispatch(onFocusLost());\n    const handleOnline = () => dispatch(onOnline());\n    const handleOffline = () => dispatch(onOffline());\n    const handleVisibilityChange = () => {\n      if (window.document.visibilityState === \"visible\") {\n        handleFocus();\n      } else {\n        handleFocusLost();\n      }\n    };\n    if (!initialized) {\n      if (typeof window !== \"undefined\" && window.addEventListener) {\n        window.addEventListener(\"visibilitychange\", handleVisibilityChange, false);\n        window.addEventListener(\"focus\", handleFocus, false);\n        window.addEventListener(\"online\", handleOnline, false);\n        window.addEventListener(\"offline\", handleOffline, false);\n        initialized = true;\n      }\n    }\n    const unsubscribe = () => {\n      window.removeEventListener(\"focus\", handleFocus);\n      window.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n      window.removeEventListener(\"online\", handleOnline);\n      window.removeEventListener(\"offline\", handleOffline);\n      initialized = false;\n    };\n    return unsubscribe;\n  }\n  return customHandler ? customHandler(dispatch, {\n    onFocus,\n    onFocusLost,\n    onOffline,\n    onOnline\n  }) : defaultHandler();\n}\n\n// src/query/endpointDefinitions.ts\nfunction isQueryDefinition(e) {\n  return e.type === \"query\" /* query */;\n}\nfunction isMutationDefinition(e) {\n  return e.type === \"mutation\" /* mutation */;\n}\nfunction isInfiniteQueryDefinition(e) {\n  return e.type === \"infinitequery\" /* infinitequery */;\n}\nfunction calculateProvidedBy(description, result, error, queryArg, meta, assertTagTypes) {\n  if (isFunction(description)) {\n    return description(result, error, queryArg, meta).filter(isNotNullish).map(expandTagDescription).map(assertTagTypes);\n  }\n  if (Array.isArray(description)) {\n    return description.map(expandTagDescription).map(assertTagTypes);\n  }\n  return [];\n}\nfunction isFunction(t) {\n  return typeof t === \"function\";\n}\nfunction expandTagDescription(description) {\n  return typeof description === \"string\" ? {\n    type: description\n  } : description;\n}\n\n// src/query/core/buildThunks.ts\n\n\n// src/query/core/buildInitiate.ts\n\n\n// src/tsHelpers.ts\nfunction asSafePromise(promise, fallback) {\n  return promise.catch(fallback);\n}\n\n// src/query/core/buildInitiate.ts\nvar forceQueryFnSymbol = Symbol(\"forceQueryFn\");\nvar isUpsertQuery = (arg) => typeof arg[forceQueryFnSymbol] === \"function\";\nfunction buildInitiate({\n  serializeQueryArgs,\n  queryThunk,\n  infiniteQueryThunk,\n  mutationThunk,\n  api,\n  context\n}) {\n  const runningQueries = /* @__PURE__ */ new Map();\n  const runningMutations = /* @__PURE__ */ new Map();\n  const {\n    unsubscribeQueryResult,\n    removeMutationResult,\n    updateSubscriptionOptions\n  } = api.internalActions;\n  return {\n    buildInitiateQuery,\n    buildInitiateInfiniteQuery,\n    buildInitiateMutation,\n    getRunningQueryThunk,\n    getRunningMutationThunk,\n    getRunningQueriesThunk,\n    getRunningMutationsThunk\n  };\n  function getRunningQueryThunk(endpointName, queryArgs) {\n    return (dispatch) => {\n      const endpointDefinition = context.endpointDefinitions[endpointName];\n      const queryCacheKey = serializeQueryArgs({\n        queryArgs,\n        endpointDefinition,\n        endpointName\n      });\n      return runningQueries.get(dispatch)?.[queryCacheKey];\n    };\n  }\n  function getRunningMutationThunk(_endpointName, fixedCacheKeyOrRequestId) {\n    return (dispatch) => {\n      return runningMutations.get(dispatch)?.[fixedCacheKeyOrRequestId];\n    };\n  }\n  function getRunningQueriesThunk() {\n    return (dispatch) => Object.values(runningQueries.get(dispatch) || {}).filter(isNotNullish);\n  }\n  function getRunningMutationsThunk() {\n    return (dispatch) => Object.values(runningMutations.get(dispatch) || {}).filter(isNotNullish);\n  }\n  function middlewareWarning(dispatch) {\n    if (true) {\n      if (middlewareWarning.triggered) return;\n      const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());\n      middlewareWarning.triggered = true;\n      if (typeof returnedValue !== \"object\" || typeof returnedValue?.type === \"string\") {\n        throw new Error( false ? 0 : `Warning: Middleware for RTK-Query API at reducerPath \"${api.reducerPath}\" has not been added to the store.\nYou must add the middleware for RTK-Query to function correctly!`);\n      }\n    }\n  }\n  function buildInitiateAnyQuery(endpointName, endpointDefinition) {\n    const queryAction = (arg, {\n      subscribe = true,\n      forceRefetch,\n      subscriptionOptions,\n      [forceQueryFnSymbol]: forceQueryFn,\n      ...rest\n    } = {}) => (dispatch, getState) => {\n      const queryCacheKey = serializeQueryArgs({\n        queryArgs: arg,\n        endpointDefinition,\n        endpointName\n      });\n      let thunk;\n      const commonThunkArgs = {\n        ...rest,\n        type: \"query\",\n        subscribe,\n        forceRefetch,\n        subscriptionOptions,\n        endpointName,\n        originalArgs: arg,\n        queryCacheKey,\n        [forceQueryFnSymbol]: forceQueryFn\n      };\n      if (isQueryDefinition(endpointDefinition)) {\n        thunk = queryThunk(commonThunkArgs);\n      } else {\n        const {\n          direction,\n          initialPageParam\n        } = rest;\n        thunk = infiniteQueryThunk({\n          ...commonThunkArgs,\n          // Supply these even if undefined. This helps with a field existence\n          // check over in `buildSlice.ts`\n          direction,\n          initialPageParam\n        });\n      }\n      const selector = api.endpoints[endpointName].select(arg);\n      const thunkResult = dispatch(thunk);\n      const stateAfter = selector(getState());\n      middlewareWarning(dispatch);\n      const {\n        requestId,\n        abort\n      } = thunkResult;\n      const skippedSynchronously = stateAfter.requestId !== requestId;\n      const runningQuery = runningQueries.get(dispatch)?.[queryCacheKey];\n      const selectFromState = () => selector(getState());\n      const statePromise = Object.assign(forceQueryFn ? (\n        // a query has been forced (upsertQueryData)\n        // -> we want to resolve it once data has been written with the data that will be written\n        thunkResult.then(selectFromState)\n      ) : skippedSynchronously && !runningQuery ? (\n        // a query has been skipped due to a condition and we do not have any currently running query\n        // -> we want to resolve it immediately with the current data\n        Promise.resolve(stateAfter)\n      ) : (\n        // query just started or one is already in flight\n        // -> wait for the running query, then resolve with data from after that\n        Promise.all([runningQuery, thunkResult]).then(selectFromState)\n      ), {\n        arg,\n        requestId,\n        subscriptionOptions,\n        queryCacheKey,\n        abort,\n        async unwrap() {\n          const result = await statePromise;\n          if (result.isError) {\n            throw result.error;\n          }\n          return result.data;\n        },\n        refetch: () => dispatch(queryAction(arg, {\n          subscribe: false,\n          forceRefetch: true\n        })),\n        unsubscribe() {\n          if (subscribe) dispatch(unsubscribeQueryResult({\n            queryCacheKey,\n            requestId\n          }));\n        },\n        updateSubscriptionOptions(options) {\n          statePromise.subscriptionOptions = options;\n          dispatch(updateSubscriptionOptions({\n            endpointName,\n            requestId,\n            queryCacheKey,\n            options\n          }));\n        }\n      });\n      if (!runningQuery && !skippedSynchronously && !forceQueryFn) {\n        const running = getOrInsert(runningQueries, dispatch, {});\n        running[queryCacheKey] = statePromise;\n        statePromise.then(() => {\n          delete running[queryCacheKey];\n          if (!countObjectKeys(running)) {\n            runningQueries.delete(dispatch);\n          }\n        });\n      }\n      return statePromise;\n    };\n    return queryAction;\n  }\n  function buildInitiateQuery(endpointName, endpointDefinition) {\n    const queryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);\n    return queryAction;\n  }\n  function buildInitiateInfiniteQuery(endpointName, endpointDefinition) {\n    const infiniteQueryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);\n    return infiniteQueryAction;\n  }\n  function buildInitiateMutation(endpointName) {\n    return (arg, {\n      track = true,\n      fixedCacheKey\n    } = {}) => (dispatch, getState) => {\n      const thunk = mutationThunk({\n        type: \"mutation\",\n        endpointName,\n        originalArgs: arg,\n        track,\n        fixedCacheKey\n      });\n      const thunkResult = dispatch(thunk);\n      middlewareWarning(dispatch);\n      const {\n        requestId,\n        abort,\n        unwrap\n      } = thunkResult;\n      const returnValuePromise = asSafePromise(thunkResult.unwrap().then((data) => ({\n        data\n      })), (error) => ({\n        error\n      }));\n      const reset = () => {\n        dispatch(removeMutationResult({\n          requestId,\n          fixedCacheKey\n        }));\n      };\n      const ret = Object.assign(returnValuePromise, {\n        arg: thunkResult.arg,\n        requestId,\n        abort,\n        unwrap,\n        reset\n      });\n      const running = runningMutations.get(dispatch) || {};\n      runningMutations.set(dispatch, running);\n      running[requestId] = ret;\n      ret.then(() => {\n        delete running[requestId];\n        if (!countObjectKeys(running)) {\n          runningMutations.delete(dispatch);\n        }\n      });\n      if (fixedCacheKey) {\n        running[fixedCacheKey] = ret;\n        ret.then(() => {\n          if (running[fixedCacheKey] === ret) {\n            delete running[fixedCacheKey];\n            if (!countObjectKeys(running)) {\n              runningMutations.delete(dispatch);\n            }\n          }\n        });\n      }\n      return ret;\n    };\n  }\n}\n\n// src/query/core/buildThunks.ts\nfunction defaultTransformResponse(baseQueryReturnValue) {\n  return baseQueryReturnValue;\n}\nvar addShouldAutoBatch = (arg = {}) => {\n  return {\n    ...arg,\n    [_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.SHOULD_AUTOBATCH]: true\n  };\n};\nfunction buildThunks({\n  reducerPath,\n  baseQuery,\n  context: {\n    endpointDefinitions\n  },\n  serializeQueryArgs,\n  api,\n  assertTagType,\n  selectors\n}) {\n  const patchQueryData = (endpointName, arg, patches, updateProvided) => (dispatch, getState) => {\n    const endpointDefinition = endpointDefinitions[endpointName];\n    const queryCacheKey = serializeQueryArgs({\n      queryArgs: arg,\n      endpointDefinition,\n      endpointName\n    });\n    dispatch(api.internalActions.queryResultPatched({\n      queryCacheKey,\n      patches\n    }));\n    if (!updateProvided) {\n      return;\n    }\n    const newValue = api.endpoints[endpointName].select(arg)(\n      // Work around TS 4.1 mismatch\n      getState()\n    );\n    const providedTags = calculateProvidedBy(endpointDefinition.providesTags, newValue.data, void 0, arg, {}, assertTagType);\n    dispatch(api.internalActions.updateProvidedBy({\n      queryCacheKey,\n      providedTags\n    }));\n  };\n  function addToStart(items, item, max = 0) {\n    const newItems = [item, ...items];\n    return max && newItems.length > max ? newItems.slice(0, -1) : newItems;\n  }\n  function addToEnd(items, item, max = 0) {\n    const newItems = [...items, item];\n    return max && newItems.length > max ? newItems.slice(1) : newItems;\n  }\n  const updateQueryData = (endpointName, arg, updateRecipe, updateProvided = true) => (dispatch, getState) => {\n    const endpointDefinition = api.endpoints[endpointName];\n    const currentState = endpointDefinition.select(arg)(\n      // Work around TS 4.1 mismatch\n      getState()\n    );\n    const ret = {\n      patches: [],\n      inversePatches: [],\n      undo: () => dispatch(api.util.patchQueryData(endpointName, arg, ret.inversePatches, updateProvided))\n    };\n    if (currentState.status === \"uninitialized\" /* uninitialized */) {\n      return ret;\n    }\n    let newValue;\n    if (\"data\" in currentState) {\n      if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(currentState.data)) {\n        const [value, patches, inversePatches] = (0,immer__WEBPACK_IMPORTED_MODULE_2__.produceWithPatches)(currentState.data, updateRecipe);\n        ret.patches.push(...patches);\n        ret.inversePatches.push(...inversePatches);\n        newValue = value;\n      } else {\n        newValue = updateRecipe(currentState.data);\n        ret.patches.push({\n          op: \"replace\",\n          path: [],\n          value: newValue\n        });\n        ret.inversePatches.push({\n          op: \"replace\",\n          path: [],\n          value: currentState.data\n        });\n      }\n    }\n    if (ret.patches.length === 0) {\n      return ret;\n    }\n    dispatch(api.util.patchQueryData(endpointName, arg, ret.patches, updateProvided));\n    return ret;\n  };\n  const upsertQueryData = (endpointName, arg, value) => (dispatch) => {\n    const res = dispatch(api.endpoints[endpointName].initiate(arg, {\n      subscribe: false,\n      forceRefetch: true,\n      [forceQueryFnSymbol]: () => ({\n        data: value\n      })\n    }));\n    return res;\n  };\n  const getTransformCallbackForEndpoint = (endpointDefinition, transformFieldName) => {\n    return endpointDefinition.query && endpointDefinition[transformFieldName] ? endpointDefinition[transformFieldName] : defaultTransformResponse;\n  };\n  const executeEndpoint = async (arg, {\n    signal,\n    abort,\n    rejectWithValue,\n    fulfillWithValue,\n    dispatch,\n    getState,\n    extra\n  }) => {\n    const endpointDefinition = endpointDefinitions[arg.endpointName];\n    try {\n      let transformResponse = getTransformCallbackForEndpoint(endpointDefinition, \"transformResponse\");\n      const baseQueryApi = {\n        signal,\n        abort,\n        dispatch,\n        getState,\n        extra,\n        endpoint: arg.endpointName,\n        type: arg.type,\n        forced: arg.type === \"query\" ? isForcedQuery(arg, getState()) : void 0,\n        queryCacheKey: arg.type === \"query\" ? arg.queryCacheKey : void 0\n      };\n      const forceQueryFn = arg.type === \"query\" ? arg[forceQueryFnSymbol] : void 0;\n      let finalQueryReturnValue;\n      const fetchPage = async (data, param, maxPages, previous) => {\n        if (param == null && data.pages.length) {\n          return Promise.resolve({\n            data\n          });\n        }\n        const finalQueryArg = {\n          queryArg: arg.originalArgs,\n          pageParam: param\n        };\n        const pageResponse = await executeRequest(finalQueryArg);\n        const addTo = previous ? addToStart : addToEnd;\n        return {\n          data: {\n            pages: addTo(data.pages, pageResponse.data, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages)\n          }\n        };\n      };\n      async function executeRequest(finalQueryArg) {\n        let result;\n        const {\n          extraOptions\n        } = endpointDefinition;\n        if (forceQueryFn) {\n          result = forceQueryFn();\n        } else if (endpointDefinition.query) {\n          result = await baseQuery(endpointDefinition.query(finalQueryArg), baseQueryApi, extraOptions);\n        } else {\n          result = await endpointDefinition.queryFn(finalQueryArg, baseQueryApi, extraOptions, (arg2) => baseQuery(arg2, baseQueryApi, extraOptions));\n        }\n        if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n          const what = endpointDefinition.query ? \"`baseQuery`\" : \"`queryFn`\";\n          let err;\n          if (!result) {\n            err = `${what} did not return anything.`;\n          } else if (typeof result !== \"object\") {\n            err = `${what} did not return an object.`;\n          } else if (result.error && result.data) {\n            err = `${what} returned an object containing both \\`error\\` and \\`result\\`.`;\n          } else if (result.error === void 0 && result.data === void 0) {\n            err = `${what} returned an object containing neither a valid \\`error\\` and \\`result\\`. At least one of them should not be \\`undefined\\``;\n          } else {\n            for (const key of Object.keys(result)) {\n              if (key !== \"error\" && key !== \"data\" && key !== \"meta\") {\n                err = `The object returned by ${what} has the unknown property ${key}.`;\n                break;\n              }\n            }\n          }\n          if (err) {\n            console.error(`Error encountered handling the endpoint ${arg.endpointName}.\n                  ${err}\n                  It needs to return an object with either the shape \\`{ data: <value> }\\` or \\`{ error: <value> }\\` that may contain an optional \\`meta\\` property.\n                  Object returned was:`, result);\n          }\n        }\n        if (result.error) throw new HandledError(result.error, result.meta);\n        const transformedResponse = await transformResponse(result.data, result.meta, finalQueryArg);\n        return {\n          ...result,\n          data: transformedResponse\n        };\n      }\n      if (arg.type === \"query\" && \"infiniteQueryOptions\" in endpointDefinition) {\n        const {\n          infiniteQueryOptions\n        } = endpointDefinition;\n        const {\n          maxPages = Infinity\n        } = infiniteQueryOptions;\n        let result;\n        const blankData = {\n          pages: [],\n          pageParams: []\n        };\n        const cachedData = selectors.selectQueryEntry(getState(), arg.queryCacheKey)?.data;\n        const isForcedQueryNeedingRefetch = (\n          // arg.forceRefetch\n          isForcedQuery(arg, getState()) && !arg.direction\n        );\n        const existingData = isForcedQueryNeedingRefetch || !cachedData ? blankData : cachedData;\n        if (\"direction\" in arg && arg.direction && existingData.pages.length) {\n          const previous = arg.direction === \"backward\";\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\n          const param = pageParamFn(infiniteQueryOptions, existingData);\n          result = await fetchPage(existingData, param, maxPages, previous);\n        } else {\n          const {\n            initialPageParam = infiniteQueryOptions.initialPageParam\n          } = arg;\n          const cachedPageParams = cachedData?.pageParams ?? [];\n          const firstPageParam = cachedPageParams[0] ?? initialPageParam;\n          const totalPages = cachedPageParams.length;\n          result = await fetchPage(existingData, firstPageParam, maxPages);\n          if (forceQueryFn) {\n            result = {\n              data: result.data.pages[0]\n            };\n          }\n          for (let i = 1; i < totalPages; i++) {\n            const param = getNextPageParam(infiniteQueryOptions, result.data);\n            result = await fetchPage(result.data, param, maxPages);\n          }\n        }\n        finalQueryReturnValue = result;\n      } else {\n        finalQueryReturnValue = await executeRequest(arg.originalArgs);\n      }\n      return fulfillWithValue(finalQueryReturnValue.data, addShouldAutoBatch({\n        fulfilledTimeStamp: Date.now(),\n        baseQueryMeta: finalQueryReturnValue.meta\n      }));\n    } catch (error) {\n      let catchedError = error;\n      if (catchedError instanceof HandledError) {\n        let transformErrorResponse = getTransformCallbackForEndpoint(endpointDefinition, \"transformErrorResponse\");\n        try {\n          return rejectWithValue(await transformErrorResponse(catchedError.value, catchedError.meta, arg.originalArgs), addShouldAutoBatch({\n            baseQueryMeta: catchedError.meta\n          }));\n        } catch (e) {\n          catchedError = e;\n        }\n      }\n      if (typeof process !== \"undefined\" && \"development\" !== \"production\") {\n        console.error(`An unhandled error occurred processing a request for the endpoint \"${arg.endpointName}\".\nIn the case of an unhandled error, no tags will be \"provided\" or \"invalidated\".`, catchedError);\n      } else {\n        console.error(catchedError);\n      }\n      throw catchedError;\n    }\n  };\n  function isForcedQuery(arg, state) {\n    const requestState = selectors.selectQueryEntry(state, arg.queryCacheKey);\n    const baseFetchOnMountOrArgChange = selectors.selectConfig(state).refetchOnMountOrArgChange;\n    const fulfilledVal = requestState?.fulfilledTimeStamp;\n    const refetchVal = arg.forceRefetch ?? (arg.subscribe && baseFetchOnMountOrArgChange);\n    if (refetchVal) {\n      return refetchVal === true || (Number(/* @__PURE__ */ new Date()) - Number(fulfilledVal)) / 1e3 >= refetchVal;\n    }\n    return false;\n  }\n  const createQueryThunk = () => {\n    const generatedQueryThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAsyncThunk)(`${reducerPath}/executeQuery`, executeEndpoint, {\n      getPendingMeta({\n        arg\n      }) {\n        const endpointDefinition = endpointDefinitions[arg.endpointName];\n        return addShouldAutoBatch({\n          startedTimeStamp: Date.now(),\n          ...isInfiniteQueryDefinition(endpointDefinition) ? {\n            direction: arg.direction\n          } : {}\n        });\n      },\n      condition(queryThunkArg, {\n        getState\n      }) {\n        const state = getState();\n        const requestState = selectors.selectQueryEntry(state, queryThunkArg.queryCacheKey);\n        const fulfilledVal = requestState?.fulfilledTimeStamp;\n        const currentArg = queryThunkArg.originalArgs;\n        const previousArg = requestState?.originalArgs;\n        const endpointDefinition = endpointDefinitions[queryThunkArg.endpointName];\n        const direction = queryThunkArg.direction;\n        if (isUpsertQuery(queryThunkArg)) {\n          return true;\n        }\n        if (requestState?.status === \"pending\") {\n          return false;\n        }\n        if (isForcedQuery(queryThunkArg, state)) {\n          return true;\n        }\n        if (isQueryDefinition(endpointDefinition) && endpointDefinition?.forceRefetch?.({\n          currentArg,\n          previousArg,\n          endpointState: requestState,\n          state\n        })) {\n          return true;\n        }\n        if (fulfilledVal && !direction) {\n          return false;\n        }\n        return true;\n      },\n      dispatchConditionRejection: true\n    });\n    return generatedQueryThunk;\n  };\n  const queryThunk = createQueryThunk();\n  const infiniteQueryThunk = createQueryThunk();\n  const mutationThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAsyncThunk)(`${reducerPath}/executeMutation`, executeEndpoint, {\n    getPendingMeta() {\n      return addShouldAutoBatch({\n        startedTimeStamp: Date.now()\n      });\n    }\n  });\n  const hasTheForce = (options) => \"force\" in options;\n  const hasMaxAge = (options) => \"ifOlderThan\" in options;\n  const prefetch = (endpointName, arg, options) => (dispatch, getState) => {\n    const force = hasTheForce(options) && options.force;\n    const maxAge = hasMaxAge(options) && options.ifOlderThan;\n    const queryAction = (force2 = true) => {\n      const options2 = {\n        forceRefetch: force2,\n        isPrefetch: true\n      };\n      return api.endpoints[endpointName].initiate(arg, options2);\n    };\n    const latestStateValue = api.endpoints[endpointName].select(arg)(getState());\n    if (force) {\n      dispatch(queryAction());\n    } else if (maxAge) {\n      const lastFulfilledTs = latestStateValue?.fulfilledTimeStamp;\n      if (!lastFulfilledTs) {\n        dispatch(queryAction());\n        return;\n      }\n      const shouldRetrigger = (Number(/* @__PURE__ */ new Date()) - Number(new Date(lastFulfilledTs))) / 1e3 >= maxAge;\n      if (shouldRetrigger) {\n        dispatch(queryAction());\n      }\n    } else {\n      dispatch(queryAction(false));\n    }\n  };\n  function matchesEndpoint(endpointName) {\n    return (action) => action?.meta?.arg?.endpointName === endpointName;\n  }\n  function buildMatchThunkActions(thunk, endpointName) {\n    return {\n      matchPending: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAllOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isPending)(thunk), matchesEndpoint(endpointName)),\n      matchFulfilled: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAllOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(thunk), matchesEndpoint(endpointName)),\n      matchRejected: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAllOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejected)(thunk), matchesEndpoint(endpointName))\n    };\n  }\n  return {\n    queryThunk,\n    mutationThunk,\n    infiniteQueryThunk,\n    prefetch,\n    updateQueryData,\n    upsertQueryData,\n    patchQueryData,\n    buildMatchThunkActions\n  };\n}\nfunction getNextPageParam(options, {\n  pages,\n  pageParams\n}) {\n  const lastIndex = pages.length - 1;\n  return options.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams);\n}\nfunction getPreviousPageParam(options, {\n  pages,\n  pageParams\n}) {\n  return options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams);\n}\nfunction calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {\n  return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(action) ? action.payload : void 0, (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejectedWithValue)(action) ? action.payload : void 0, action.meta.arg.originalArgs, \"baseQueryMeta\" in action.meta ? action.meta.baseQueryMeta : void 0, assertTagType);\n}\n\n// src/query/core/buildSlice.ts\n\n\nfunction updateQuerySubstateIfExists(state, queryCacheKey, update) {\n  const substate = state[queryCacheKey];\n  if (substate) {\n    update(substate);\n  }\n}\nfunction getMutationCacheKey(id) {\n  return (\"arg\" in id ? id.arg.fixedCacheKey : id.fixedCacheKey) ?? id.requestId;\n}\nfunction updateMutationSubstateIfExists(state, id, update) {\n  const substate = state[getMutationCacheKey(id)];\n  if (substate) {\n    update(substate);\n  }\n}\nvar initialState = {};\nfunction buildSlice({\n  reducerPath,\n  queryThunk,\n  mutationThunk,\n  serializeQueryArgs,\n  context: {\n    endpointDefinitions: definitions,\n    apiUid,\n    extractRehydrationInfo,\n    hasRehydrationInfo\n  },\n  assertTagType,\n  config\n}) {\n  const resetApiState = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(`${reducerPath}/resetApiState`);\n  function writePendingCacheEntry(draft, arg, upserting, meta) {\n    draft[arg.queryCacheKey] ??= {\n      status: \"uninitialized\" /* uninitialized */,\n      endpointName: arg.endpointName\n    };\n    updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate) => {\n      substate.status = \"pending\" /* pending */;\n      substate.requestId = upserting && substate.requestId ? (\n        // for `upsertQuery` **updates**, keep the current `requestId`\n        substate.requestId\n      ) : (\n        // for normal queries or `upsertQuery` **inserts** always update the `requestId`\n        meta.requestId\n      );\n      if (arg.originalArgs !== void 0) {\n        substate.originalArgs = arg.originalArgs;\n      }\n      substate.startedTimeStamp = meta.startedTimeStamp;\n      const endpointDefinition = definitions[meta.arg.endpointName];\n      if (isInfiniteQueryDefinition(endpointDefinition) && \"direction\" in arg) {\n        ;\n        substate.direction = arg.direction;\n      }\n    });\n  }\n  function writeFulfilledCacheEntry(draft, meta, payload, upserting) {\n    updateQuerySubstateIfExists(draft, meta.arg.queryCacheKey, (substate) => {\n      if (substate.requestId !== meta.requestId && !upserting) return;\n      const {\n        merge\n      } = definitions[meta.arg.endpointName];\n      substate.status = \"fulfilled\" /* fulfilled */;\n      if (merge) {\n        if (substate.data !== void 0) {\n          const {\n            fulfilledTimeStamp,\n            arg,\n            baseQueryMeta,\n            requestId\n          } = meta;\n          let newData = (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(substate.data, (draftSubstateData) => {\n            return merge(draftSubstateData, payload, {\n              arg: arg.originalArgs,\n              baseQueryMeta,\n              fulfilledTimeStamp,\n              requestId\n            });\n          });\n          substate.data = newData;\n        } else {\n          substate.data = payload;\n        }\n      } else {\n        substate.data = definitions[meta.arg.endpointName].structuralSharing ?? true ? copyWithStructuralSharing((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(substate.data) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.original)(substate.data) : substate.data, payload) : payload;\n      }\n      delete substate.error;\n      substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;\n    });\n  }\n  const querySlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n    name: `${reducerPath}/queries`,\n    initialState,\n    reducers: {\n      removeQueryResult: {\n        reducer(draft, {\n          payload: {\n            queryCacheKey\n          }\n        }) {\n          delete draft[queryCacheKey];\n        },\n        prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n      },\n      cacheEntriesUpserted: {\n        reducer(draft, action) {\n          for (const entry of action.payload) {\n            const {\n              queryDescription: arg,\n              value\n            } = entry;\n            writePendingCacheEntry(draft, arg, true, {\n              arg,\n              requestId: action.meta.requestId,\n              startedTimeStamp: action.meta.timestamp\n            });\n            writeFulfilledCacheEntry(\n              draft,\n              {\n                arg,\n                requestId: action.meta.requestId,\n                fulfilledTimeStamp: action.meta.timestamp,\n                baseQueryMeta: {}\n              },\n              value,\n              // We know we're upserting here\n              true\n            );\n          }\n        },\n        prepare: (payload) => {\n          const queryDescriptions = payload.map((entry) => {\n            const {\n              endpointName,\n              arg,\n              value\n            } = entry;\n            const endpointDefinition = definitions[endpointName];\n            const queryDescription = {\n              type: \"query\",\n              endpointName,\n              originalArgs: entry.arg,\n              queryCacheKey: serializeQueryArgs({\n                queryArgs: arg,\n                endpointDefinition,\n                endpointName\n              })\n            };\n            return {\n              queryDescription,\n              value\n            };\n          });\n          const result = {\n            payload: queryDescriptions,\n            meta: {\n              [_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.SHOULD_AUTOBATCH]: true,\n              requestId: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.nanoid)(),\n              timestamp: Date.now()\n            }\n          };\n          return result;\n        }\n      },\n      queryResultPatched: {\n        reducer(draft, {\n          payload: {\n            queryCacheKey,\n            patches\n          }\n        }) {\n          updateQuerySubstateIfExists(draft, queryCacheKey, (substate) => {\n            substate.data = (0,immer__WEBPACK_IMPORTED_MODULE_2__.applyPatches)(substate.data, patches.concat());\n          });\n        },\n        prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n      }\n    },\n    extraReducers(builder) {\n      builder.addCase(queryThunk.pending, (draft, {\n        meta,\n        meta: {\n          arg\n        }\n      }) => {\n        const upserting = isUpsertQuery(arg);\n        writePendingCacheEntry(draft, arg, upserting, meta);\n      }).addCase(queryThunk.fulfilled, (draft, {\n        meta,\n        payload\n      }) => {\n        const upserting = isUpsertQuery(meta.arg);\n        writeFulfilledCacheEntry(draft, meta, payload, upserting);\n      }).addCase(queryThunk.rejected, (draft, {\n        meta: {\n          condition,\n          arg,\n          requestId\n        },\n        error,\n        payload\n      }) => {\n        updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate) => {\n          if (condition) {\n          } else {\n            if (substate.requestId !== requestId) return;\n            substate.status = \"rejected\" /* rejected */;\n            substate.error = payload ?? error;\n          }\n        });\n      }).addMatcher(hasRehydrationInfo, (draft, action) => {\n        const {\n          queries\n        } = extractRehydrationInfo(action);\n        for (const [key, entry] of Object.entries(queries)) {\n          if (\n            // do not rehydrate entries that were currently in flight.\n            entry?.status === \"fulfilled\" /* fulfilled */ || entry?.status === \"rejected\" /* rejected */\n          ) {\n            draft[key] = entry;\n          }\n        }\n      });\n    }\n  });\n  const mutationSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n    name: `${reducerPath}/mutations`,\n    initialState,\n    reducers: {\n      removeMutationResult: {\n        reducer(draft, {\n          payload\n        }) {\n          const cacheKey = getMutationCacheKey(payload);\n          if (cacheKey in draft) {\n            delete draft[cacheKey];\n          }\n        },\n        prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n      }\n    },\n    extraReducers(builder) {\n      builder.addCase(mutationThunk.pending, (draft, {\n        meta,\n        meta: {\n          requestId,\n          arg,\n          startedTimeStamp\n        }\n      }) => {\n        if (!arg.track) return;\n        draft[getMutationCacheKey(meta)] = {\n          requestId,\n          status: \"pending\" /* pending */,\n          endpointName: arg.endpointName,\n          startedTimeStamp\n        };\n      }).addCase(mutationThunk.fulfilled, (draft, {\n        payload,\n        meta\n      }) => {\n        if (!meta.arg.track) return;\n        updateMutationSubstateIfExists(draft, meta, (substate) => {\n          if (substate.requestId !== meta.requestId) return;\n          substate.status = \"fulfilled\" /* fulfilled */;\n          substate.data = payload;\n          substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;\n        });\n      }).addCase(mutationThunk.rejected, (draft, {\n        payload,\n        error,\n        meta\n      }) => {\n        if (!meta.arg.track) return;\n        updateMutationSubstateIfExists(draft, meta, (substate) => {\n          if (substate.requestId !== meta.requestId) return;\n          substate.status = \"rejected\" /* rejected */;\n          substate.error = payload ?? error;\n        });\n      }).addMatcher(hasRehydrationInfo, (draft, action) => {\n        const {\n          mutations\n        } = extractRehydrationInfo(action);\n        for (const [key, entry] of Object.entries(mutations)) {\n          if (\n            // do not rehydrate entries that were currently in flight.\n            (entry?.status === \"fulfilled\" /* fulfilled */ || entry?.status === \"rejected\" /* rejected */) && // only rehydrate endpoints that were persisted using a `fixedCacheKey`\n            key !== entry?.requestId\n          ) {\n            draft[key] = entry;\n          }\n        }\n      });\n    }\n  });\n  const invalidationSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n    name: `${reducerPath}/invalidation`,\n    initialState,\n    reducers: {\n      updateProvidedBy: {\n        reducer(draft, action) {\n          const {\n            queryCacheKey,\n            providedTags\n          } = action.payload;\n          for (const tagTypeSubscriptions of Object.values(draft)) {\n            for (const idSubscriptions of Object.values(tagTypeSubscriptions)) {\n              const foundAt = idSubscriptions.indexOf(queryCacheKey);\n              if (foundAt !== -1) {\n                idSubscriptions.splice(foundAt, 1);\n              }\n            }\n          }\n          for (const {\n            type,\n            id\n          } of providedTags) {\n            const subscribedQueries = (draft[type] ??= {})[id || \"__internal_without_id\"] ??= [];\n            const alreadySubscribed = subscribedQueries.includes(queryCacheKey);\n            if (!alreadySubscribed) {\n              subscribedQueries.push(queryCacheKey);\n            }\n          }\n        },\n        prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n      }\n    },\n    extraReducers(builder) {\n      builder.addCase(querySlice.actions.removeQueryResult, (draft, {\n        payload: {\n          queryCacheKey\n        }\n      }) => {\n        for (const tagTypeSubscriptions of Object.values(draft)) {\n          for (const idSubscriptions of Object.values(tagTypeSubscriptions)) {\n            const foundAt = idSubscriptions.indexOf(queryCacheKey);\n            if (foundAt !== -1) {\n              idSubscriptions.splice(foundAt, 1);\n            }\n          }\n        }\n      }).addMatcher(hasRehydrationInfo, (draft, action) => {\n        const {\n          provided\n        } = extractRehydrationInfo(action);\n        for (const [type, incomingTags] of Object.entries(provided)) {\n          for (const [id, cacheKeys] of Object.entries(incomingTags)) {\n            const subscribedQueries = (draft[type] ??= {})[id || \"__internal_without_id\"] ??= [];\n            for (const queryCacheKey of cacheKeys) {\n              const alreadySubscribed = subscribedQueries.includes(queryCacheKey);\n              if (!alreadySubscribed) {\n                subscribedQueries.push(queryCacheKey);\n              }\n            }\n          }\n        }\n      }).addMatcher((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAnyOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(queryThunk), (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejectedWithValue)(queryThunk)), (draft, action) => {\n        writeProvidedTagsForQuery(draft, action);\n      }).addMatcher(querySlice.actions.cacheEntriesUpserted.match, (draft, action) => {\n        for (const {\n          queryDescription: arg,\n          value\n        } of action.payload) {\n          const action2 = {\n            type: \"UNKNOWN\",\n            payload: value,\n            meta: {\n              requestStatus: \"fulfilled\",\n              requestId: \"UNKNOWN\",\n              arg\n            }\n          };\n          writeProvidedTagsForQuery(draft, action2);\n        }\n      });\n    }\n  });\n  function writeProvidedTagsForQuery(draft, action) {\n    const providedTags = calculateProvidedByThunk(action, \"providesTags\", definitions, assertTagType);\n    const {\n      queryCacheKey\n    } = action.meta.arg;\n    invalidationSlice.caseReducers.updateProvidedBy(draft, invalidationSlice.actions.updateProvidedBy({\n      queryCacheKey,\n      providedTags\n    }));\n  }\n  const subscriptionSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n    name: `${reducerPath}/subscriptions`,\n    initialState,\n    reducers: {\n      updateSubscriptionOptions(d, a) {\n      },\n      unsubscribeQueryResult(d, a) {\n      },\n      internal_getRTKQSubscriptions() {\n      }\n    }\n  });\n  const internalSubscriptionsSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n    name: `${reducerPath}/internalSubscriptions`,\n    initialState,\n    reducers: {\n      subscriptionsUpdated: {\n        reducer(state, action) {\n          return (0,immer__WEBPACK_IMPORTED_MODULE_2__.applyPatches)(state, action.payload);\n        },\n        prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n      }\n    }\n  });\n  const configSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n    name: `${reducerPath}/config`,\n    initialState: {\n      online: isOnline(),\n      focused: isDocumentVisible(),\n      middlewareRegistered: false,\n      ...config\n    },\n    reducers: {\n      middlewareRegistered(state, {\n        payload\n      }) {\n        state.middlewareRegistered = state.middlewareRegistered === \"conflict\" || apiUid !== payload ? \"conflict\" : true;\n      }\n    },\n    extraReducers: (builder) => {\n      builder.addCase(onOnline, (state) => {\n        state.online = true;\n      }).addCase(onOffline, (state) => {\n        state.online = false;\n      }).addCase(onFocus, (state) => {\n        state.focused = true;\n      }).addCase(onFocusLost, (state) => {\n        state.focused = false;\n      }).addMatcher(hasRehydrationInfo, (draft) => ({\n        ...draft\n      }));\n    }\n  });\n  const combinedReducer = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.combineReducers)({\n    queries: querySlice.reducer,\n    mutations: mutationSlice.reducer,\n    provided: invalidationSlice.reducer,\n    subscriptions: internalSubscriptionsSlice.reducer,\n    config: configSlice.reducer\n  });\n  const reducer = (state, action) => combinedReducer(resetApiState.match(action) ? void 0 : state, action);\n  const actions = {\n    ...configSlice.actions,\n    ...querySlice.actions,\n    ...subscriptionSlice.actions,\n    ...internalSubscriptionsSlice.actions,\n    ...mutationSlice.actions,\n    ...invalidationSlice.actions,\n    resetApiState\n  };\n  return {\n    reducer,\n    actions\n  };\n}\n\n// src/query/core/buildSelectors.ts\nvar skipToken = /* @__PURE__ */ Symbol.for(\"RTKQ/skipToken\");\nvar initialSubState = {\n  status: \"uninitialized\" /* uninitialized */\n};\nvar defaultQuerySubState = /* @__PURE__ */ (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(initialSubState, () => {\n});\nvar defaultMutationSubState = /* @__PURE__ */ (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(initialSubState, () => {\n});\nfunction buildSelectors({\n  serializeQueryArgs,\n  reducerPath,\n  createSelector: createSelector2\n}) {\n  const selectSkippedQuery = (state) => defaultQuerySubState;\n  const selectSkippedMutation = (state) => defaultMutationSubState;\n  return {\n    buildQuerySelector,\n    buildInfiniteQuerySelector,\n    buildMutationSelector,\n    selectInvalidatedBy,\n    selectCachedArgsForQuery,\n    selectApiState,\n    selectQueries,\n    selectMutations,\n    selectQueryEntry,\n    selectConfig\n  };\n  function withRequestFlags(substate) {\n    return {\n      ...substate,\n      ...getRequestStatusFlags(substate.status)\n    };\n  }\n  function selectApiState(rootState) {\n    const state = rootState[reducerPath];\n    if (true) {\n      if (!state) {\n        if (selectApiState.triggered) return state;\n        selectApiState.triggered = true;\n        console.error(`Error: No data found at \\`state.${reducerPath}\\`. Did you forget to add the reducer to the store?`);\n      }\n    }\n    return state;\n  }\n  function selectQueries(rootState) {\n    return selectApiState(rootState)?.queries;\n  }\n  function selectQueryEntry(rootState, cacheKey) {\n    return selectQueries(rootState)?.[cacheKey];\n  }\n  function selectMutations(rootState) {\n    return selectApiState(rootState)?.mutations;\n  }\n  function selectConfig(rootState) {\n    return selectApiState(rootState)?.config;\n  }\n  function buildAnyQuerySelector(endpointName, endpointDefinition, combiner) {\n    return (queryArgs) => {\n      if (queryArgs === skipToken) {\n        return createSelector2(selectSkippedQuery, combiner);\n      }\n      const serializedArgs = serializeQueryArgs({\n        queryArgs,\n        endpointDefinition,\n        endpointName\n      });\n      const selectQuerySubstate = (state) => selectQueryEntry(state, serializedArgs) ?? defaultQuerySubState;\n      return createSelector2(selectQuerySubstate, combiner);\n    };\n  }\n  function buildQuerySelector(endpointName, endpointDefinition) {\n    return buildAnyQuerySelector(endpointName, endpointDefinition, withRequestFlags);\n  }\n  function buildInfiniteQuerySelector(endpointName, endpointDefinition) {\n    const {\n      infiniteQueryOptions\n    } = endpointDefinition;\n    function withInfiniteQueryResultFlags(substate) {\n      const stateWithRequestFlags = {\n        ...substate,\n        ...getRequestStatusFlags(substate.status)\n      };\n      const {\n        isLoading,\n        isError,\n        direction\n      } = stateWithRequestFlags;\n      const isForward = direction === \"forward\";\n      const isBackward = direction === \"backward\";\n      return {\n        ...stateWithRequestFlags,\n        hasNextPage: getHasNextPage(infiniteQueryOptions, stateWithRequestFlags.data),\n        hasPreviousPage: getHasPreviousPage(infiniteQueryOptions, stateWithRequestFlags.data),\n        isFetchingNextPage: isLoading && isForward,\n        isFetchingPreviousPage: isLoading && isBackward,\n        isFetchNextPageError: isError && isForward,\n        isFetchPreviousPageError: isError && isBackward\n      };\n    }\n    return buildAnyQuerySelector(endpointName, endpointDefinition, withInfiniteQueryResultFlags);\n  }\n  function buildMutationSelector() {\n    return (id) => {\n      let mutationId;\n      if (typeof id === \"object\") {\n        mutationId = getMutationCacheKey(id) ?? skipToken;\n      } else {\n        mutationId = id;\n      }\n      const selectMutationSubstate = (state) => selectApiState(state)?.mutations?.[mutationId] ?? defaultMutationSubState;\n      const finalSelectMutationSubstate = mutationId === skipToken ? selectSkippedMutation : selectMutationSubstate;\n      return createSelector2(finalSelectMutationSubstate, withRequestFlags);\n    };\n  }\n  function selectInvalidatedBy(state, tags) {\n    const apiState = state[reducerPath];\n    const toInvalidate = /* @__PURE__ */ new Set();\n    for (const tag of tags.filter(isNotNullish).map(expandTagDescription)) {\n      const provided = apiState.provided[tag.type];\n      if (!provided) {\n        continue;\n      }\n      let invalidateSubscriptions = (tag.id !== void 0 ? (\n        // id given: invalidate all queries that provide this type & id\n        provided[tag.id]\n      ) : (\n        // no id: invalidate all queries that provide this type\n        flatten(Object.values(provided))\n      )) ?? [];\n      for (const invalidate of invalidateSubscriptions) {\n        toInvalidate.add(invalidate);\n      }\n    }\n    return flatten(Array.from(toInvalidate.values()).map((queryCacheKey) => {\n      const querySubState = apiState.queries[queryCacheKey];\n      return querySubState ? [{\n        queryCacheKey,\n        endpointName: querySubState.endpointName,\n        originalArgs: querySubState.originalArgs\n      }] : [];\n    }));\n  }\n  function selectCachedArgsForQuery(state, queryName) {\n    return Object.values(selectQueries(state)).filter((entry) => entry?.endpointName === queryName && entry.status !== \"uninitialized\" /* uninitialized */).map((entry) => entry.originalArgs);\n  }\n  function getHasNextPage(options, data) {\n    if (!data) return false;\n    return getNextPageParam(options, data) != null;\n  }\n  function getHasPreviousPage(options, data) {\n    if (!data || !options.getPreviousPageParam) return false;\n    return getPreviousPageParam(options, data) != null;\n  }\n}\n\n// src/query/createApi.ts\n\n\n// src/query/defaultSerializeQueryArgs.ts\nvar cache = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0;\nvar defaultSerializeQueryArgs = ({\n  endpointName,\n  queryArgs\n}) => {\n  let serialized = \"\";\n  const cached = cache?.get(queryArgs);\n  if (typeof cached === \"string\") {\n    serialized = cached;\n  } else {\n    const stringified = JSON.stringify(queryArgs, (key, value) => {\n      value = typeof value === \"bigint\" ? {\n        $bigint: value.toString()\n      } : value;\n      value = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) ? Object.keys(value).sort().reduce((acc, key2) => {\n        acc[key2] = value[key2];\n        return acc;\n      }, {}) : value;\n      return value;\n    });\n    if ((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(queryArgs)) {\n      cache?.set(queryArgs, stringified);\n    }\n    serialized = stringified;\n  }\n  return `${endpointName}(${serialized})`;\n};\n\n// src/query/createApi.ts\n\nfunction buildCreateApi(...modules) {\n  return function baseCreateApi(options) {\n    const extractRehydrationInfo = (0,reselect__WEBPACK_IMPORTED_MODULE_3__.weakMapMemoize)((action) => options.extractRehydrationInfo?.(action, {\n      reducerPath: options.reducerPath ?? \"api\"\n    }));\n    const optionsWithDefaults = {\n      reducerPath: \"api\",\n      keepUnusedDataFor: 60,\n      refetchOnMountOrArgChange: false,\n      refetchOnFocus: false,\n      refetchOnReconnect: false,\n      invalidationBehavior: \"delayed\",\n      ...options,\n      extractRehydrationInfo,\n      serializeQueryArgs(queryArgsApi) {\n        let finalSerializeQueryArgs = defaultSerializeQueryArgs;\n        if (\"serializeQueryArgs\" in queryArgsApi.endpointDefinition) {\n          const endpointSQA = queryArgsApi.endpointDefinition.serializeQueryArgs;\n          finalSerializeQueryArgs = (queryArgsApi2) => {\n            const initialResult = endpointSQA(queryArgsApi2);\n            if (typeof initialResult === \"string\") {\n              return initialResult;\n            } else {\n              return defaultSerializeQueryArgs({\n                ...queryArgsApi2,\n                queryArgs: initialResult\n              });\n            }\n          };\n        } else if (options.serializeQueryArgs) {\n          finalSerializeQueryArgs = options.serializeQueryArgs;\n        }\n        return finalSerializeQueryArgs(queryArgsApi);\n      },\n      tagTypes: [...options.tagTypes || []]\n    };\n    const context = {\n      endpointDefinitions: {},\n      batch(fn) {\n        fn();\n      },\n      apiUid: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.nanoid)(),\n      extractRehydrationInfo,\n      hasRehydrationInfo: (0,reselect__WEBPACK_IMPORTED_MODULE_3__.weakMapMemoize)((action) => extractRehydrationInfo(action) != null)\n    };\n    const api = {\n      injectEndpoints,\n      enhanceEndpoints({\n        addTagTypes,\n        endpoints\n      }) {\n        if (addTagTypes) {\n          for (const eT of addTagTypes) {\n            if (!optionsWithDefaults.tagTypes.includes(eT)) {\n              ;\n              optionsWithDefaults.tagTypes.push(eT);\n            }\n          }\n        }\n        if (endpoints) {\n          for (const [endpointName, partialDefinition] of Object.entries(endpoints)) {\n            if (typeof partialDefinition === \"function\") {\n              partialDefinition(context.endpointDefinitions[endpointName]);\n            } else {\n              Object.assign(context.endpointDefinitions[endpointName] || {}, partialDefinition);\n            }\n          }\n        }\n        return api;\n      }\n    };\n    const initializedModules = modules.map((m) => m.init(api, optionsWithDefaults, context));\n    function injectEndpoints(inject) {\n      const evaluatedEndpoints = inject.endpoints({\n        query: (x) => ({\n          ...x,\n          type: \"query\" /* query */\n        }),\n        mutation: (x) => ({\n          ...x,\n          type: \"mutation\" /* mutation */\n        }),\n        infiniteQuery: (x) => ({\n          ...x,\n          type: \"infinitequery\" /* infinitequery */\n        })\n      });\n      for (const [endpointName, definition] of Object.entries(evaluatedEndpoints)) {\n        if (inject.overrideExisting !== true && endpointName in context.endpointDefinitions) {\n          if (inject.overrideExisting === \"throw\") {\n            throw new Error( false ? 0 : `called \\`injectEndpoints\\` to override already-existing endpointName ${endpointName} without specifying \\`overrideExisting: true\\``);\n          } else if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n            console.error(`called \\`injectEndpoints\\` to override already-existing endpointName ${endpointName} without specifying \\`overrideExisting: true\\``);\n          }\n          continue;\n        }\n        if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n          if (isInfiniteQueryDefinition(definition)) {\n            const {\n              infiniteQueryOptions\n            } = definition;\n            const {\n              maxPages,\n              getPreviousPageParam: getPreviousPageParam2\n            } = infiniteQueryOptions;\n            if (typeof maxPages === \"number\") {\n              if (maxPages < 1) {\n                throw new Error( false ? 0 : `maxPages for endpoint '${endpointName}' must be a number greater than 0`);\n              }\n              if (typeof getPreviousPageParam2 !== \"function\") {\n                throw new Error( false ? 0 : `getPreviousPageParam for endpoint '${endpointName}' must be a function if maxPages is used`);\n              }\n            }\n          }\n        }\n        context.endpointDefinitions[endpointName] = definition;\n        for (const m of initializedModules) {\n          m.injectEndpoint(endpointName, definition);\n        }\n      }\n      return api;\n    }\n    return api.injectEndpoints({\n      endpoints: options.endpoints\n    });\n  };\n}\n\n// src/query/fakeBaseQuery.ts\n\nvar _NEVER = /* @__PURE__ */ Symbol();\nfunction fakeBaseQuery() {\n  return function() {\n    throw new Error( false ? 0 : \"When using `fakeBaseQuery`, all queries & mutations must use the `queryFn` definition syntax.\");\n  };\n}\n\n// src/query/core/module.ts\n\n\n// src/query/tsHelpers.ts\nfunction assertCast(v) {\n}\nfunction safeAssign(target, ...args) {\n  return Object.assign(target, ...args);\n}\n\n// src/query/core/buildMiddleware/batchActions.ts\n\nvar buildBatchedActionsHandler = ({\n  api,\n  queryThunk,\n  internalState\n}) => {\n  const subscriptionsPrefix = `${api.reducerPath}/subscriptions`;\n  let previousSubscriptions = null;\n  let updateSyncTimer = null;\n  const {\n    updateSubscriptionOptions,\n    unsubscribeQueryResult\n  } = api.internalActions;\n  const actuallyMutateSubscriptions = (mutableState, action) => {\n    if (updateSubscriptionOptions.match(action)) {\n      const {\n        queryCacheKey,\n        requestId,\n        options\n      } = action.payload;\n      if (mutableState?.[queryCacheKey]?.[requestId]) {\n        mutableState[queryCacheKey][requestId] = options;\n      }\n      return true;\n    }\n    if (unsubscribeQueryResult.match(action)) {\n      const {\n        queryCacheKey,\n        requestId\n      } = action.payload;\n      if (mutableState[queryCacheKey]) {\n        delete mutableState[queryCacheKey][requestId];\n      }\n      return true;\n    }\n    if (api.internalActions.removeQueryResult.match(action)) {\n      delete mutableState[action.payload.queryCacheKey];\n      return true;\n    }\n    if (queryThunk.pending.match(action)) {\n      const {\n        meta: {\n          arg,\n          requestId\n        }\n      } = action;\n      const substate = mutableState[arg.queryCacheKey] ??= {};\n      substate[`${requestId}_running`] = {};\n      if (arg.subscribe) {\n        substate[requestId] = arg.subscriptionOptions ?? substate[requestId] ?? {};\n      }\n      return true;\n    }\n    let mutated = false;\n    if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action)) {\n      const state = mutableState[action.meta.arg.queryCacheKey] || {};\n      const key = `${action.meta.requestId}_running`;\n      mutated ||= !!state[key];\n      delete state[key];\n    }\n    if (queryThunk.rejected.match(action)) {\n      const {\n        meta: {\n          condition,\n          arg,\n          requestId\n        }\n      } = action;\n      if (condition && arg.subscribe) {\n        const substate = mutableState[arg.queryCacheKey] ??= {};\n        substate[requestId] = arg.subscriptionOptions ?? substate[requestId] ?? {};\n        mutated = true;\n      }\n    }\n    return mutated;\n  };\n  const getSubscriptions = () => internalState.currentSubscriptions;\n  const getSubscriptionCount = (queryCacheKey) => {\n    const subscriptions = getSubscriptions();\n    const subscriptionsForQueryArg = subscriptions[queryCacheKey] ?? {};\n    return countObjectKeys(subscriptionsForQueryArg);\n  };\n  const isRequestSubscribed = (queryCacheKey, requestId) => {\n    const subscriptions = getSubscriptions();\n    return !!subscriptions?.[queryCacheKey]?.[requestId];\n  };\n  const subscriptionSelectors = {\n    getSubscriptions,\n    getSubscriptionCount,\n    isRequestSubscribed\n  };\n  return (action, mwApi) => {\n    if (!previousSubscriptions) {\n      previousSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));\n    }\n    if (api.util.resetApiState.match(action)) {\n      previousSubscriptions = internalState.currentSubscriptions = {};\n      updateSyncTimer = null;\n      return [true, false];\n    }\n    if (api.internalActions.internal_getRTKQSubscriptions.match(action)) {\n      return [false, subscriptionSelectors];\n    }\n    const didMutate = actuallyMutateSubscriptions(internalState.currentSubscriptions, action);\n    let actionShouldContinue = true;\n    if (didMutate) {\n      if (!updateSyncTimer) {\n        updateSyncTimer = setTimeout(() => {\n          const newSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));\n          const [, patches] = (0,immer__WEBPACK_IMPORTED_MODULE_2__.produceWithPatches)(previousSubscriptions, () => newSubscriptions);\n          mwApi.next(api.internalActions.subscriptionsUpdated(patches));\n          previousSubscriptions = newSubscriptions;\n          updateSyncTimer = null;\n        }, 500);\n      }\n      const isSubscriptionSliceAction = typeof action.type == \"string\" && !!action.type.startsWith(subscriptionsPrefix);\n      const isAdditionalSubscriptionAction = queryThunk.rejected.match(action) && action.meta.condition && !!action.meta.arg.subscribe;\n      actionShouldContinue = !isSubscriptionSliceAction && !isAdditionalSubscriptionAction;\n    }\n    return [actionShouldContinue, false];\n  };\n};\n\n// src/query/core/buildMiddleware/cacheCollection.ts\nfunction isObjectEmpty(obj) {\n  for (const k in obj) {\n    return false;\n  }\n  return true;\n}\nvar THIRTY_TWO_BIT_MAX_TIMER_SECONDS = 2147483647 / 1e3 - 1;\nvar buildCacheCollectionHandler = ({\n  reducerPath,\n  api,\n  queryThunk,\n  context,\n  internalState,\n  selectors: {\n    selectQueryEntry,\n    selectConfig\n  }\n}) => {\n  const {\n    removeQueryResult,\n    unsubscribeQueryResult,\n    cacheEntriesUpserted\n  } = api.internalActions;\n  const canTriggerUnsubscribe = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAnyOf)(unsubscribeQueryResult.match, queryThunk.fulfilled, queryThunk.rejected, cacheEntriesUpserted.match);\n  function anySubscriptionsRemainingForKey(queryCacheKey) {\n    const subscriptions = internalState.currentSubscriptions[queryCacheKey];\n    return !!subscriptions && !isObjectEmpty(subscriptions);\n  }\n  const currentRemovalTimeouts = {};\n  const handler = (action, mwApi, internalState2) => {\n    const state = mwApi.getState();\n    const config = selectConfig(state);\n    if (canTriggerUnsubscribe(action)) {\n      let queryCacheKeys;\n      if (cacheEntriesUpserted.match(action)) {\n        queryCacheKeys = action.payload.map((entry) => entry.queryDescription.queryCacheKey);\n      } else {\n        const {\n          queryCacheKey\n        } = unsubscribeQueryResult.match(action) ? action.payload : action.meta.arg;\n        queryCacheKeys = [queryCacheKey];\n      }\n      handleUnsubscribeMany(queryCacheKeys, mwApi, config);\n    }\n    if (api.util.resetApiState.match(action)) {\n      for (const [key, timeout] of Object.entries(currentRemovalTimeouts)) {\n        if (timeout) clearTimeout(timeout);\n        delete currentRemovalTimeouts[key];\n      }\n    }\n    if (context.hasRehydrationInfo(action)) {\n      const {\n        queries\n      } = context.extractRehydrationInfo(action);\n      handleUnsubscribeMany(Object.keys(queries), mwApi, config);\n    }\n  };\n  function handleUnsubscribeMany(cacheKeys, api2, config) {\n    const state = api2.getState();\n    for (const queryCacheKey of cacheKeys) {\n      const entry = selectQueryEntry(state, queryCacheKey);\n      handleUnsubscribe(queryCacheKey, entry?.endpointName, api2, config);\n    }\n  }\n  function handleUnsubscribe(queryCacheKey, endpointName, api2, config) {\n    const endpointDefinition = context.endpointDefinitions[endpointName];\n    const keepUnusedDataFor = endpointDefinition?.keepUnusedDataFor ?? config.keepUnusedDataFor;\n    if (keepUnusedDataFor === Infinity) {\n      return;\n    }\n    const finalKeepUnusedDataFor = Math.max(0, Math.min(keepUnusedDataFor, THIRTY_TWO_BIT_MAX_TIMER_SECONDS));\n    if (!anySubscriptionsRemainingForKey(queryCacheKey)) {\n      const currentTimeout = currentRemovalTimeouts[queryCacheKey];\n      if (currentTimeout) {\n        clearTimeout(currentTimeout);\n      }\n      currentRemovalTimeouts[queryCacheKey] = setTimeout(() => {\n        if (!anySubscriptionsRemainingForKey(queryCacheKey)) {\n          api2.dispatch(removeQueryResult({\n            queryCacheKey\n          }));\n        }\n        delete currentRemovalTimeouts[queryCacheKey];\n      }, finalKeepUnusedDataFor * 1e3);\n    }\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/cacheLifecycle.ts\nvar neverResolvedError = new Error(\"Promise never resolved before cacheEntryRemoved.\");\nvar buildCacheLifecycleHandler = ({\n  api,\n  reducerPath,\n  context,\n  queryThunk,\n  mutationThunk,\n  internalState,\n  selectors: {\n    selectQueryEntry,\n    selectApiState\n  }\n}) => {\n  const isQueryThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAsyncThunkAction)(queryThunk);\n  const isMutationThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAsyncThunkAction)(mutationThunk);\n  const isFulfilledThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(queryThunk, mutationThunk);\n  const lifecycleMap = {};\n  function resolveLifecycleEntry(cacheKey, data, meta) {\n    const lifecycle = lifecycleMap[cacheKey];\n    if (lifecycle?.valueResolved) {\n      lifecycle.valueResolved({\n        data,\n        meta\n      });\n      delete lifecycle.valueResolved;\n    }\n  }\n  function removeLifecycleEntry(cacheKey) {\n    const lifecycle = lifecycleMap[cacheKey];\n    if (lifecycle) {\n      delete lifecycleMap[cacheKey];\n      lifecycle.cacheEntryRemoved();\n    }\n  }\n  const handler = (action, mwApi, stateBefore) => {\n    const cacheKey = getCacheKey(action);\n    function checkForNewCacheKey(endpointName, cacheKey2, requestId, originalArgs) {\n      const oldEntry = selectQueryEntry(stateBefore, cacheKey2);\n      const newEntry = selectQueryEntry(mwApi.getState(), cacheKey2);\n      if (!oldEntry && newEntry) {\n        handleNewKey(endpointName, originalArgs, cacheKey2, mwApi, requestId);\n      }\n    }\n    if (queryThunk.pending.match(action)) {\n      checkForNewCacheKey(action.meta.arg.endpointName, cacheKey, action.meta.requestId, action.meta.arg.originalArgs);\n    } else if (api.internalActions.cacheEntriesUpserted.match(action)) {\n      for (const {\n        queryDescription,\n        value\n      } of action.payload) {\n        const {\n          endpointName,\n          originalArgs,\n          queryCacheKey\n        } = queryDescription;\n        checkForNewCacheKey(endpointName, queryCacheKey, action.meta.requestId, originalArgs);\n        resolveLifecycleEntry(queryCacheKey, value, {});\n      }\n    } else if (mutationThunk.pending.match(action)) {\n      const state = mwApi.getState()[reducerPath].mutations[cacheKey];\n      if (state) {\n        handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);\n      }\n    } else if (isFulfilledThunk(action)) {\n      resolveLifecycleEntry(cacheKey, action.payload, action.meta.baseQueryMeta);\n    } else if (api.internalActions.removeQueryResult.match(action) || api.internalActions.removeMutationResult.match(action)) {\n      removeLifecycleEntry(cacheKey);\n    } else if (api.util.resetApiState.match(action)) {\n      for (const cacheKey2 of Object.keys(lifecycleMap)) {\n        removeLifecycleEntry(cacheKey2);\n      }\n    }\n  };\n  function getCacheKey(action) {\n    if (isQueryThunk(action)) return action.meta.arg.queryCacheKey;\n    if (isMutationThunk(action)) {\n      return action.meta.arg.fixedCacheKey ?? action.meta.requestId;\n    }\n    if (api.internalActions.removeQueryResult.match(action)) return action.payload.queryCacheKey;\n    if (api.internalActions.removeMutationResult.match(action)) return getMutationCacheKey(action.payload);\n    return \"\";\n  }\n  function handleNewKey(endpointName, originalArgs, queryCacheKey, mwApi, requestId) {\n    const endpointDefinition = context.endpointDefinitions[endpointName];\n    const onCacheEntryAdded = endpointDefinition?.onCacheEntryAdded;\n    if (!onCacheEntryAdded) return;\n    const lifecycle = {};\n    const cacheEntryRemoved = new Promise((resolve) => {\n      lifecycle.cacheEntryRemoved = resolve;\n    });\n    const cacheDataLoaded = Promise.race([new Promise((resolve) => {\n      lifecycle.valueResolved = resolve;\n    }), cacheEntryRemoved.then(() => {\n      throw neverResolvedError;\n    })]);\n    cacheDataLoaded.catch(() => {\n    });\n    lifecycleMap[queryCacheKey] = lifecycle;\n    const selector = api.endpoints[endpointName].select(endpointDefinition.type === \"query\" /* query */ ? originalArgs : queryCacheKey);\n    const extra = mwApi.dispatch((_, __, extra2) => extra2);\n    const lifecycleApi = {\n      ...mwApi,\n      getCacheEntry: () => selector(mwApi.getState()),\n      requestId,\n      extra,\n      updateCachedData: endpointDefinition.type === \"query\" /* query */ ? (updateRecipe) => mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,\n      cacheDataLoaded,\n      cacheEntryRemoved\n    };\n    const runningHandler = onCacheEntryAdded(originalArgs, lifecycleApi);\n    Promise.resolve(runningHandler).catch((e) => {\n      if (e === neverResolvedError) return;\n      throw e;\n    });\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/devMiddleware.ts\nvar buildDevCheckHandler = ({\n  api,\n  context: {\n    apiUid\n  },\n  reducerPath\n}) => {\n  return (action, mwApi) => {\n    if (api.util.resetApiState.match(action)) {\n      mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));\n    }\n    if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n      if (api.internalActions.middlewareRegistered.match(action) && action.payload === apiUid && mwApi.getState()[reducerPath]?.config?.middlewareRegistered === \"conflict\") {\n        console.warn(`There is a mismatch between slice and middleware for the reducerPath \"${reducerPath}\".\nYou can only have one api per reducer path, this will lead to crashes in various situations!${reducerPath === \"api\" ? `\nIf you have multiple apis, you *have* to specify the reducerPath option when using createApi!` : \"\"}`);\n      }\n    }\n  };\n};\n\n// src/query/core/buildMiddleware/invalidationByTags.ts\nvar buildInvalidationByTagsHandler = ({\n  reducerPath,\n  context,\n  context: {\n    endpointDefinitions\n  },\n  mutationThunk,\n  queryThunk,\n  api,\n  assertTagType,\n  refetchQuery,\n  internalState\n}) => {\n  const {\n    removeQueryResult\n  } = api.internalActions;\n  const isThunkActionWithTags = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAnyOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(mutationThunk), (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejectedWithValue)(mutationThunk));\n  const isQueryEnd = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAnyOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(mutationThunk, queryThunk), (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejected)(mutationThunk, queryThunk));\n  let pendingTagInvalidations = [];\n  const handler = (action, mwApi) => {\n    if (isThunkActionWithTags(action)) {\n      invalidateTags(calculateProvidedByThunk(action, \"invalidatesTags\", endpointDefinitions, assertTagType), mwApi);\n    } else if (isQueryEnd(action)) {\n      invalidateTags([], mwApi);\n    } else if (api.util.invalidateTags.match(action)) {\n      invalidateTags(calculateProvidedBy(action.payload, void 0, void 0, void 0, void 0, assertTagType), mwApi);\n    }\n  };\n  function hasPendingRequests(state) {\n    const {\n      queries,\n      mutations\n    } = state;\n    for (const cacheRecord of [queries, mutations]) {\n      for (const key in cacheRecord) {\n        if (cacheRecord[key]?.status === \"pending\" /* pending */) return true;\n      }\n    }\n    return false;\n  }\n  function invalidateTags(newTags, mwApi) {\n    const rootState = mwApi.getState();\n    const state = rootState[reducerPath];\n    pendingTagInvalidations.push(...newTags);\n    if (state.config.invalidationBehavior === \"delayed\" && hasPendingRequests(state)) {\n      return;\n    }\n    const tags = pendingTagInvalidations;\n    pendingTagInvalidations = [];\n    if (tags.length === 0) return;\n    const toInvalidate = api.util.selectInvalidatedBy(rootState, tags);\n    context.batch(() => {\n      const valuesArray = Array.from(toInvalidate.values());\n      for (const {\n        queryCacheKey\n      } of valuesArray) {\n        const querySubState = state.queries[queryCacheKey];\n        const subscriptionSubState = internalState.currentSubscriptions[queryCacheKey] ?? {};\n        if (querySubState) {\n          if (countObjectKeys(subscriptionSubState) === 0) {\n            mwApi.dispatch(removeQueryResult({\n              queryCacheKey\n            }));\n          } else if (querySubState.status !== \"uninitialized\" /* uninitialized */) {\n            mwApi.dispatch(refetchQuery(querySubState));\n          }\n        }\n      }\n    });\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/polling.ts\nvar buildPollingHandler = ({\n  reducerPath,\n  queryThunk,\n  api,\n  refetchQuery,\n  internalState\n}) => {\n  const currentPolls = {};\n  const handler = (action, mwApi) => {\n    if (api.internalActions.updateSubscriptionOptions.match(action) || api.internalActions.unsubscribeQueryResult.match(action)) {\n      updatePollingInterval(action.payload, mwApi);\n    }\n    if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {\n      updatePollingInterval(action.meta.arg, mwApi);\n    }\n    if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {\n      startNextPoll(action.meta.arg, mwApi);\n    }\n    if (api.util.resetApiState.match(action)) {\n      clearPolls();\n    }\n  };\n  function getCacheEntrySubscriptions(queryCacheKey, api2) {\n    const state = api2.getState()[reducerPath];\n    const querySubState = state.queries[queryCacheKey];\n    const subscriptions = internalState.currentSubscriptions[queryCacheKey];\n    if (!querySubState || querySubState.status === \"uninitialized\" /* uninitialized */) return;\n    return subscriptions;\n  }\n  function startNextPoll({\n    queryCacheKey\n  }, api2) {\n    const state = api2.getState()[reducerPath];\n    const querySubState = state.queries[queryCacheKey];\n    const subscriptions = internalState.currentSubscriptions[queryCacheKey];\n    if (!querySubState || querySubState.status === \"uninitialized\" /* uninitialized */) return;\n    const {\n      lowestPollingInterval,\n      skipPollingIfUnfocused\n    } = findLowestPollingInterval(subscriptions);\n    if (!Number.isFinite(lowestPollingInterval)) return;\n    const currentPoll = currentPolls[queryCacheKey];\n    if (currentPoll?.timeout) {\n      clearTimeout(currentPoll.timeout);\n      currentPoll.timeout = void 0;\n    }\n    const nextPollTimestamp = Date.now() + lowestPollingInterval;\n    currentPolls[queryCacheKey] = {\n      nextPollTimestamp,\n      pollingInterval: lowestPollingInterval,\n      timeout: setTimeout(() => {\n        if (state.config.focused || !skipPollingIfUnfocused) {\n          api2.dispatch(refetchQuery(querySubState));\n        }\n        startNextPoll({\n          queryCacheKey\n        }, api2);\n      }, lowestPollingInterval)\n    };\n  }\n  function updatePollingInterval({\n    queryCacheKey\n  }, api2) {\n    const state = api2.getState()[reducerPath];\n    const querySubState = state.queries[queryCacheKey];\n    const subscriptions = internalState.currentSubscriptions[queryCacheKey];\n    if (!querySubState || querySubState.status === \"uninitialized\" /* uninitialized */) {\n      return;\n    }\n    const {\n      lowestPollingInterval\n    } = findLowestPollingInterval(subscriptions);\n    if (!Number.isFinite(lowestPollingInterval)) {\n      cleanupPollForKey(queryCacheKey);\n      return;\n    }\n    const currentPoll = currentPolls[queryCacheKey];\n    const nextPollTimestamp = Date.now() + lowestPollingInterval;\n    if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {\n      startNextPoll({\n        queryCacheKey\n      }, api2);\n    }\n  }\n  function cleanupPollForKey(key) {\n    const existingPoll = currentPolls[key];\n    if (existingPoll?.timeout) {\n      clearTimeout(existingPoll.timeout);\n    }\n    delete currentPolls[key];\n  }\n  function clearPolls() {\n    for (const key of Object.keys(currentPolls)) {\n      cleanupPollForKey(key);\n    }\n  }\n  function findLowestPollingInterval(subscribers = {}) {\n    let skipPollingIfUnfocused = false;\n    let lowestPollingInterval = Number.POSITIVE_INFINITY;\n    for (let key in subscribers) {\n      if (!!subscribers[key].pollingInterval) {\n        lowestPollingInterval = Math.min(subscribers[key].pollingInterval, lowestPollingInterval);\n        skipPollingIfUnfocused = subscribers[key].skipPollingIfUnfocused || skipPollingIfUnfocused;\n      }\n    }\n    return {\n      lowestPollingInterval,\n      skipPollingIfUnfocused\n    };\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/queryLifecycle.ts\nvar buildQueryLifecycleHandler = ({\n  api,\n  context,\n  queryThunk,\n  mutationThunk\n}) => {\n  const isPendingThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isPending)(queryThunk, mutationThunk);\n  const isRejectedThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejected)(queryThunk, mutationThunk);\n  const isFullfilledThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(queryThunk, mutationThunk);\n  const lifecycleMap = {};\n  const handler = (action, mwApi) => {\n    if (isPendingThunk(action)) {\n      const {\n        requestId,\n        arg: {\n          endpointName,\n          originalArgs\n        }\n      } = action.meta;\n      const endpointDefinition = context.endpointDefinitions[endpointName];\n      const onQueryStarted = endpointDefinition?.onQueryStarted;\n      if (onQueryStarted) {\n        const lifecycle = {};\n        const queryFulfilled = new Promise((resolve, reject) => {\n          lifecycle.resolve = resolve;\n          lifecycle.reject = reject;\n        });\n        queryFulfilled.catch(() => {\n        });\n        lifecycleMap[requestId] = lifecycle;\n        const selector = api.endpoints[endpointName].select(endpointDefinition.type === \"query\" /* query */ ? originalArgs : requestId);\n        const extra = mwApi.dispatch((_, __, extra2) => extra2);\n        const lifecycleApi = {\n          ...mwApi,\n          getCacheEntry: () => selector(mwApi.getState()),\n          requestId,\n          extra,\n          updateCachedData: endpointDefinition.type === \"query\" /* query */ ? (updateRecipe) => mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,\n          queryFulfilled\n        };\n        onQueryStarted(originalArgs, lifecycleApi);\n      }\n    } else if (isFullfilledThunk(action)) {\n      const {\n        requestId,\n        baseQueryMeta\n      } = action.meta;\n      lifecycleMap[requestId]?.resolve({\n        data: action.payload,\n        meta: baseQueryMeta\n      });\n      delete lifecycleMap[requestId];\n    } else if (isRejectedThunk(action)) {\n      const {\n        requestId,\n        rejectedWithValue,\n        baseQueryMeta\n      } = action.meta;\n      lifecycleMap[requestId]?.reject({\n        error: action.payload ?? action.error,\n        isUnhandledError: !rejectedWithValue,\n        meta: baseQueryMeta\n      });\n      delete lifecycleMap[requestId];\n    }\n  };\n  return handler;\n};\n\n// src/query/core/buildMiddleware/windowEventHandling.ts\nvar buildWindowEventHandler = ({\n  reducerPath,\n  context,\n  api,\n  refetchQuery,\n  internalState\n}) => {\n  const {\n    removeQueryResult\n  } = api.internalActions;\n  const handler = (action, mwApi) => {\n    if (onFocus.match(action)) {\n      refetchValidQueries(mwApi, \"refetchOnFocus\");\n    }\n    if (onOnline.match(action)) {\n      refetchValidQueries(mwApi, \"refetchOnReconnect\");\n    }\n  };\n  function refetchValidQueries(api2, type) {\n    const state = api2.getState()[reducerPath];\n    const queries = state.queries;\n    const subscriptions = internalState.currentSubscriptions;\n    context.batch(() => {\n      for (const queryCacheKey of Object.keys(subscriptions)) {\n        const querySubState = queries[queryCacheKey];\n        const subscriptionSubState = subscriptions[queryCacheKey];\n        if (!subscriptionSubState || !querySubState) continue;\n        const shouldRefetch = Object.values(subscriptionSubState).some((sub) => sub[type] === true) || Object.values(subscriptionSubState).every((sub) => sub[type] === void 0) && state.config[type];\n        if (shouldRefetch) {\n          if (countObjectKeys(subscriptionSubState) === 0) {\n            api2.dispatch(removeQueryResult({\n              queryCacheKey\n            }));\n          } else if (querySubState.status !== \"uninitialized\" /* uninitialized */) {\n            api2.dispatch(refetchQuery(querySubState));\n          }\n        }\n      }\n    });\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/index.ts\nfunction buildMiddleware(input) {\n  const {\n    reducerPath,\n    queryThunk,\n    api,\n    context\n  } = input;\n  const {\n    apiUid\n  } = context;\n  const actions = {\n    invalidateTags: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(`${reducerPath}/invalidateTags`)\n  };\n  const isThisApiSliceAction = (action) => action.type.startsWith(`${reducerPath}/`);\n  const handlerBuilders = [buildDevCheckHandler, buildCacheCollectionHandler, buildInvalidationByTagsHandler, buildPollingHandler, buildCacheLifecycleHandler, buildQueryLifecycleHandler];\n  const middleware = (mwApi) => {\n    let initialized2 = false;\n    const internalState = {\n      currentSubscriptions: {}\n    };\n    const builderArgs = {\n      ...input,\n      internalState,\n      refetchQuery,\n      isThisApiSliceAction\n    };\n    const handlers = handlerBuilders.map((build) => build(builderArgs));\n    const batchedActionsHandler = buildBatchedActionsHandler(builderArgs);\n    const windowEventsHandler = buildWindowEventHandler(builderArgs);\n    return (next) => {\n      return (action) => {\n        if (!(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n          return next(action);\n        }\n        if (!initialized2) {\n          initialized2 = true;\n          mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));\n        }\n        const mwApiWithNext = {\n          ...mwApi,\n          next\n        };\n        const stateBefore = mwApi.getState();\n        const [actionShouldContinue, internalProbeResult] = batchedActionsHandler(action, mwApiWithNext, stateBefore);\n        let res;\n        if (actionShouldContinue) {\n          res = next(action);\n        } else {\n          res = internalProbeResult;\n        }\n        if (!!mwApi.getState()[reducerPath]) {\n          windowEventsHandler(action, mwApiWithNext, stateBefore);\n          if (isThisApiSliceAction(action) || context.hasRehydrationInfo(action)) {\n            for (const handler of handlers) {\n              handler(action, mwApiWithNext, stateBefore);\n            }\n          }\n        }\n        return res;\n      };\n    };\n  };\n  return {\n    middleware,\n    actions\n  };\n  function refetchQuery(querySubState) {\n    return input.api.endpoints[querySubState.endpointName].initiate(querySubState.originalArgs, {\n      subscribe: false,\n      forceRefetch: true\n    });\n  }\n}\n\n// src/query/core/module.ts\nvar coreModuleName = /* @__PURE__ */ Symbol();\nvar coreModule = ({\n  createSelector: createSelector2 = reselect__WEBPACK_IMPORTED_MODULE_3__.createSelector\n} = {}) => ({\n  name: coreModuleName,\n  init(api, {\n    baseQuery,\n    tagTypes,\n    reducerPath,\n    serializeQueryArgs,\n    keepUnusedDataFor,\n    refetchOnMountOrArgChange,\n    refetchOnFocus,\n    refetchOnReconnect,\n    invalidationBehavior\n  }, context) {\n    (0,immer__WEBPACK_IMPORTED_MODULE_2__.enablePatches)();\n    assertCast(serializeQueryArgs);\n    const assertTagType = (tag) => {\n      if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n        if (!tagTypes.includes(tag.type)) {\n          console.error(`Tag type '${tag.type}' was used, but not specified in \\`tagTypes\\`!`);\n        }\n      }\n      return tag;\n    };\n    Object.assign(api, {\n      reducerPath,\n      endpoints: {},\n      internalActions: {\n        onOnline,\n        onOffline,\n        onFocus,\n        onFocusLost\n      },\n      util: {}\n    });\n    const selectors = buildSelectors({\n      serializeQueryArgs,\n      reducerPath,\n      createSelector: createSelector2\n    });\n    const {\n      selectInvalidatedBy,\n      selectCachedArgsForQuery,\n      buildQuerySelector,\n      buildInfiniteQuerySelector,\n      buildMutationSelector\n    } = selectors;\n    safeAssign(api.util, {\n      selectInvalidatedBy,\n      selectCachedArgsForQuery\n    });\n    const {\n      queryThunk,\n      infiniteQueryThunk,\n      mutationThunk,\n      patchQueryData,\n      updateQueryData,\n      upsertQueryData,\n      prefetch,\n      buildMatchThunkActions\n    } = buildThunks({\n      baseQuery,\n      reducerPath,\n      context,\n      api,\n      serializeQueryArgs,\n      assertTagType,\n      selectors\n    });\n    const {\n      reducer,\n      actions: sliceActions\n    } = buildSlice({\n      context,\n      queryThunk,\n      infiniteQueryThunk,\n      mutationThunk,\n      serializeQueryArgs,\n      reducerPath,\n      assertTagType,\n      config: {\n        refetchOnFocus,\n        refetchOnReconnect,\n        refetchOnMountOrArgChange,\n        keepUnusedDataFor,\n        reducerPath,\n        invalidationBehavior\n      }\n    });\n    safeAssign(api.util, {\n      patchQueryData,\n      updateQueryData,\n      upsertQueryData,\n      prefetch,\n      resetApiState: sliceActions.resetApiState,\n      upsertQueryEntries: sliceActions.cacheEntriesUpserted\n    });\n    safeAssign(api.internalActions, sliceActions);\n    const {\n      middleware,\n      actions: middlewareActions\n    } = buildMiddleware({\n      reducerPath,\n      context,\n      queryThunk,\n      mutationThunk,\n      infiniteQueryThunk,\n      api,\n      assertTagType,\n      selectors\n    });\n    safeAssign(api.util, middlewareActions);\n    safeAssign(api, {\n      reducer,\n      middleware\n    });\n    const {\n      buildInitiateQuery,\n      buildInitiateInfiniteQuery,\n      buildInitiateMutation,\n      getRunningMutationThunk,\n      getRunningMutationsThunk,\n      getRunningQueriesThunk,\n      getRunningQueryThunk\n    } = buildInitiate({\n      queryThunk,\n      mutationThunk,\n      infiniteQueryThunk,\n      api,\n      serializeQueryArgs,\n      context\n    });\n    safeAssign(api.util, {\n      getRunningMutationThunk,\n      getRunningMutationsThunk,\n      getRunningQueryThunk,\n      getRunningQueriesThunk\n    });\n    return {\n      name: coreModuleName,\n      injectEndpoint(endpointName, definition) {\n        const anyApi = api;\n        const endpoint = anyApi.endpoints[endpointName] ??= {};\n        if (isQueryDefinition(definition)) {\n          safeAssign(endpoint, {\n            name: endpointName,\n            select: buildQuerySelector(endpointName, definition),\n            initiate: buildInitiateQuery(endpointName, definition)\n          }, buildMatchThunkActions(queryThunk, endpointName));\n        }\n        if (isMutationDefinition(definition)) {\n          safeAssign(endpoint, {\n            name: endpointName,\n            select: buildMutationSelector(),\n            initiate: buildInitiateMutation(endpointName)\n          }, buildMatchThunkActions(mutationThunk, endpointName));\n        }\n        if (isInfiniteQueryDefinition(definition)) {\n          safeAssign(endpoint, {\n            name: endpointName,\n            select: buildInfiniteQuerySelector(endpointName, definition),\n            initiate: buildInitiateInfiniteQuery(endpointName, definition)\n          }, buildMatchThunkActions(queryThunk, endpointName));\n        }\n      }\n    };\n  }\n});\n\n// src/query/core/index.ts\nvar createApi = /* @__PURE__ */ buildCreateApi(coreModule());\n\n//# sourceMappingURL=rtk-query.modern.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3F1ZXJ5L3J0ay1xdWVyeS5tb2Rlcm4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG1CQUFtQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDdVM7O0FBRXZTO0FBQ0EscUJBQXFCLDJEQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLLEVBQUUsVUFBVSxFQUFFLElBQUk7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTywrREFBYTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlFQUFpRSwrREFBYTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FB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c1xcQHJlZHV4anNcXHRvb2xraXRcXGRpc3RcXHF1ZXJ5XFxydGstcXVlcnkubW9kZXJuLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcXVlcnkvY29yZS9hcGlTdGF0ZS50c1xudmFyIFF1ZXJ5U3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoUXVlcnlTdGF0dXMyKSA9PiB7XG4gIFF1ZXJ5U3RhdHVzMltcInVuaW5pdGlhbGl6ZWRcIl0gPSBcInVuaW5pdGlhbGl6ZWRcIjtcbiAgUXVlcnlTdGF0dXMyW1wicGVuZGluZ1wiXSA9IFwicGVuZGluZ1wiO1xuICBRdWVyeVN0YXR1czJbXCJmdWxmaWxsZWRcIl0gPSBcImZ1bGZpbGxlZFwiO1xuICBRdWVyeVN0YXR1czJbXCJyZWplY3RlZFwiXSA9IFwicmVqZWN0ZWRcIjtcbiAgcmV0dXJuIFF1ZXJ5U3RhdHVzMjtcbn0pKFF1ZXJ5U3RhdHVzIHx8IHt9KTtcbmZ1bmN0aW9uIGdldFJlcXVlc3RTdGF0dXNGbGFncyhzdGF0dXMpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXMsXG4gICAgaXNVbmluaXRpYWxpemVkOiBzdGF0dXMgPT09IFwidW5pbml0aWFsaXplZFwiIC8qIHVuaW5pdGlhbGl6ZWQgKi8sXG4gICAgaXNMb2FkaW5nOiBzdGF0dXMgPT09IFwicGVuZGluZ1wiIC8qIHBlbmRpbmcgKi8sXG4gICAgaXNTdWNjZXNzOiBzdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIgLyogZnVsZmlsbGVkICovLFxuICAgIGlzRXJyb3I6IHN0YXR1cyA9PT0gXCJyZWplY3RlZFwiIC8qIHJlamVjdGVkICovXG4gIH07XG59XG5cbi8vIHNyYy9xdWVyeS9jb3JlL3J0a0ltcG9ydHMudHNcbmltcG9ydCB7IGNyZWF0ZUFjdGlvbiwgY3JlYXRlU2xpY2UsIGNyZWF0ZVNlbGVjdG9yLCBjcmVhdGVBc3luY1RodW5rLCBjb21iaW5lUmVkdWNlcnMsIGNyZWF0ZU5leHRTdGF0ZSwgaXNBbnlPZiwgaXNBbGxPZiwgaXNBY3Rpb24sIGlzUGVuZGluZywgaXNSZWplY3RlZCwgaXNGdWxmaWxsZWQsIGlzUmVqZWN0ZWRXaXRoVmFsdWUsIGlzQXN5bmNUaHVua0FjdGlvbiwgcHJlcGFyZUF1dG9CYXRjaGVkLCBTSE9VTERfQVVUT0JBVENILCBpc1BsYWluT2JqZWN0LCBuYW5vaWQgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuXG4vLyBzcmMvcXVlcnkvdXRpbHMvY29weVdpdGhTdHJ1Y3R1cmFsU2hhcmluZy50c1xudmFyIGlzUGxhaW5PYmplY3QyID0gaXNQbGFpbk9iamVjdDtcbmZ1bmN0aW9uIGNvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmcob2xkT2JqLCBuZXdPYmopIHtcbiAgaWYgKG9sZE9iaiA9PT0gbmV3T2JqIHx8ICEoaXNQbGFpbk9iamVjdDIob2xkT2JqKSAmJiBpc1BsYWluT2JqZWN0MihuZXdPYmopIHx8IEFycmF5LmlzQXJyYXkob2xkT2JqKSAmJiBBcnJheS5pc0FycmF5KG5ld09iaikpKSB7XG4gICAgcmV0dXJuIG5ld09iajtcbiAgfVxuICBjb25zdCBuZXdLZXlzID0gT2JqZWN0LmtleXMobmV3T2JqKTtcbiAgY29uc3Qgb2xkS2V5cyA9IE9iamVjdC5rZXlzKG9sZE9iaik7XG4gIGxldCBpc1NhbWVPYmplY3QgPSBuZXdLZXlzLmxlbmd0aCA9PT0gb2xkS2V5cy5sZW5ndGg7XG4gIGNvbnN0IG1lcmdlT2JqID0gQXJyYXkuaXNBcnJheShuZXdPYmopID8gW10gOiB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2YgbmV3S2V5cykge1xuICAgIG1lcmdlT2JqW2tleV0gPSBjb3B5V2l0aFN0cnVjdHVyYWxTaGFyaW5nKG9sZE9ialtrZXldLCBuZXdPYmpba2V5XSk7XG4gICAgaWYgKGlzU2FtZU9iamVjdCkgaXNTYW1lT2JqZWN0ID0gb2xkT2JqW2tleV0gPT09IG1lcmdlT2JqW2tleV07XG4gIH1cbiAgcmV0dXJuIGlzU2FtZU9iamVjdCA/IG9sZE9iaiA6IG1lcmdlT2JqO1xufVxuXG4vLyBzcmMvcXVlcnkvdXRpbHMvY291bnRPYmplY3RLZXlzLnRzXG5mdW5jdGlvbiBjb3VudE9iamVjdEtleXMob2JqKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAoY29uc3QgX2tleSBpbiBvYmopIHtcbiAgICBjb3VudCsrO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn1cblxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2ZsYXR0ZW4udHNcbnZhciBmbGF0dGVuID0gKGFycikgPT4gW10uY29uY2F0KC4uLmFycik7XG5cbi8vIHNyYy9xdWVyeS91dGlscy9pc0Fic29sdXRlVXJsLnRzXG5mdW5jdGlvbiBpc0Fic29sdXRlVXJsKHVybCkge1xuICByZXR1cm4gbmV3IFJlZ0V4cChgKF58OikvL2ApLnRlc3QodXJsKTtcbn1cblxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2lzRG9jdW1lbnRWaXNpYmxlLnRzXG5mdW5jdGlvbiBpc0RvY3VtZW50VmlzaWJsZSgpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgIT09IFwiaGlkZGVuXCI7XG59XG5cbi8vIHNyYy9xdWVyeS91dGlscy9pc05vdE51bGxpc2gudHNcbmZ1bmN0aW9uIGlzTm90TnVsbGlzaCh2KSB7XG4gIHJldHVybiB2ICE9IG51bGw7XG59XG5cbi8vIHNyYy9xdWVyeS91dGlscy9pc09ubGluZS50c1xuZnVuY3Rpb24gaXNPbmxpbmUoKSB7XG4gIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yID09PSBcInVuZGVmaW5lZFwiID8gdHJ1ZSA6IG5hdmlnYXRvci5vbkxpbmUgPT09IHZvaWQgMCA/IHRydWUgOiBuYXZpZ2F0b3Iub25MaW5lO1xufVxuXG4vLyBzcmMvcXVlcnkvdXRpbHMvam9pblVybHMudHNcbnZhciB3aXRob3V0VHJhaWxpbmdTbGFzaCA9ICh1cmwpID0+IHVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG52YXIgd2l0aG91dExlYWRpbmdTbGFzaCA9ICh1cmwpID0+IHVybC5yZXBsYWNlKC9eXFwvLywgXCJcIik7XG5mdW5jdGlvbiBqb2luVXJscyhiYXNlLCB1cmwpIHtcbiAgaWYgKCFiYXNlKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBpZiAoIXVybCkge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGlmIChpc0Fic29sdXRlVXJsKHVybCkpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGNvbnN0IGRlbGltaXRlciA9IGJhc2UuZW5kc1dpdGgoXCIvXCIpIHx8ICF1cmwuc3RhcnRzV2l0aChcIj9cIikgPyBcIi9cIiA6IFwiXCI7XG4gIGJhc2UgPSB3aXRob3V0VHJhaWxpbmdTbGFzaChiYXNlKTtcbiAgdXJsID0gd2l0aG91dExlYWRpbmdTbGFzaCh1cmwpO1xuICByZXR1cm4gYCR7YmFzZX0ke2RlbGltaXRlcn0ke3VybH1gO1xufVxuXG4vLyBzcmMvcXVlcnkvdXRpbHMvZ2V0T3JJbnNlcnQudHNcbmZ1bmN0aW9uIGdldE9ySW5zZXJ0KG1hcCwga2V5LCB2YWx1ZSkge1xuICBpZiAobWFwLmhhcyhrZXkpKSByZXR1cm4gbWFwLmdldChrZXkpO1xuICByZXR1cm4gbWFwLnNldChrZXksIHZhbHVlKS5nZXQoa2V5KTtcbn1cblxuLy8gc3JjL3F1ZXJ5L2ZldGNoQmFzZVF1ZXJ5LnRzXG52YXIgZGVmYXVsdEZldGNoRm4gPSAoLi4uYXJncykgPT4gZmV0Y2goLi4uYXJncyk7XG52YXIgZGVmYXVsdFZhbGlkYXRlU3RhdHVzID0gKHJlc3BvbnNlKSA9PiByZXNwb25zZS5zdGF0dXMgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1cyA8PSAyOTk7XG52YXIgZGVmYXVsdElzSnNvbkNvbnRlbnRUeXBlID0gKGhlYWRlcnMpID0+IChcbiAgLyphcHBsaWNhdCovXG4gIC9pb25cXC8odm5kXFwuYXBpXFwrKT9qc29uLy50ZXN0KGhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpIHx8IFwiXCIpXG4pO1xuZnVuY3Rpb24gc3RyaXBVbmRlZmluZWQob2JqKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBjb25zdCBjb3B5ID0ge1xuICAgIC4uLm9ialxuICB9O1xuICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhjb3B5KSkge1xuICAgIGlmICh2ID09PSB2b2lkIDApIGRlbGV0ZSBjb3B5W2tdO1xuICB9XG4gIHJldHVybiBjb3B5O1xufVxuZnVuY3Rpb24gZmV0Y2hCYXNlUXVlcnkoe1xuICBiYXNlVXJsLFxuICBwcmVwYXJlSGVhZGVycyA9ICh4KSA9PiB4LFxuICBmZXRjaEZuID0gZGVmYXVsdEZldGNoRm4sXG4gIHBhcmFtc1NlcmlhbGl6ZXIsXG4gIGlzSnNvbkNvbnRlbnRUeXBlID0gZGVmYXVsdElzSnNvbkNvbnRlbnRUeXBlLFxuICBqc29uQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAganNvblJlcGxhY2VyLFxuICB0aW1lb3V0OiBkZWZhdWx0VGltZW91dCxcbiAgcmVzcG9uc2VIYW5kbGVyOiBnbG9iYWxSZXNwb25zZUhhbmRsZXIsXG4gIHZhbGlkYXRlU3RhdHVzOiBnbG9iYWxWYWxpZGF0ZVN0YXR1cyxcbiAgLi4uYmFzZUZldGNoT3B0aW9uc1xufSA9IHt9KSB7XG4gIGlmICh0eXBlb2YgZmV0Y2ggPT09IFwidW5kZWZpbmVkXCIgJiYgZmV0Y2hGbiA9PT0gZGVmYXVsdEZldGNoRm4pIHtcbiAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBgZmV0Y2hgIGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBzdXBwbHkgYSBjdXN0b20gYGZldGNoRm5gIHByb3BlcnR5IHRvIHVzZSBgZmV0Y2hCYXNlUXVlcnlgIG9uIFNTUiBlbnZpcm9ubWVudHMuXCIpO1xuICB9XG4gIHJldHVybiBhc3luYyAoYXJnLCBhcGksIGV4dHJhT3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGdldFN0YXRlLFxuICAgICAgZXh0cmEsXG4gICAgICBlbmRwb2ludCxcbiAgICAgIGZvcmNlZCxcbiAgICAgIHR5cGVcbiAgICB9ID0gYXBpO1xuICAgIGxldCBtZXRhO1xuICAgIGxldCB7XG4gICAgICB1cmwsXG4gICAgICBoZWFkZXJzID0gbmV3IEhlYWRlcnMoYmFzZUZldGNoT3B0aW9ucy5oZWFkZXJzKSxcbiAgICAgIHBhcmFtcyA9IHZvaWQgMCxcbiAgICAgIHJlc3BvbnNlSGFuZGxlciA9IGdsb2JhbFJlc3BvbnNlSGFuZGxlciA/PyBcImpzb25cIixcbiAgICAgIHZhbGlkYXRlU3RhdHVzID0gZ2xvYmFsVmFsaWRhdGVTdGF0dXMgPz8gZGVmYXVsdFZhbGlkYXRlU3RhdHVzLFxuICAgICAgdGltZW91dCA9IGRlZmF1bHRUaW1lb3V0LFxuICAgICAgLi4ucmVzdFxuICAgIH0gPSB0eXBlb2YgYXJnID09IFwic3RyaW5nXCIgPyB7XG4gICAgICB1cmw6IGFyZ1xuICAgIH0gOiBhcmc7XG4gICAgbGV0IGFib3J0Q29udHJvbGxlciwgc2lnbmFsID0gYXBpLnNpZ25hbDtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgYXBpLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRDb250cm9sbGVyLmFib3J0KTtcbiAgICAgIHNpZ25hbCA9IGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgfVxuICAgIGxldCBjb25maWcgPSB7XG4gICAgICAuLi5iYXNlRmV0Y2hPcHRpb25zLFxuICAgICAgc2lnbmFsLFxuICAgICAgLi4ucmVzdFxuICAgIH07XG4gICAgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHN0cmlwVW5kZWZpbmVkKGhlYWRlcnMpKTtcbiAgICBjb25maWcuaGVhZGVycyA9IGF3YWl0IHByZXBhcmVIZWFkZXJzKGhlYWRlcnMsIHtcbiAgICAgIGdldFN0YXRlLFxuICAgICAgYXJnLFxuICAgICAgZXh0cmEsXG4gICAgICBlbmRwb2ludCxcbiAgICAgIGZvcmNlZCxcbiAgICAgIHR5cGUsXG4gICAgICBleHRyYU9wdGlvbnNcbiAgICB9KSB8fCBoZWFkZXJzO1xuICAgIGNvbnN0IGlzSnNvbmlmaWFibGUgPSAoYm9keSkgPT4gdHlwZW9mIGJvZHkgPT09IFwib2JqZWN0XCIgJiYgKGlzUGxhaW5PYmplY3QoYm9keSkgfHwgQXJyYXkuaXNBcnJheShib2R5KSB8fCB0eXBlb2YgYm9keS50b0pTT04gPT09IFwiZnVuY3Rpb25cIik7XG4gICAgaWYgKCFjb25maWcuaGVhZGVycy5oYXMoXCJjb250ZW50LXR5cGVcIikgJiYgaXNKc29uaWZpYWJsZShjb25maWcuYm9keSkpIHtcbiAgICAgIGNvbmZpZy5oZWFkZXJzLnNldChcImNvbnRlbnQtdHlwZVwiLCBqc29uQ29udGVudFR5cGUpO1xuICAgIH1cbiAgICBpZiAoaXNKc29uaWZpYWJsZShjb25maWcuYm9keSkgJiYgaXNKc29uQ29udGVudFR5cGUoY29uZmlnLmhlYWRlcnMpKSB7XG4gICAgICBjb25maWcuYm9keSA9IEpTT04uc3RyaW5naWZ5KGNvbmZpZy5ib2R5LCBqc29uUmVwbGFjZXIpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICBjb25zdCBkaXZpZGVyID0gfnVybC5pbmRleE9mKFwiP1wiKSA/IFwiJlwiIDogXCI/XCI7XG4gICAgICBjb25zdCBxdWVyeSA9IHBhcmFtc1NlcmlhbGl6ZXIgPyBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcykgOiBuZXcgVVJMU2VhcmNoUGFyYW1zKHN0cmlwVW5kZWZpbmVkKHBhcmFtcykpO1xuICAgICAgdXJsICs9IGRpdmlkZXIgKyBxdWVyeTtcbiAgICB9XG4gICAgdXJsID0gam9pblVybHMoYmFzZVVybCwgdXJsKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodXJsLCBjb25maWcpO1xuICAgIGNvbnN0IHJlcXVlc3RDbG9uZSA9IG5ldyBSZXF1ZXN0KHVybCwgY29uZmlnKTtcbiAgICBtZXRhID0ge1xuICAgICAgcmVxdWVzdDogcmVxdWVzdENsb25lXG4gICAgfTtcbiAgICBsZXQgcmVzcG9uc2UsIHRpbWVkT3V0ID0gZmFsc2UsIHRpbWVvdXRJZCA9IGFib3J0Q29udHJvbGxlciAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRpbWVkT3V0ID0gdHJ1ZTtcbiAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgIH0sIHRpbWVvdXQpO1xuICAgIHRyeSB7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoRm4ocmVxdWVzdCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICBzdGF0dXM6IHRpbWVkT3V0ID8gXCJUSU1FT1VUX0VSUk9SXCIgOiBcIkZFVENIX0VSUk9SXCIsXG4gICAgICAgICAgZXJyb3I6IFN0cmluZyhlKVxuICAgICAgICB9LFxuICAgICAgICBtZXRhXG4gICAgICB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGltZW91dElkKSBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIGFib3J0Q29udHJvbGxlcj8uc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydENvbnRyb2xsZXIuYWJvcnQpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZUNsb25lID0gcmVzcG9uc2UuY2xvbmUoKTtcbiAgICBtZXRhLnJlc3BvbnNlID0gcmVzcG9uc2VDbG9uZTtcbiAgICBsZXQgcmVzdWx0RGF0YTtcbiAgICBsZXQgcmVzcG9uc2VUZXh0ID0gXCJcIjtcbiAgICB0cnkge1xuICAgICAgbGV0IGhhbmRsZVJlc3BvbnNlRXJyb3I7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlLCByZXNwb25zZUhhbmRsZXIpLnRoZW4oKHIpID0+IHJlc3VsdERhdGEgPSByLCAoZSkgPT4gaGFuZGxlUmVzcG9uc2VFcnJvciA9IGUpLFxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvbm9kZS1mZXRjaC9pc3N1ZXMvNjY1I2lzc3VlY29tbWVudC01Mzg5OTUxODJcbiAgICAgICAgLy8gd2UgKmhhdmUqIHRvIFwidXNlIHVwXCIgYm90aCBzdHJlYW1zIGF0IHRoZSBzYW1lIHRpbWUgb3IgdGhleSB3aWxsIHN0b3AgcnVubmluZyBpbiBub2RlLWZldGNoIHNjZW5hcmlvc1xuICAgICAgICByZXNwb25zZUNsb25lLnRleHQoKS50aGVuKChyKSA9PiByZXNwb25zZVRleHQgPSByLCAoKSA9PiB7XG4gICAgICAgIH0pXG4gICAgICBdKTtcbiAgICAgIGlmIChoYW5kbGVSZXNwb25zZUVycm9yKSB0aHJvdyBoYW5kbGVSZXNwb25zZUVycm9yO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgc3RhdHVzOiBcIlBBUlNJTkdfRVJST1JcIixcbiAgICAgICAgICBvcmlnaW5hbFN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIGRhdGE6IHJlc3BvbnNlVGV4dCxcbiAgICAgICAgICBlcnJvcjogU3RyaW5nKGUpXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZSwgcmVzdWx0RGF0YSkgPyB7XG4gICAgICBkYXRhOiByZXN1bHREYXRhLFxuICAgICAgbWV0YVxuICAgIH0gOiB7XG4gICAgICBlcnJvcjoge1xuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgZGF0YTogcmVzdWx0RGF0YVxuICAgICAgfSxcbiAgICAgIG1ldGFcbiAgICB9O1xuICB9O1xuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVSZXNwb25zZShyZXNwb25zZSwgcmVzcG9uc2VIYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiByZXNwb25zZUhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlSGFuZGxlcihyZXNwb25zZSk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZUhhbmRsZXIgPT09IFwiY29udGVudC10eXBlXCIpIHtcbiAgICAgIHJlc3BvbnNlSGFuZGxlciA9IGlzSnNvbkNvbnRlbnRUeXBlKHJlc3BvbnNlLmhlYWRlcnMpID8gXCJqc29uXCIgOiBcInRleHRcIjtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlSGFuZGxlciA9PT0gXCJqc29uXCIpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICByZXR1cm4gdGV4dC5sZW5ndGggPyBKU09OLnBhcnNlKHRleHQpIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgfVxufVxuXG4vLyBzcmMvcXVlcnkvSGFuZGxlZEVycm9yLnRzXG52YXIgSGFuZGxlZEVycm9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgbWV0YSA9IHZvaWQgMCkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICB9XG59O1xuXG4vLyBzcmMvcXVlcnkvcmV0cnkudHNcbmFzeW5jIGZ1bmN0aW9uIGRlZmF1bHRCYWNrb2ZmKGF0dGVtcHQgPSAwLCBtYXhSZXRyaWVzID0gNSkge1xuICBjb25zdCBhdHRlbXB0cyA9IE1hdGgubWluKGF0dGVtcHQsIG1heFJldHJpZXMpO1xuICBjb25zdCB0aW1lb3V0ID0gfn4oKE1hdGgucmFuZG9tKCkgKyAwLjQpICogKDMwMCA8PCBhdHRlbXB0cykpO1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dCgocmVzKSA9PiByZXNvbHZlKHJlcyksIHRpbWVvdXQpKTtcbn1cbmZ1bmN0aW9uIGZhaWwoZXJyb3IsIG1ldGEpIHtcbiAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgSGFuZGxlZEVycm9yKHtcbiAgICBlcnJvcixcbiAgICBtZXRhXG4gIH0pLCB7XG4gICAgdGhyb3dJbW1lZGlhdGVseTogdHJ1ZVxuICB9KTtcbn1cbnZhciBFTVBUWV9PUFRJT05TID0ge307XG52YXIgcmV0cnlXaXRoQmFja29mZiA9IChiYXNlUXVlcnksIGRlZmF1bHRPcHRpb25zKSA9PiBhc3luYyAoYXJncywgYXBpLCBleHRyYU9wdGlvbnMpID0+IHtcbiAgY29uc3QgcG9zc2libGVNYXhSZXRyaWVzID0gWzUsIChkZWZhdWx0T3B0aW9ucyB8fCBFTVBUWV9PUFRJT05TKS5tYXhSZXRyaWVzLCAoZXh0cmFPcHRpb25zIHx8IEVNUFRZX09QVElPTlMpLm1heFJldHJpZXNdLmZpbHRlcigoeCkgPT4geCAhPT0gdm9pZCAwKTtcbiAgY29uc3QgW21heFJldHJpZXNdID0gcG9zc2libGVNYXhSZXRyaWVzLnNsaWNlKC0xKTtcbiAgY29uc3QgZGVmYXVsdFJldHJ5Q29uZGl0aW9uID0gKF8sIF9fLCB7XG4gICAgYXR0ZW1wdFxuICB9KSA9PiBhdHRlbXB0IDw9IG1heFJldHJpZXM7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgbWF4UmV0cmllcyxcbiAgICBiYWNrb2ZmOiBkZWZhdWx0QmFja29mZixcbiAgICByZXRyeUNvbmRpdGlvbjogZGVmYXVsdFJldHJ5Q29uZGl0aW9uLFxuICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgIC4uLmV4dHJhT3B0aW9uc1xuICB9O1xuICBsZXQgcmV0cnkyID0gMDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYmFzZVF1ZXJ5KGFyZ3MsIGFwaSwgZXh0cmFPcHRpb25zKTtcbiAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEhhbmRsZWRFcnJvcihyZXN1bHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXRyeTIrKztcbiAgICAgIGlmIChlLnRocm93SW1tZWRpYXRlbHkpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBIYW5kbGVkRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBIYW5kbGVkRXJyb3IgJiYgIW9wdGlvbnMucmV0cnlDb25kaXRpb24oZS52YWx1ZS5lcnJvciwgYXJncywge1xuICAgICAgICBhdHRlbXB0OiByZXRyeTIsXG4gICAgICAgIGJhc2VRdWVyeUFwaTogYXBpLFxuICAgICAgICBleHRyYU9wdGlvbnNcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybiBlLnZhbHVlO1xuICAgICAgfVxuICAgICAgYXdhaXQgb3B0aW9ucy5iYWNrb2ZmKHJldHJ5Miwgb3B0aW9ucy5tYXhSZXRyaWVzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgcmV0cnkgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmFzc2lnbihyZXRyeVdpdGhCYWNrb2ZmLCB7XG4gIGZhaWxcbn0pO1xuXG4vLyBzcmMvcXVlcnkvY29yZS9zZXR1cExpc3RlbmVycy50c1xudmFyIG9uRm9jdXMgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQWN0aW9uKFwiX19ydGtxL2ZvY3VzZWRcIik7XG52YXIgb25Gb2N1c0xvc3QgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQWN0aW9uKFwiX19ydGtxL3VuZm9jdXNlZFwiKTtcbnZhciBvbk9ubGluZSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVBY3Rpb24oXCJfX3J0a3Evb25saW5lXCIpO1xudmFyIG9uT2ZmbGluZSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVBY3Rpb24oXCJfX3J0a3Evb2ZmbGluZVwiKTtcbnZhciBpbml0aWFsaXplZCA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0dXBMaXN0ZW5lcnMoZGlzcGF0Y2gsIGN1c3RvbUhhbmRsZXIpIHtcbiAgZnVuY3Rpb24gZGVmYXVsdEhhbmRsZXIoKSB7XG4gICAgY29uc3QgaGFuZGxlRm9jdXMgPSAoKSA9PiBkaXNwYXRjaChvbkZvY3VzKCkpO1xuICAgIGNvbnN0IGhhbmRsZUZvY3VzTG9zdCA9ICgpID0+IGRpc3BhdGNoKG9uRm9jdXNMb3N0KCkpO1xuICAgIGNvbnN0IGhhbmRsZU9ubGluZSA9ICgpID0+IGRpc3BhdGNoKG9uT25saW5lKCkpO1xuICAgIGNvbnN0IGhhbmRsZU9mZmxpbmUgPSAoKSA9PiBkaXNwYXRjaChvbk9mZmxpbmUoKSk7XG4gICAgY29uc3QgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGlmICh3aW5kb3cuZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSBcInZpc2libGVcIikge1xuICAgICAgICBoYW5kbGVGb2N1cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlRm9jdXNMb3N0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoIWluaXRpYWxpemVkKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSwgZmFsc2UpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGhhbmRsZUZvY3VzLCBmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsIGhhbmRsZU9ubGluZSwgZmFsc2UpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgaGFuZGxlT2ZmbGluZSwgZmFsc2UpO1xuICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBoYW5kbGVGb2N1cyk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBoYW5kbGVPbmxpbmUpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIGhhbmRsZU9mZmxpbmUpO1xuICAgICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgfVxuICByZXR1cm4gY3VzdG9tSGFuZGxlciA/IGN1c3RvbUhhbmRsZXIoZGlzcGF0Y2gsIHtcbiAgICBvbkZvY3VzLFxuICAgIG9uRm9jdXNMb3N0LFxuICAgIG9uT2ZmbGluZSxcbiAgICBvbk9ubGluZVxuICB9KSA6IGRlZmF1bHRIYW5kbGVyKCk7XG59XG5cbi8vIHNyYy9xdWVyeS9lbmRwb2ludERlZmluaXRpb25zLnRzXG5mdW5jdGlvbiBpc1F1ZXJ5RGVmaW5pdGlvbihlKSB7XG4gIHJldHVybiBlLnR5cGUgPT09IFwicXVlcnlcIiAvKiBxdWVyeSAqLztcbn1cbmZ1bmN0aW9uIGlzTXV0YXRpb25EZWZpbml0aW9uKGUpIHtcbiAgcmV0dXJuIGUudHlwZSA9PT0gXCJtdXRhdGlvblwiIC8qIG11dGF0aW9uICovO1xufVxuZnVuY3Rpb24gaXNJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbihlKSB7XG4gIHJldHVybiBlLnR5cGUgPT09IFwiaW5maW5pdGVxdWVyeVwiIC8qIGluZmluaXRlcXVlcnkgKi87XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVQcm92aWRlZEJ5KGRlc2NyaXB0aW9uLCByZXN1bHQsIGVycm9yLCBxdWVyeUFyZywgbWV0YSwgYXNzZXJ0VGFnVHlwZXMpIHtcbiAgaWYgKGlzRnVuY3Rpb24oZGVzY3JpcHRpb24pKSB7XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uKHJlc3VsdCwgZXJyb3IsIHF1ZXJ5QXJnLCBtZXRhKS5maWx0ZXIoaXNOb3ROdWxsaXNoKS5tYXAoZXhwYW5kVGFnRGVzY3JpcHRpb24pLm1hcChhc3NlcnRUYWdUeXBlcyk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGVzY3JpcHRpb24pKSB7XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uLm1hcChleHBhbmRUYWdEZXNjcmlwdGlvbikubWFwKGFzc2VydFRhZ1R5cGVzKTtcbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHR5cGVvZiB0ID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBleHBhbmRUYWdEZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xuICByZXR1cm4gdHlwZW9mIGRlc2NyaXB0aW9uID09PSBcInN0cmluZ1wiID8ge1xuICAgIHR5cGU6IGRlc2NyaXB0aW9uXG4gIH0gOiBkZXNjcmlwdGlvbjtcbn1cblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRUaHVua3MudHNcbmltcG9ydCB7IGlzRHJhZnRhYmxlLCBwcm9kdWNlV2l0aFBhdGNoZXMgfSBmcm9tIFwiaW1tZXJcIjtcblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRJbml0aWF0ZS50c1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5cbi8vIHNyYy90c0hlbHBlcnMudHNcbmZ1bmN0aW9uIGFzU2FmZVByb21pc2UocHJvbWlzZSwgZmFsbGJhY2spIHtcbiAgcmV0dXJuIHByb21pc2UuY2F0Y2goZmFsbGJhY2spO1xufVxuXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZEluaXRpYXRlLnRzXG52YXIgZm9yY2VRdWVyeUZuU3ltYm9sID0gU3ltYm9sKFwiZm9yY2VRdWVyeUZuXCIpO1xudmFyIGlzVXBzZXJ0UXVlcnkgPSAoYXJnKSA9PiB0eXBlb2YgYXJnW2ZvcmNlUXVlcnlGblN5bWJvbF0gPT09IFwiZnVuY3Rpb25cIjtcbmZ1bmN0aW9uIGJ1aWxkSW5pdGlhdGUoe1xuICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gIHF1ZXJ5VGh1bmssXG4gIGluZmluaXRlUXVlcnlUaHVuayxcbiAgbXV0YXRpb25UaHVuayxcbiAgYXBpLFxuICBjb250ZXh0XG59KSB7XG4gIGNvbnN0IHJ1bm5pbmdRdWVyaWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgcnVubmluZ011dGF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHtcbiAgICB1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0LFxuICAgIHJlbW92ZU11dGF0aW9uUmVzdWx0LFxuICAgIHVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnNcbiAgfSA9IGFwaS5pbnRlcm5hbEFjdGlvbnM7XG4gIHJldHVybiB7XG4gICAgYnVpbGRJbml0aWF0ZVF1ZXJ5LFxuICAgIGJ1aWxkSW5pdGlhdGVJbmZpbml0ZVF1ZXJ5LFxuICAgIGJ1aWxkSW5pdGlhdGVNdXRhdGlvbixcbiAgICBnZXRSdW5uaW5nUXVlcnlUaHVuayxcbiAgICBnZXRSdW5uaW5nTXV0YXRpb25UaHVuayxcbiAgICBnZXRSdW5uaW5nUXVlcmllc1RodW5rLFxuICAgIGdldFJ1bm5pbmdNdXRhdGlvbnNUaHVua1xuICB9O1xuICBmdW5jdGlvbiBnZXRSdW5uaW5nUXVlcnlUaHVuayhlbmRwb2ludE5hbWUsIHF1ZXJ5QXJncykge1xuICAgIHJldHVybiAoZGlzcGF0Y2gpID0+IHtcbiAgICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdO1xuICAgICAgY29uc3QgcXVlcnlDYWNoZUtleSA9IHNlcmlhbGl6ZVF1ZXJ5QXJncyh7XG4gICAgICAgIHF1ZXJ5QXJncyxcbiAgICAgICAgZW5kcG9pbnREZWZpbml0aW9uLFxuICAgICAgICBlbmRwb2ludE5hbWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJ1bm5pbmdRdWVyaWVzLmdldChkaXNwYXRjaCk/LltxdWVyeUNhY2hlS2V5XTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGdldFJ1bm5pbmdNdXRhdGlvblRodW5rKF9lbmRwb2ludE5hbWUsIGZpeGVkQ2FjaGVLZXlPclJlcXVlc3RJZCkge1xuICAgIHJldHVybiAoZGlzcGF0Y2gpID0+IHtcbiAgICAgIHJldHVybiBydW5uaW5nTXV0YXRpb25zLmdldChkaXNwYXRjaCk/LltmaXhlZENhY2hlS2V5T3JSZXF1ZXN0SWRdO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UnVubmluZ1F1ZXJpZXNUaHVuaygpIHtcbiAgICByZXR1cm4gKGRpc3BhdGNoKSA9PiBPYmplY3QudmFsdWVzKHJ1bm5pbmdRdWVyaWVzLmdldChkaXNwYXRjaCkgfHwge30pLmZpbHRlcihpc05vdE51bGxpc2gpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFJ1bm5pbmdNdXRhdGlvbnNUaHVuaygpIHtcbiAgICByZXR1cm4gKGRpc3BhdGNoKSA9PiBPYmplY3QudmFsdWVzKHJ1bm5pbmdNdXRhdGlvbnMuZ2V0KGRpc3BhdGNoKSB8fCB7fSkuZmlsdGVyKGlzTm90TnVsbGlzaCk7XG4gIH1cbiAgZnVuY3Rpb24gbWlkZGxld2FyZVdhcm5pbmcoZGlzcGF0Y2gpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAobWlkZGxld2FyZVdhcm5pbmcudHJpZ2dlcmVkKSByZXR1cm47XG4gICAgICBjb25zdCByZXR1cm5lZFZhbHVlID0gZGlzcGF0Y2goYXBpLmludGVybmFsQWN0aW9ucy5pbnRlcm5hbF9nZXRSVEtRU3Vic2NyaXB0aW9ucygpKTtcbiAgICAgIG1pZGRsZXdhcmVXYXJuaW5nLnRyaWdnZXJlZCA9IHRydWU7XG4gICAgICBpZiAodHlwZW9mIHJldHVybmVkVmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHJldHVybmVkVmFsdWU/LnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDM0KSA6IGBXYXJuaW5nOiBNaWRkbGV3YXJlIGZvciBSVEstUXVlcnkgQVBJIGF0IHJlZHVjZXJQYXRoIFwiJHthcGkucmVkdWNlclBhdGh9XCIgaGFzIG5vdCBiZWVuIGFkZGVkIHRvIHRoZSBzdG9yZS5cbllvdSBtdXN0IGFkZCB0aGUgbWlkZGxld2FyZSBmb3IgUlRLLVF1ZXJ5IHRvIGZ1bmN0aW9uIGNvcnJlY3RseSFgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRJbml0aWF0ZUFueVF1ZXJ5KGVuZHBvaW50TmFtZSwgZW5kcG9pbnREZWZpbml0aW9uKSB7XG4gICAgY29uc3QgcXVlcnlBY3Rpb24gPSAoYXJnLCB7XG4gICAgICBzdWJzY3JpYmUgPSB0cnVlLFxuICAgICAgZm9yY2VSZWZldGNoLFxuICAgICAgc3Vic2NyaXB0aW9uT3B0aW9ucyxcbiAgICAgIFtmb3JjZVF1ZXJ5Rm5TeW1ib2xdOiBmb3JjZVF1ZXJ5Rm4sXG4gICAgICAuLi5yZXN0XG4gICAgfSA9IHt9KSA9PiAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBxdWVyeUNhY2hlS2V5ID0gc2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgICAgcXVlcnlBcmdzOiBhcmcsXG4gICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbixcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9KTtcbiAgICAgIGxldCB0aHVuaztcbiAgICAgIGNvbnN0IGNvbW1vblRodW5rQXJncyA9IHtcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgdHlwZTogXCJxdWVyeVwiLFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGZvcmNlUmVmZXRjaCxcbiAgICAgICAgc3Vic2NyaXB0aW9uT3B0aW9ucyxcbiAgICAgICAgZW5kcG9pbnROYW1lLFxuICAgICAgICBvcmlnaW5hbEFyZ3M6IGFyZyxcbiAgICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgICAgW2ZvcmNlUXVlcnlGblN5bWJvbF06IGZvcmNlUXVlcnlGblxuICAgICAgfTtcbiAgICAgIGlmIChpc1F1ZXJ5RGVmaW5pdGlvbihlbmRwb2ludERlZmluaXRpb24pKSB7XG4gICAgICAgIHRodW5rID0gcXVlcnlUaHVuayhjb21tb25UaHVua0FyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgICBpbml0aWFsUGFnZVBhcmFtXG4gICAgICAgIH0gPSByZXN0O1xuICAgICAgICB0aHVuayA9IGluZmluaXRlUXVlcnlUaHVuayh7XG4gICAgICAgICAgLi4uY29tbW9uVGh1bmtBcmdzLFxuICAgICAgICAgIC8vIFN1cHBseSB0aGVzZSBldmVuIGlmIHVuZGVmaW5lZC4gVGhpcyBoZWxwcyB3aXRoIGEgZmllbGQgZXhpc3RlbmNlXG4gICAgICAgICAgLy8gY2hlY2sgb3ZlciBpbiBgYnVpbGRTbGljZS50c2BcbiAgICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgICAgaW5pdGlhbFBhZ2VQYXJhbVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlbGVjdG9yID0gYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdLnNlbGVjdChhcmcpO1xuICAgICAgY29uc3QgdGh1bmtSZXN1bHQgPSBkaXNwYXRjaCh0aHVuayk7XG4gICAgICBjb25zdCBzdGF0ZUFmdGVyID0gc2VsZWN0b3IoZ2V0U3RhdGUoKSk7XG4gICAgICBtaWRkbGV3YXJlV2FybmluZyhkaXNwYXRjaCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgYWJvcnRcbiAgICAgIH0gPSB0aHVua1Jlc3VsdDtcbiAgICAgIGNvbnN0IHNraXBwZWRTeW5jaHJvbm91c2x5ID0gc3RhdGVBZnRlci5yZXF1ZXN0SWQgIT09IHJlcXVlc3RJZDtcbiAgICAgIGNvbnN0IHJ1bm5pbmdRdWVyeSA9IHJ1bm5pbmdRdWVyaWVzLmdldChkaXNwYXRjaCk/LltxdWVyeUNhY2hlS2V5XTtcbiAgICAgIGNvbnN0IHNlbGVjdEZyb21TdGF0ZSA9ICgpID0+IHNlbGVjdG9yKGdldFN0YXRlKCkpO1xuICAgICAgY29uc3Qgc3RhdGVQcm9taXNlID0gT2JqZWN0LmFzc2lnbihmb3JjZVF1ZXJ5Rm4gPyAoXG4gICAgICAgIC8vIGEgcXVlcnkgaGFzIGJlZW4gZm9yY2VkICh1cHNlcnRRdWVyeURhdGEpXG4gICAgICAgIC8vIC0+IHdlIHdhbnQgdG8gcmVzb2x2ZSBpdCBvbmNlIGRhdGEgaGFzIGJlZW4gd3JpdHRlbiB3aXRoIHRoZSBkYXRhIHRoYXQgd2lsbCBiZSB3cml0dGVuXG4gICAgICAgIHRodW5rUmVzdWx0LnRoZW4oc2VsZWN0RnJvbVN0YXRlKVxuICAgICAgKSA6IHNraXBwZWRTeW5jaHJvbm91c2x5ICYmICFydW5uaW5nUXVlcnkgPyAoXG4gICAgICAgIC8vIGEgcXVlcnkgaGFzIGJlZW4gc2tpcHBlZCBkdWUgdG8gYSBjb25kaXRpb24gYW5kIHdlIGRvIG5vdCBoYXZlIGFueSBjdXJyZW50bHkgcnVubmluZyBxdWVyeVxuICAgICAgICAvLyAtPiB3ZSB3YW50IHRvIHJlc29sdmUgaXQgaW1tZWRpYXRlbHkgd2l0aCB0aGUgY3VycmVudCBkYXRhXG4gICAgICAgIFByb21pc2UucmVzb2x2ZShzdGF0ZUFmdGVyKVxuICAgICAgKSA6IChcbiAgICAgICAgLy8gcXVlcnkganVzdCBzdGFydGVkIG9yIG9uZSBpcyBhbHJlYWR5IGluIGZsaWdodFxuICAgICAgICAvLyAtPiB3YWl0IGZvciB0aGUgcnVubmluZyBxdWVyeSwgdGhlbiByZXNvbHZlIHdpdGggZGF0YSBmcm9tIGFmdGVyIHRoYXRcbiAgICAgICAgUHJvbWlzZS5hbGwoW3J1bm5pbmdRdWVyeSwgdGh1bmtSZXN1bHRdKS50aGVuKHNlbGVjdEZyb21TdGF0ZSlcbiAgICAgICksIHtcbiAgICAgICAgYXJnLFxuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHN1YnNjcmlwdGlvbk9wdGlvbnMsXG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgIGFib3J0LFxuICAgICAgICBhc3luYyB1bndyYXAoKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RhdGVQcm9taXNlO1xuICAgICAgICAgIGlmIChyZXN1bHQuaXNFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZmV0Y2g6ICgpID0+IGRpc3BhdGNoKHF1ZXJ5QWN0aW9uKGFyZywge1xuICAgICAgICAgIHN1YnNjcmliZTogZmFsc2UsXG4gICAgICAgICAgZm9yY2VSZWZldGNoOiB0cnVlXG4gICAgICAgIH0pKSxcbiAgICAgICAgdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgICAgaWYgKHN1YnNjcmliZSkgZGlzcGF0Y2godW5zdWJzY3JpYmVRdWVyeVJlc3VsdCh7XG4gICAgICAgICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgICBzdGF0ZVByb21pc2Uuc3Vic2NyaXB0aW9uT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgZGlzcGF0Y2godXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9ucyh7XG4gICAgICAgICAgICBlbmRwb2ludE5hbWUsXG4gICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJ1bm5pbmdRdWVyeSAmJiAhc2tpcHBlZFN5bmNocm9ub3VzbHkgJiYgIWZvcmNlUXVlcnlGbikge1xuICAgICAgICBjb25zdCBydW5uaW5nID0gZ2V0T3JJbnNlcnQocnVubmluZ1F1ZXJpZXMsIGRpc3BhdGNoLCB7fSk7XG4gICAgICAgIHJ1bm5pbmdbcXVlcnlDYWNoZUtleV0gPSBzdGF0ZVByb21pc2U7XG4gICAgICAgIHN0YXRlUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICBkZWxldGUgcnVubmluZ1txdWVyeUNhY2hlS2V5XTtcbiAgICAgICAgICBpZiAoIWNvdW50T2JqZWN0S2V5cyhydW5uaW5nKSkge1xuICAgICAgICAgICAgcnVubmluZ1F1ZXJpZXMuZGVsZXRlKGRpc3BhdGNoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXRlUHJvbWlzZTtcbiAgICB9O1xuICAgIHJldHVybiBxdWVyeUFjdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBidWlsZEluaXRpYXRlUXVlcnkoZW5kcG9pbnROYW1lLCBlbmRwb2ludERlZmluaXRpb24pIHtcbiAgICBjb25zdCBxdWVyeUFjdGlvbiA9IGJ1aWxkSW5pdGlhdGVBbnlRdWVyeShlbmRwb2ludE5hbWUsIGVuZHBvaW50RGVmaW5pdGlvbik7XG4gICAgcmV0dXJuIHF1ZXJ5QWN0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkSW5pdGlhdGVJbmZpbml0ZVF1ZXJ5KGVuZHBvaW50TmFtZSwgZW5kcG9pbnREZWZpbml0aW9uKSB7XG4gICAgY29uc3QgaW5maW5pdGVRdWVyeUFjdGlvbiA9IGJ1aWxkSW5pdGlhdGVBbnlRdWVyeShlbmRwb2ludE5hbWUsIGVuZHBvaW50RGVmaW5pdGlvbik7XG4gICAgcmV0dXJuIGluZmluaXRlUXVlcnlBY3Rpb247XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRJbml0aWF0ZU11dGF0aW9uKGVuZHBvaW50TmFtZSkge1xuICAgIHJldHVybiAoYXJnLCB7XG4gICAgICB0cmFjayA9IHRydWUsXG4gICAgICBmaXhlZENhY2hlS2V5XG4gICAgfSA9IHt9KSA9PiAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XG4gICAgICBjb25zdCB0aHVuayA9IG11dGF0aW9uVGh1bmsoe1xuICAgICAgICB0eXBlOiBcIm11dGF0aW9uXCIsXG4gICAgICAgIGVuZHBvaW50TmFtZSxcbiAgICAgICAgb3JpZ2luYWxBcmdzOiBhcmcsXG4gICAgICAgIHRyYWNrLFxuICAgICAgICBmaXhlZENhY2hlS2V5XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHRodW5rUmVzdWx0ID0gZGlzcGF0Y2godGh1bmspO1xuICAgICAgbWlkZGxld2FyZVdhcm5pbmcoZGlzcGF0Y2gpO1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIGFib3J0LFxuICAgICAgICB1bndyYXBcbiAgICAgIH0gPSB0aHVua1Jlc3VsdDtcbiAgICAgIGNvbnN0IHJldHVyblZhbHVlUHJvbWlzZSA9IGFzU2FmZVByb21pc2UodGh1bmtSZXN1bHQudW53cmFwKCkudGhlbigoZGF0YSkgPT4gKHtcbiAgICAgICAgZGF0YVxuICAgICAgfSkpLCAoZXJyb3IpID0+ICh7XG4gICAgICAgIGVycm9yXG4gICAgICB9KSk7XG4gICAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgICAgZGlzcGF0Y2gocmVtb3ZlTXV0YXRpb25SZXN1bHQoe1xuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICBmaXhlZENhY2hlS2V5XG4gICAgICAgIH0pKTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXQgPSBPYmplY3QuYXNzaWduKHJldHVyblZhbHVlUHJvbWlzZSwge1xuICAgICAgICBhcmc6IHRodW5rUmVzdWx0LmFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICBhYm9ydCxcbiAgICAgICAgdW53cmFwLFxuICAgICAgICByZXNldFxuICAgICAgfSk7XG4gICAgICBjb25zdCBydW5uaW5nID0gcnVubmluZ011dGF0aW9ucy5nZXQoZGlzcGF0Y2gpIHx8IHt9O1xuICAgICAgcnVubmluZ011dGF0aW9ucy5zZXQoZGlzcGF0Y2gsIHJ1bm5pbmcpO1xuICAgICAgcnVubmluZ1tyZXF1ZXN0SWRdID0gcmV0O1xuICAgICAgcmV0LnRoZW4oKCkgPT4ge1xuICAgICAgICBkZWxldGUgcnVubmluZ1tyZXF1ZXN0SWRdO1xuICAgICAgICBpZiAoIWNvdW50T2JqZWN0S2V5cyhydW5uaW5nKSkge1xuICAgICAgICAgIHJ1bm5pbmdNdXRhdGlvbnMuZGVsZXRlKGRpc3BhdGNoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZml4ZWRDYWNoZUtleSkge1xuICAgICAgICBydW5uaW5nW2ZpeGVkQ2FjaGVLZXldID0gcmV0O1xuICAgICAgICByZXQudGhlbigoKSA9PiB7XG4gICAgICAgICAgaWYgKHJ1bm5pbmdbZml4ZWRDYWNoZUtleV0gPT09IHJldCkge1xuICAgICAgICAgICAgZGVsZXRlIHJ1bm5pbmdbZml4ZWRDYWNoZUtleV07XG4gICAgICAgICAgICBpZiAoIWNvdW50T2JqZWN0S2V5cyhydW5uaW5nKSkge1xuICAgICAgICAgICAgICBydW5uaW5nTXV0YXRpb25zLmRlbGV0ZShkaXNwYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZFRodW5rcy50c1xuZnVuY3Rpb24gZGVmYXVsdFRyYW5zZm9ybVJlc3BvbnNlKGJhc2VRdWVyeVJldHVyblZhbHVlKSB7XG4gIHJldHVybiBiYXNlUXVlcnlSZXR1cm5WYWx1ZTtcbn1cbnZhciBhZGRTaG91bGRBdXRvQmF0Y2ggPSAoYXJnID0ge30pID0+IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5hcmcsXG4gICAgW1NIT1VMRF9BVVRPQkFUQ0hdOiB0cnVlXG4gIH07XG59O1xuZnVuY3Rpb24gYnVpbGRUaHVua3Moe1xuICByZWR1Y2VyUGF0aCxcbiAgYmFzZVF1ZXJ5LFxuICBjb250ZXh0OiB7XG4gICAgZW5kcG9pbnREZWZpbml0aW9uc1xuICB9LFxuICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gIGFwaSxcbiAgYXNzZXJ0VGFnVHlwZSxcbiAgc2VsZWN0b3JzXG59KSB7XG4gIGNvbnN0IHBhdGNoUXVlcnlEYXRhID0gKGVuZHBvaW50TmFtZSwgYXJnLCBwYXRjaGVzLCB1cGRhdGVQcm92aWRlZCkgPT4gKGRpc3BhdGNoLCBnZXRTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXTtcbiAgICBjb25zdCBxdWVyeUNhY2hlS2V5ID0gc2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgIHF1ZXJ5QXJnczogYXJnLFxuICAgICAgZW5kcG9pbnREZWZpbml0aW9uLFxuICAgICAgZW5kcG9pbnROYW1lXG4gICAgfSk7XG4gICAgZGlzcGF0Y2goYXBpLmludGVybmFsQWN0aW9ucy5xdWVyeVJlc3VsdFBhdGNoZWQoe1xuICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgIHBhdGNoZXNcbiAgICB9KSk7XG4gICAgaWYgKCF1cGRhdGVQcm92aWRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXdWYWx1ZSA9IGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXS5zZWxlY3QoYXJnKShcbiAgICAgIC8vIFdvcmsgYXJvdW5kIFRTIDQuMSBtaXNtYXRjaFxuICAgICAgZ2V0U3RhdGUoKVxuICAgICk7XG4gICAgY29uc3QgcHJvdmlkZWRUYWdzID0gY2FsY3VsYXRlUHJvdmlkZWRCeShlbmRwb2ludERlZmluaXRpb24ucHJvdmlkZXNUYWdzLCBuZXdWYWx1ZS5kYXRhLCB2b2lkIDAsIGFyZywge30sIGFzc2VydFRhZ1R5cGUpO1xuICAgIGRpc3BhdGNoKGFwaS5pbnRlcm5hbEFjdGlvbnMudXBkYXRlUHJvdmlkZWRCeSh7XG4gICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgcHJvdmlkZWRUYWdzXG4gICAgfSkpO1xuICB9O1xuICBmdW5jdGlvbiBhZGRUb1N0YXJ0KGl0ZW1zLCBpdGVtLCBtYXggPSAwKSB7XG4gICAgY29uc3QgbmV3SXRlbXMgPSBbaXRlbSwgLi4uaXRlbXNdO1xuICAgIHJldHVybiBtYXggJiYgbmV3SXRlbXMubGVuZ3RoID4gbWF4ID8gbmV3SXRlbXMuc2xpY2UoMCwgLTEpIDogbmV3SXRlbXM7XG4gIH1cbiAgZnVuY3Rpb24gYWRkVG9FbmQoaXRlbXMsIGl0ZW0sIG1heCA9IDApIHtcbiAgICBjb25zdCBuZXdJdGVtcyA9IFsuLi5pdGVtcywgaXRlbV07XG4gICAgcmV0dXJuIG1heCAmJiBuZXdJdGVtcy5sZW5ndGggPiBtYXggPyBuZXdJdGVtcy5zbGljZSgxKSA6IG5ld0l0ZW1zO1xuICB9XG4gIGNvbnN0IHVwZGF0ZVF1ZXJ5RGF0YSA9IChlbmRwb2ludE5hbWUsIGFyZywgdXBkYXRlUmVjaXBlLCB1cGRhdGVQcm92aWRlZCA9IHRydWUpID0+IChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgICBjb25zdCBlbmRwb2ludERlZmluaXRpb24gPSBhcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV07XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gZW5kcG9pbnREZWZpbml0aW9uLnNlbGVjdChhcmcpKFxuICAgICAgLy8gV29yayBhcm91bmQgVFMgNC4xIG1pc21hdGNoXG4gICAgICBnZXRTdGF0ZSgpXG4gICAgKTtcbiAgICBjb25zdCByZXQgPSB7XG4gICAgICBwYXRjaGVzOiBbXSxcbiAgICAgIGludmVyc2VQYXRjaGVzOiBbXSxcbiAgICAgIHVuZG86ICgpID0+IGRpc3BhdGNoKGFwaS51dGlsLnBhdGNoUXVlcnlEYXRhKGVuZHBvaW50TmFtZSwgYXJnLCByZXQuaW52ZXJzZVBhdGNoZXMsIHVwZGF0ZVByb3ZpZGVkKSlcbiAgICB9O1xuICAgIGlmIChjdXJyZW50U3RhdGUuc3RhdHVzID09PSBcInVuaW5pdGlhbGl6ZWRcIiAvKiB1bmluaXRpYWxpemVkICovKSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBsZXQgbmV3VmFsdWU7XG4gICAgaWYgKFwiZGF0YVwiIGluIGN1cnJlbnRTdGF0ZSkge1xuICAgICAgaWYgKGlzRHJhZnRhYmxlKGN1cnJlbnRTdGF0ZS5kYXRhKSkge1xuICAgICAgICBjb25zdCBbdmFsdWUsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzXSA9IHByb2R1Y2VXaXRoUGF0Y2hlcyhjdXJyZW50U3RhdGUuZGF0YSwgdXBkYXRlUmVjaXBlKTtcbiAgICAgICAgcmV0LnBhdGNoZXMucHVzaCguLi5wYXRjaGVzKTtcbiAgICAgICAgcmV0LmludmVyc2VQYXRjaGVzLnB1c2goLi4uaW52ZXJzZVBhdGNoZXMpO1xuICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSB1cGRhdGVSZWNpcGUoY3VycmVudFN0YXRlLmRhdGEpO1xuICAgICAgICByZXQucGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgcGF0aDogW10sXG4gICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXQuaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgb3A6IFwicmVwbGFjZVwiLFxuICAgICAgICAgIHBhdGg6IFtdLFxuICAgICAgICAgIHZhbHVlOiBjdXJyZW50U3RhdGUuZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJldC5wYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZGlzcGF0Y2goYXBpLnV0aWwucGF0Y2hRdWVyeURhdGEoZW5kcG9pbnROYW1lLCBhcmcsIHJldC5wYXRjaGVzLCB1cGRhdGVQcm92aWRlZCkpO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG4gIGNvbnN0IHVwc2VydFF1ZXJ5RGF0YSA9IChlbmRwb2ludE5hbWUsIGFyZywgdmFsdWUpID0+IChkaXNwYXRjaCkgPT4ge1xuICAgIGNvbnN0IHJlcyA9IGRpc3BhdGNoKGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXS5pbml0aWF0ZShhcmcsIHtcbiAgICAgIHN1YnNjcmliZTogZmFsc2UsXG4gICAgICBmb3JjZVJlZmV0Y2g6IHRydWUsXG4gICAgICBbZm9yY2VRdWVyeUZuU3ltYm9sXTogKCkgPT4gKHtcbiAgICAgICAgZGF0YTogdmFsdWVcbiAgICAgIH0pXG4gICAgfSkpO1xuICAgIHJldHVybiByZXM7XG4gIH07XG4gIGNvbnN0IGdldFRyYW5zZm9ybUNhbGxiYWNrRm9yRW5kcG9pbnQgPSAoZW5kcG9pbnREZWZpbml0aW9uLCB0cmFuc2Zvcm1GaWVsZE5hbWUpID0+IHtcbiAgICByZXR1cm4gZW5kcG9pbnREZWZpbml0aW9uLnF1ZXJ5ICYmIGVuZHBvaW50RGVmaW5pdGlvblt0cmFuc2Zvcm1GaWVsZE5hbWVdID8gZW5kcG9pbnREZWZpbml0aW9uW3RyYW5zZm9ybUZpZWxkTmFtZV0gOiBkZWZhdWx0VHJhbnNmb3JtUmVzcG9uc2U7XG4gIH07XG4gIGNvbnN0IGV4ZWN1dGVFbmRwb2ludCA9IGFzeW5jIChhcmcsIHtcbiAgICBzaWduYWwsXG4gICAgYWJvcnQsXG4gICAgcmVqZWN0V2l0aFZhbHVlLFxuICAgIGZ1bGZpbGxXaXRoVmFsdWUsXG4gICAgZGlzcGF0Y2gsXG4gICAgZ2V0U3RhdGUsXG4gICAgZXh0cmFcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGVuZHBvaW50RGVmaW5pdGlvbnNbYXJnLmVuZHBvaW50TmFtZV07XG4gICAgdHJ5IHtcbiAgICAgIGxldCB0cmFuc2Zvcm1SZXNwb25zZSA9IGdldFRyYW5zZm9ybUNhbGxiYWNrRm9yRW5kcG9pbnQoZW5kcG9pbnREZWZpbml0aW9uLCBcInRyYW5zZm9ybVJlc3BvbnNlXCIpO1xuICAgICAgY29uc3QgYmFzZVF1ZXJ5QXBpID0ge1xuICAgICAgICBzaWduYWwsXG4gICAgICAgIGFib3J0LFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgZ2V0U3RhdGUsXG4gICAgICAgIGV4dHJhLFxuICAgICAgICBlbmRwb2ludDogYXJnLmVuZHBvaW50TmFtZSxcbiAgICAgICAgdHlwZTogYXJnLnR5cGUsXG4gICAgICAgIGZvcmNlZDogYXJnLnR5cGUgPT09IFwicXVlcnlcIiA/IGlzRm9yY2VkUXVlcnkoYXJnLCBnZXRTdGF0ZSgpKSA6IHZvaWQgMCxcbiAgICAgICAgcXVlcnlDYWNoZUtleTogYXJnLnR5cGUgPT09IFwicXVlcnlcIiA/IGFyZy5xdWVyeUNhY2hlS2V5IDogdm9pZCAwXG4gICAgICB9O1xuICAgICAgY29uc3QgZm9yY2VRdWVyeUZuID0gYXJnLnR5cGUgPT09IFwicXVlcnlcIiA/IGFyZ1tmb3JjZVF1ZXJ5Rm5TeW1ib2xdIDogdm9pZCAwO1xuICAgICAgbGV0IGZpbmFsUXVlcnlSZXR1cm5WYWx1ZTtcbiAgICAgIGNvbnN0IGZldGNoUGFnZSA9IGFzeW5jIChkYXRhLCBwYXJhbSwgbWF4UGFnZXMsIHByZXZpb3VzKSA9PiB7XG4gICAgICAgIGlmIChwYXJhbSA9PSBudWxsICYmIGRhdGEucGFnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICBkYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmluYWxRdWVyeUFyZyA9IHtcbiAgICAgICAgICBxdWVyeUFyZzogYXJnLm9yaWdpbmFsQXJncyxcbiAgICAgICAgICBwYWdlUGFyYW06IHBhcmFtXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBhZ2VSZXNwb25zZSA9IGF3YWl0IGV4ZWN1dGVSZXF1ZXN0KGZpbmFsUXVlcnlBcmcpO1xuICAgICAgICBjb25zdCBhZGRUbyA9IHByZXZpb3VzID8gYWRkVG9TdGFydCA6IGFkZFRvRW5kO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHBhZ2VzOiBhZGRUbyhkYXRhLnBhZ2VzLCBwYWdlUmVzcG9uc2UuZGF0YSwgbWF4UGFnZXMpLFxuICAgICAgICAgICAgcGFnZVBhcmFtczogYWRkVG8oZGF0YS5wYWdlUGFyYW1zLCBwYXJhbSwgbWF4UGFnZXMpXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVSZXF1ZXN0KGZpbmFsUXVlcnlBcmcpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGV4dHJhT3B0aW9uc1xuICAgICAgICB9ID0gZW5kcG9pbnREZWZpbml0aW9uO1xuICAgICAgICBpZiAoZm9yY2VRdWVyeUZuKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZm9yY2VRdWVyeUZuKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZW5kcG9pbnREZWZpbml0aW9uLnF1ZXJ5KSB7XG4gICAgICAgICAgcmVzdWx0ID0gYXdhaXQgYmFzZVF1ZXJ5KGVuZHBvaW50RGVmaW5pdGlvbi5xdWVyeShmaW5hbFF1ZXJ5QXJnKSwgYmFzZVF1ZXJ5QXBpLCBleHRyYU9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IGVuZHBvaW50RGVmaW5pdGlvbi5xdWVyeUZuKGZpbmFsUXVlcnlBcmcsIGJhc2VRdWVyeUFwaSwgZXh0cmFPcHRpb25zLCAoYXJnMikgPT4gYmFzZVF1ZXJ5KGFyZzIsIGJhc2VRdWVyeUFwaSwgZXh0cmFPcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgICBjb25zdCB3aGF0ID0gZW5kcG9pbnREZWZpbml0aW9uLnF1ZXJ5ID8gXCJgYmFzZVF1ZXJ5YFwiIDogXCJgcXVlcnlGbmBcIjtcbiAgICAgICAgICBsZXQgZXJyO1xuICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICBlcnIgPSBgJHt3aGF0fSBkaWQgbm90IHJldHVybiBhbnl0aGluZy5gO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgZXJyID0gYCR7d2hhdH0gZGlkIG5vdCByZXR1cm4gYW4gb2JqZWN0LmA7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuZXJyb3IgJiYgcmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgIGVyciA9IGAke3doYXR9IHJldHVybmVkIGFuIG9iamVjdCBjb250YWluaW5nIGJvdGggXFxgZXJyb3JcXGAgYW5kIFxcYHJlc3VsdFxcYC5gO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmVycm9yID09PSB2b2lkIDAgJiYgcmVzdWx0LmRhdGEgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZXJyID0gYCR7d2hhdH0gcmV0dXJuZWQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbmVpdGhlciBhIHZhbGlkIFxcYGVycm9yXFxgIGFuZCBcXGByZXN1bHRcXGAuIEF0IGxlYXN0IG9uZSBvZiB0aGVtIHNob3VsZCBub3QgYmUgXFxgdW5kZWZpbmVkXFxgYDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocmVzdWx0KSkge1xuICAgICAgICAgICAgICBpZiAoa2V5ICE9PSBcImVycm9yXCIgJiYga2V5ICE9PSBcImRhdGFcIiAmJiBrZXkgIT09IFwibWV0YVwiKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gYFRoZSBvYmplY3QgcmV0dXJuZWQgYnkgJHt3aGF0fSBoYXMgdGhlIHVua25vd24gcHJvcGVydHkgJHtrZXl9LmA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZW5jb3VudGVyZWQgaGFuZGxpbmcgdGhlIGVuZHBvaW50ICR7YXJnLmVuZHBvaW50TmFtZX0uXG4gICAgICAgICAgICAgICAgICAke2Vycn1cbiAgICAgICAgICAgICAgICAgIEl0IG5lZWRzIHRvIHJldHVybiBhbiBvYmplY3Qgd2l0aCBlaXRoZXIgdGhlIHNoYXBlIFxcYHsgZGF0YTogPHZhbHVlPiB9XFxgIG9yIFxcYHsgZXJyb3I6IDx2YWx1ZT4gfVxcYCB0aGF0IG1heSBjb250YWluIGFuIG9wdGlvbmFsIFxcYG1ldGFcXGAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgICBPYmplY3QgcmV0dXJuZWQgd2FzOmAsIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHRocm93IG5ldyBIYW5kbGVkRXJyb3IocmVzdWx0LmVycm9yLCByZXN1bHQubWV0YSk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUmVzcG9uc2UgPSBhd2FpdCB0cmFuc2Zvcm1SZXNwb25zZShyZXN1bHQuZGF0YSwgcmVzdWx0Lm1ldGEsIGZpbmFsUXVlcnlBcmcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICBkYXRhOiB0cmFuc2Zvcm1lZFJlc3BvbnNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoYXJnLnR5cGUgPT09IFwicXVlcnlcIiAmJiBcImluZmluaXRlUXVlcnlPcHRpb25zXCIgaW4gZW5kcG9pbnREZWZpbml0aW9uKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpbmZpbml0ZVF1ZXJ5T3B0aW9uc1xuICAgICAgICB9ID0gZW5kcG9pbnREZWZpbml0aW9uO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbWF4UGFnZXMgPSBJbmZpbml0eVxuICAgICAgICB9ID0gaW5maW5pdGVRdWVyeU9wdGlvbnM7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGNvbnN0IGJsYW5rRGF0YSA9IHtcbiAgICAgICAgICBwYWdlczogW10sXG4gICAgICAgICAgcGFnZVBhcmFtczogW11cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2FjaGVkRGF0YSA9IHNlbGVjdG9ycy5zZWxlY3RRdWVyeUVudHJ5KGdldFN0YXRlKCksIGFyZy5xdWVyeUNhY2hlS2V5KT8uZGF0YTtcbiAgICAgICAgY29uc3QgaXNGb3JjZWRRdWVyeU5lZWRpbmdSZWZldGNoID0gKFxuICAgICAgICAgIC8vIGFyZy5mb3JjZVJlZmV0Y2hcbiAgICAgICAgICBpc0ZvcmNlZFF1ZXJ5KGFyZywgZ2V0U3RhdGUoKSkgJiYgIWFyZy5kaXJlY3Rpb25cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdEYXRhID0gaXNGb3JjZWRRdWVyeU5lZWRpbmdSZWZldGNoIHx8ICFjYWNoZWREYXRhID8gYmxhbmtEYXRhIDogY2FjaGVkRGF0YTtcbiAgICAgICAgaWYgKFwiZGlyZWN0aW9uXCIgaW4gYXJnICYmIGFyZy5kaXJlY3Rpb24gJiYgZXhpc3RpbmdEYXRhLnBhZ2VzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gYXJnLmRpcmVjdGlvbiA9PT0gXCJiYWNrd2FyZFwiO1xuICAgICAgICAgIGNvbnN0IHBhZ2VQYXJhbUZuID0gcHJldmlvdXMgPyBnZXRQcmV2aW91c1BhZ2VQYXJhbSA6IGdldE5leHRQYWdlUGFyYW07XG4gICAgICAgICAgY29uc3QgcGFyYW0gPSBwYWdlUGFyYW1GbihpbmZpbml0ZVF1ZXJ5T3B0aW9ucywgZXhpc3RpbmdEYXRhKTtcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCBmZXRjaFBhZ2UoZXhpc3RpbmdEYXRhLCBwYXJhbSwgbWF4UGFnZXMsIHByZXZpb3VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpbml0aWFsUGFnZVBhcmFtID0gaW5maW5pdGVRdWVyeU9wdGlvbnMuaW5pdGlhbFBhZ2VQYXJhbVxuICAgICAgICAgIH0gPSBhcmc7XG4gICAgICAgICAgY29uc3QgY2FjaGVkUGFnZVBhcmFtcyA9IGNhY2hlZERhdGE/LnBhZ2VQYXJhbXMgPz8gW107XG4gICAgICAgICAgY29uc3QgZmlyc3RQYWdlUGFyYW0gPSBjYWNoZWRQYWdlUGFyYW1zWzBdID8/IGluaXRpYWxQYWdlUGFyYW07XG4gICAgICAgICAgY29uc3QgdG90YWxQYWdlcyA9IGNhY2hlZFBhZ2VQYXJhbXMubGVuZ3RoO1xuICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IGZldGNoUGFnZShleGlzdGluZ0RhdGEsIGZpcnN0UGFnZVBhcmFtLCBtYXhQYWdlcyk7XG4gICAgICAgICAgaWYgKGZvcmNlUXVlcnlGbikge1xuICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICBkYXRhOiByZXN1bHQuZGF0YS5wYWdlc1swXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0b3RhbFBhZ2VzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtID0gZ2V0TmV4dFBhZ2VQYXJhbShpbmZpbml0ZVF1ZXJ5T3B0aW9ucywgcmVzdWx0LmRhdGEpO1xuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgZmV0Y2hQYWdlKHJlc3VsdC5kYXRhLCBwYXJhbSwgbWF4UGFnZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbFF1ZXJ5UmV0dXJuVmFsdWUgPSByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5hbFF1ZXJ5UmV0dXJuVmFsdWUgPSBhd2FpdCBleGVjdXRlUmVxdWVzdChhcmcub3JpZ2luYWxBcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdWxmaWxsV2l0aFZhbHVlKGZpbmFsUXVlcnlSZXR1cm5WYWx1ZS5kYXRhLCBhZGRTaG91bGRBdXRvQmF0Y2goe1xuICAgICAgICBmdWxmaWxsZWRUaW1lU3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIGJhc2VRdWVyeU1ldGE6IGZpbmFsUXVlcnlSZXR1cm5WYWx1ZS5tZXRhXG4gICAgICB9KSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxldCBjYXRjaGVkRXJyb3IgPSBlcnJvcjtcbiAgICAgIGlmIChjYXRjaGVkRXJyb3IgaW5zdGFuY2VvZiBIYW5kbGVkRXJyb3IpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybUVycm9yUmVzcG9uc2UgPSBnZXRUcmFuc2Zvcm1DYWxsYmFja0ZvckVuZHBvaW50KGVuZHBvaW50RGVmaW5pdGlvbiwgXCJ0cmFuc2Zvcm1FcnJvclJlc3BvbnNlXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZWplY3RXaXRoVmFsdWUoYXdhaXQgdHJhbnNmb3JtRXJyb3JSZXNwb25zZShjYXRjaGVkRXJyb3IudmFsdWUsIGNhdGNoZWRFcnJvci5tZXRhLCBhcmcub3JpZ2luYWxBcmdzKSwgYWRkU2hvdWxkQXV0b0JhdGNoKHtcbiAgICAgICAgICAgIGJhc2VRdWVyeU1ldGE6IGNhdGNoZWRFcnJvci5tZXRhXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY2F0Y2hlZEVycm9yID0gZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBBbiB1bmhhbmRsZWQgZXJyb3Igb2NjdXJyZWQgcHJvY2Vzc2luZyBhIHJlcXVlc3QgZm9yIHRoZSBlbmRwb2ludCBcIiR7YXJnLmVuZHBvaW50TmFtZX1cIi5cbkluIHRoZSBjYXNlIG9mIGFuIHVuaGFuZGxlZCBlcnJvciwgbm8gdGFncyB3aWxsIGJlIFwicHJvdmlkZWRcIiBvciBcImludmFsaWRhdGVkXCIuYCwgY2F0Y2hlZEVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoY2F0Y2hlZEVycm9yKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGNhdGNoZWRFcnJvcjtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGlzRm9yY2VkUXVlcnkoYXJnLCBzdGF0ZSkge1xuICAgIGNvbnN0IHJlcXVlc3RTdGF0ZSA9IHNlbGVjdG9ycy5zZWxlY3RRdWVyeUVudHJ5KHN0YXRlLCBhcmcucXVlcnlDYWNoZUtleSk7XG4gICAgY29uc3QgYmFzZUZldGNoT25Nb3VudE9yQXJnQ2hhbmdlID0gc2VsZWN0b3JzLnNlbGVjdENvbmZpZyhzdGF0ZSkucmVmZXRjaE9uTW91bnRPckFyZ0NoYW5nZTtcbiAgICBjb25zdCBmdWxmaWxsZWRWYWwgPSByZXF1ZXN0U3RhdGU/LmZ1bGZpbGxlZFRpbWVTdGFtcDtcbiAgICBjb25zdCByZWZldGNoVmFsID0gYXJnLmZvcmNlUmVmZXRjaCA/PyAoYXJnLnN1YnNjcmliZSAmJiBiYXNlRmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2UpO1xuICAgIGlmIChyZWZldGNoVmFsKSB7XG4gICAgICByZXR1cm4gcmVmZXRjaFZhbCA9PT0gdHJ1ZSB8fCAoTnVtYmVyKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKSAtIE51bWJlcihmdWxmaWxsZWRWYWwpKSAvIDFlMyA+PSByZWZldGNoVmFsO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgY3JlYXRlUXVlcnlUaHVuayA9ICgpID0+IHtcbiAgICBjb25zdCBnZW5lcmF0ZWRRdWVyeVRodW5rID0gY3JlYXRlQXN5bmNUaHVuayhgJHtyZWR1Y2VyUGF0aH0vZXhlY3V0ZVF1ZXJ5YCwgZXhlY3V0ZUVuZHBvaW50LCB7XG4gICAgICBnZXRQZW5kaW5nTWV0YSh7XG4gICAgICAgIGFyZ1xuICAgICAgfSkge1xuICAgICAgICBjb25zdCBlbmRwb2ludERlZmluaXRpb24gPSBlbmRwb2ludERlZmluaXRpb25zW2FyZy5lbmRwb2ludE5hbWVdO1xuICAgICAgICByZXR1cm4gYWRkU2hvdWxkQXV0b0JhdGNoKHtcbiAgICAgICAgICBzdGFydGVkVGltZVN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgIC4uLmlzSW5maW5pdGVRdWVyeURlZmluaXRpb24oZW5kcG9pbnREZWZpbml0aW9uKSA/IHtcbiAgICAgICAgICAgIGRpcmVjdGlvbjogYXJnLmRpcmVjdGlvblxuICAgICAgICAgIH0gOiB7fVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBjb25kaXRpb24ocXVlcnlUaHVua0FyZywge1xuICAgICAgICBnZXRTdGF0ZVxuICAgICAgfSkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RTdGF0ZSA9IHNlbGVjdG9ycy5zZWxlY3RRdWVyeUVudHJ5KHN0YXRlLCBxdWVyeVRodW5rQXJnLnF1ZXJ5Q2FjaGVLZXkpO1xuICAgICAgICBjb25zdCBmdWxmaWxsZWRWYWwgPSByZXF1ZXN0U3RhdGU/LmZ1bGZpbGxlZFRpbWVTdGFtcDtcbiAgICAgICAgY29uc3QgY3VycmVudEFyZyA9IHF1ZXJ5VGh1bmtBcmcub3JpZ2luYWxBcmdzO1xuICAgICAgICBjb25zdCBwcmV2aW91c0FyZyA9IHJlcXVlc3RTdGF0ZT8ub3JpZ2luYWxBcmdzO1xuICAgICAgICBjb25zdCBlbmRwb2ludERlZmluaXRpb24gPSBlbmRwb2ludERlZmluaXRpb25zW3F1ZXJ5VGh1bmtBcmcuZW5kcG9pbnROYW1lXTtcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gcXVlcnlUaHVua0FyZy5kaXJlY3Rpb247XG4gICAgICAgIGlmIChpc1Vwc2VydFF1ZXJ5KHF1ZXJ5VGh1bmtBcmcpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3RTdGF0ZT8uc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGb3JjZWRRdWVyeShxdWVyeVRodW5rQXJnLCBzdGF0ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNRdWVyeURlZmluaXRpb24oZW5kcG9pbnREZWZpbml0aW9uKSAmJiBlbmRwb2ludERlZmluaXRpb24/LmZvcmNlUmVmZXRjaD8uKHtcbiAgICAgICAgICBjdXJyZW50QXJnLFxuICAgICAgICAgIHByZXZpb3VzQXJnLFxuICAgICAgICAgIGVuZHBvaW50U3RhdGU6IHJlcXVlc3RTdGF0ZSxcbiAgICAgICAgICBzdGF0ZVxuICAgICAgICB9KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdWxmaWxsZWRWYWwgJiYgIWRpcmVjdGlvbikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBkaXNwYXRjaENvbmRpdGlvblJlamVjdGlvbjogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBnZW5lcmF0ZWRRdWVyeVRodW5rO1xuICB9O1xuICBjb25zdCBxdWVyeVRodW5rID0gY3JlYXRlUXVlcnlUaHVuaygpO1xuICBjb25zdCBpbmZpbml0ZVF1ZXJ5VGh1bmsgPSBjcmVhdGVRdWVyeVRodW5rKCk7XG4gIGNvbnN0IG11dGF0aW9uVGh1bmsgPSBjcmVhdGVBc3luY1RodW5rKGAke3JlZHVjZXJQYXRofS9leGVjdXRlTXV0YXRpb25gLCBleGVjdXRlRW5kcG9pbnQsIHtcbiAgICBnZXRQZW5kaW5nTWV0YSgpIHtcbiAgICAgIHJldHVybiBhZGRTaG91bGRBdXRvQmF0Y2goe1xuICAgICAgICBzdGFydGVkVGltZVN0YW1wOiBEYXRlLm5vdygpXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBoYXNUaGVGb3JjZSA9IChvcHRpb25zKSA9PiBcImZvcmNlXCIgaW4gb3B0aW9ucztcbiAgY29uc3QgaGFzTWF4QWdlID0gKG9wdGlvbnMpID0+IFwiaWZPbGRlclRoYW5cIiBpbiBvcHRpb25zO1xuICBjb25zdCBwcmVmZXRjaCA9IChlbmRwb2ludE5hbWUsIGFyZywgb3B0aW9ucykgPT4gKGRpc3BhdGNoLCBnZXRTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IGZvcmNlID0gaGFzVGhlRm9yY2Uob3B0aW9ucykgJiYgb3B0aW9ucy5mb3JjZTtcbiAgICBjb25zdCBtYXhBZ2UgPSBoYXNNYXhBZ2Uob3B0aW9ucykgJiYgb3B0aW9ucy5pZk9sZGVyVGhhbjtcbiAgICBjb25zdCBxdWVyeUFjdGlvbiA9IChmb3JjZTIgPSB0cnVlKSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zMiA9IHtcbiAgICAgICAgZm9yY2VSZWZldGNoOiBmb3JjZTIsXG4gICAgICAgIGlzUHJlZmV0Y2g6IHRydWVcbiAgICAgIH07XG4gICAgICByZXR1cm4gYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdLmluaXRpYXRlKGFyZywgb3B0aW9uczIpO1xuICAgIH07XG4gICAgY29uc3QgbGF0ZXN0U3RhdGVWYWx1ZSA9IGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXS5zZWxlY3QoYXJnKShnZXRTdGF0ZSgpKTtcbiAgICBpZiAoZm9yY2UpIHtcbiAgICAgIGRpc3BhdGNoKHF1ZXJ5QWN0aW9uKCkpO1xuICAgIH0gZWxzZSBpZiAobWF4QWdlKSB7XG4gICAgICBjb25zdCBsYXN0RnVsZmlsbGVkVHMgPSBsYXRlc3RTdGF0ZVZhbHVlPy5mdWxmaWxsZWRUaW1lU3RhbXA7XG4gICAgICBpZiAoIWxhc3RGdWxmaWxsZWRUcykge1xuICAgICAgICBkaXNwYXRjaChxdWVyeUFjdGlvbigpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2hvdWxkUmV0cmlnZ2VyID0gKE51bWJlcigvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkgLSBOdW1iZXIobmV3IERhdGUobGFzdEZ1bGZpbGxlZFRzKSkpIC8gMWUzID49IG1heEFnZTtcbiAgICAgIGlmIChzaG91bGRSZXRyaWdnZXIpIHtcbiAgICAgICAgZGlzcGF0Y2gocXVlcnlBY3Rpb24oKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc3BhdGNoKHF1ZXJ5QWN0aW9uKGZhbHNlKSk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBtYXRjaGVzRW5kcG9pbnQoZW5kcG9pbnROYW1lKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGFjdGlvbj8ubWV0YT8uYXJnPy5lbmRwb2ludE5hbWUgPT09IGVuZHBvaW50TmFtZTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZE1hdGNoVGh1bmtBY3Rpb25zKHRodW5rLCBlbmRwb2ludE5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0Y2hQZW5kaW5nOiBpc0FsbE9mKGlzUGVuZGluZyh0aHVuayksIG1hdGNoZXNFbmRwb2ludChlbmRwb2ludE5hbWUpKSxcbiAgICAgIG1hdGNoRnVsZmlsbGVkOiBpc0FsbE9mKGlzRnVsZmlsbGVkKHRodW5rKSwgbWF0Y2hlc0VuZHBvaW50KGVuZHBvaW50TmFtZSkpLFxuICAgICAgbWF0Y2hSZWplY3RlZDogaXNBbGxPZihpc1JlamVjdGVkKHRodW5rKSwgbWF0Y2hlc0VuZHBvaW50KGVuZHBvaW50TmFtZSkpXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHF1ZXJ5VGh1bmssXG4gICAgbXV0YXRpb25UaHVuayxcbiAgICBpbmZpbml0ZVF1ZXJ5VGh1bmssXG4gICAgcHJlZmV0Y2gsXG4gICAgdXBkYXRlUXVlcnlEYXRhLFxuICAgIHVwc2VydFF1ZXJ5RGF0YSxcbiAgICBwYXRjaFF1ZXJ5RGF0YSxcbiAgICBidWlsZE1hdGNoVGh1bmtBY3Rpb25zXG4gIH07XG59XG5mdW5jdGlvbiBnZXROZXh0UGFnZVBhcmFtKG9wdGlvbnMsIHtcbiAgcGFnZXMsXG4gIHBhZ2VQYXJhbXNcbn0pIHtcbiAgY29uc3QgbGFzdEluZGV4ID0gcGFnZXMubGVuZ3RoIC0gMTtcbiAgcmV0dXJuIG9wdGlvbnMuZ2V0TmV4dFBhZ2VQYXJhbShwYWdlc1tsYXN0SW5kZXhdLCBwYWdlcywgcGFnZVBhcmFtc1tsYXN0SW5kZXhdLCBwYWdlUGFyYW1zKTtcbn1cbmZ1bmN0aW9uIGdldFByZXZpb3VzUGFnZVBhcmFtKG9wdGlvbnMsIHtcbiAgcGFnZXMsXG4gIHBhZ2VQYXJhbXNcbn0pIHtcbiAgcmV0dXJuIG9wdGlvbnMuZ2V0UHJldmlvdXNQYWdlUGFyYW0/LihwYWdlc1swXSwgcGFnZXMsIHBhZ2VQYXJhbXNbMF0sIHBhZ2VQYXJhbXMpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUHJvdmlkZWRCeVRodW5rKGFjdGlvbiwgdHlwZSwgZW5kcG9pbnREZWZpbml0aW9ucywgYXNzZXJ0VGFnVHlwZSkge1xuICByZXR1cm4gY2FsY3VsYXRlUHJvdmlkZWRCeShlbmRwb2ludERlZmluaXRpb25zW2FjdGlvbi5tZXRhLmFyZy5lbmRwb2ludE5hbWVdW3R5cGVdLCBpc0Z1bGZpbGxlZChhY3Rpb24pID8gYWN0aW9uLnBheWxvYWQgOiB2b2lkIDAsIGlzUmVqZWN0ZWRXaXRoVmFsdWUoYWN0aW9uKSA/IGFjdGlvbi5wYXlsb2FkIDogdm9pZCAwLCBhY3Rpb24ubWV0YS5hcmcub3JpZ2luYWxBcmdzLCBcImJhc2VRdWVyeU1ldGFcIiBpbiBhY3Rpb24ubWV0YSA/IGFjdGlvbi5tZXRhLmJhc2VRdWVyeU1ldGEgOiB2b2lkIDAsIGFzc2VydFRhZ1R5cGUpO1xufVxuXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZFNsaWNlLnRzXG5pbXBvcnQgeyBpc0RyYWZ0IH0gZnJvbSBcImltbWVyXCI7XG5pbXBvcnQgeyBhcHBseVBhdGNoZXMsIG9yaWdpbmFsIH0gZnJvbSBcImltbWVyXCI7XG5mdW5jdGlvbiB1cGRhdGVRdWVyeVN1YnN0YXRlSWZFeGlzdHMoc3RhdGUsIHF1ZXJ5Q2FjaGVLZXksIHVwZGF0ZSkge1xuICBjb25zdCBzdWJzdGF0ZSA9IHN0YXRlW3F1ZXJ5Q2FjaGVLZXldO1xuICBpZiAoc3Vic3RhdGUpIHtcbiAgICB1cGRhdGUoc3Vic3RhdGUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRNdXRhdGlvbkNhY2hlS2V5KGlkKSB7XG4gIHJldHVybiAoXCJhcmdcIiBpbiBpZCA/IGlkLmFyZy5maXhlZENhY2hlS2V5IDogaWQuZml4ZWRDYWNoZUtleSkgPz8gaWQucmVxdWVzdElkO1xufVxuZnVuY3Rpb24gdXBkYXRlTXV0YXRpb25TdWJzdGF0ZUlmRXhpc3RzKHN0YXRlLCBpZCwgdXBkYXRlKSB7XG4gIGNvbnN0IHN1YnN0YXRlID0gc3RhdGVbZ2V0TXV0YXRpb25DYWNoZUtleShpZCldO1xuICBpZiAoc3Vic3RhdGUpIHtcbiAgICB1cGRhdGUoc3Vic3RhdGUpO1xuICB9XG59XG52YXIgaW5pdGlhbFN0YXRlID0ge307XG5mdW5jdGlvbiBidWlsZFNsaWNlKHtcbiAgcmVkdWNlclBhdGgsXG4gIHF1ZXJ5VGh1bmssXG4gIG11dGF0aW9uVGh1bmssXG4gIHNlcmlhbGl6ZVF1ZXJ5QXJncyxcbiAgY29udGV4dDoge1xuICAgIGVuZHBvaW50RGVmaW5pdGlvbnM6IGRlZmluaXRpb25zLFxuICAgIGFwaVVpZCxcbiAgICBleHRyYWN0UmVoeWRyYXRpb25JbmZvLFxuICAgIGhhc1JlaHlkcmF0aW9uSW5mb1xuICB9LFxuICBhc3NlcnRUYWdUeXBlLFxuICBjb25maWdcbn0pIHtcbiAgY29uc3QgcmVzZXRBcGlTdGF0ZSA9IGNyZWF0ZUFjdGlvbihgJHtyZWR1Y2VyUGF0aH0vcmVzZXRBcGlTdGF0ZWApO1xuICBmdW5jdGlvbiB3cml0ZVBlbmRpbmdDYWNoZUVudHJ5KGRyYWZ0LCBhcmcsIHVwc2VydGluZywgbWV0YSkge1xuICAgIGRyYWZ0W2FyZy5xdWVyeUNhY2hlS2V5XSA/Pz0ge1xuICAgICAgc3RhdHVzOiBcInVuaW5pdGlhbGl6ZWRcIiAvKiB1bmluaXRpYWxpemVkICovLFxuICAgICAgZW5kcG9pbnROYW1lOiBhcmcuZW5kcG9pbnROYW1lXG4gICAgfTtcbiAgICB1cGRhdGVRdWVyeVN1YnN0YXRlSWZFeGlzdHMoZHJhZnQsIGFyZy5xdWVyeUNhY2hlS2V5LCAoc3Vic3RhdGUpID0+IHtcbiAgICAgIHN1YnN0YXRlLnN0YXR1cyA9IFwicGVuZGluZ1wiIC8qIHBlbmRpbmcgKi87XG4gICAgICBzdWJzdGF0ZS5yZXF1ZXN0SWQgPSB1cHNlcnRpbmcgJiYgc3Vic3RhdGUucmVxdWVzdElkID8gKFxuICAgICAgICAvLyBmb3IgYHVwc2VydFF1ZXJ5YCAqKnVwZGF0ZXMqKiwga2VlcCB0aGUgY3VycmVudCBgcmVxdWVzdElkYFxuICAgICAgICBzdWJzdGF0ZS5yZXF1ZXN0SWRcbiAgICAgICkgOiAoXG4gICAgICAgIC8vIGZvciBub3JtYWwgcXVlcmllcyBvciBgdXBzZXJ0UXVlcnlgICoqaW5zZXJ0cyoqIGFsd2F5cyB1cGRhdGUgdGhlIGByZXF1ZXN0SWRgXG4gICAgICAgIG1ldGEucmVxdWVzdElkXG4gICAgICApO1xuICAgICAgaWYgKGFyZy5vcmlnaW5hbEFyZ3MgIT09IHZvaWQgMCkge1xuICAgICAgICBzdWJzdGF0ZS5vcmlnaW5hbEFyZ3MgPSBhcmcub3JpZ2luYWxBcmdzO1xuICAgICAgfVxuICAgICAgc3Vic3RhdGUuc3RhcnRlZFRpbWVTdGFtcCA9IG1ldGEuc3RhcnRlZFRpbWVTdGFtcDtcbiAgICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGRlZmluaXRpb25zW21ldGEuYXJnLmVuZHBvaW50TmFtZV07XG4gICAgICBpZiAoaXNJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbihlbmRwb2ludERlZmluaXRpb24pICYmIFwiZGlyZWN0aW9uXCIgaW4gYXJnKSB7XG4gICAgICAgIDtcbiAgICAgICAgc3Vic3RhdGUuZGlyZWN0aW9uID0gYXJnLmRpcmVjdGlvbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiB3cml0ZUZ1bGZpbGxlZENhY2hlRW50cnkoZHJhZnQsIG1ldGEsIHBheWxvYWQsIHVwc2VydGluZykge1xuICAgIHVwZGF0ZVF1ZXJ5U3Vic3RhdGVJZkV4aXN0cyhkcmFmdCwgbWV0YS5hcmcucXVlcnlDYWNoZUtleSwgKHN1YnN0YXRlKSA9PiB7XG4gICAgICBpZiAoc3Vic3RhdGUucmVxdWVzdElkICE9PSBtZXRhLnJlcXVlc3RJZCAmJiAhdXBzZXJ0aW5nKSByZXR1cm47XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1lcmdlXG4gICAgICB9ID0gZGVmaW5pdGlvbnNbbWV0YS5hcmcuZW5kcG9pbnROYW1lXTtcbiAgICAgIHN1YnN0YXRlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCIgLyogZnVsZmlsbGVkICovO1xuICAgICAgaWYgKG1lcmdlKSB7XG4gICAgICAgIGlmIChzdWJzdGF0ZS5kYXRhICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBmdWxmaWxsZWRUaW1lU3RhbXAsXG4gICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICBiYXNlUXVlcnlNZXRhLFxuICAgICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgICAgfSA9IG1ldGE7XG4gICAgICAgICAgbGV0IG5ld0RhdGEgPSBjcmVhdGVOZXh0U3RhdGUoc3Vic3RhdGUuZGF0YSwgKGRyYWZ0U3Vic3RhdGVEYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2UoZHJhZnRTdWJzdGF0ZURhdGEsIHBheWxvYWQsIHtcbiAgICAgICAgICAgICAgYXJnOiBhcmcub3JpZ2luYWxBcmdzLFxuICAgICAgICAgICAgICBiYXNlUXVlcnlNZXRhLFxuICAgICAgICAgICAgICBmdWxmaWxsZWRUaW1lU3RhbXAsXG4gICAgICAgICAgICAgIHJlcXVlc3RJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3Vic3RhdGUuZGF0YSA9IG5ld0RhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3Vic3RhdGUuZGF0YSA9IHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1YnN0YXRlLmRhdGEgPSBkZWZpbml0aW9uc1ttZXRhLmFyZy5lbmRwb2ludE5hbWVdLnN0cnVjdHVyYWxTaGFyaW5nID8/IHRydWUgPyBjb3B5V2l0aFN0cnVjdHVyYWxTaGFyaW5nKGlzRHJhZnQoc3Vic3RhdGUuZGF0YSkgPyBvcmlnaW5hbChzdWJzdGF0ZS5kYXRhKSA6IHN1YnN0YXRlLmRhdGEsIHBheWxvYWQpIDogcGF5bG9hZDtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBzdWJzdGF0ZS5lcnJvcjtcbiAgICAgIHN1YnN0YXRlLmZ1bGZpbGxlZFRpbWVTdGFtcCA9IG1ldGEuZnVsZmlsbGVkVGltZVN0YW1wO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IHF1ZXJ5U2xpY2UgPSBjcmVhdGVTbGljZSh7XG4gICAgbmFtZTogYCR7cmVkdWNlclBhdGh9L3F1ZXJpZXNgLFxuICAgIGluaXRpYWxTdGF0ZSxcbiAgICByZWR1Y2Vyczoge1xuICAgICAgcmVtb3ZlUXVlcnlSZXN1bHQ6IHtcbiAgICAgICAgcmVkdWNlcihkcmFmdCwge1xuICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgICAgICB9XG4gICAgICAgIH0pIHtcbiAgICAgICAgICBkZWxldGUgZHJhZnRbcXVlcnlDYWNoZUtleV07XG4gICAgICAgIH0sXG4gICAgICAgIHByZXBhcmU6IHByZXBhcmVBdXRvQmF0Y2hlZCgpXG4gICAgICB9LFxuICAgICAgY2FjaGVFbnRyaWVzVXBzZXJ0ZWQ6IHtcbiAgICAgICAgcmVkdWNlcihkcmFmdCwgYWN0aW9uKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBhY3Rpb24ucGF5bG9hZCkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBxdWVyeURlc2NyaXB0aW9uOiBhcmcsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9ID0gZW50cnk7XG4gICAgICAgICAgICB3cml0ZVBlbmRpbmdDYWNoZUVudHJ5KGRyYWZ0LCBhcmcsIHRydWUsIHtcbiAgICAgICAgICAgICAgYXJnLFxuICAgICAgICAgICAgICByZXF1ZXN0SWQ6IGFjdGlvbi5tZXRhLnJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgc3RhcnRlZFRpbWVTdGFtcDogYWN0aW9uLm1ldGEudGltZXN0YW1wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHdyaXRlRnVsZmlsbGVkQ2FjaGVFbnRyeShcbiAgICAgICAgICAgICAgZHJhZnQsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICAgICAgcmVxdWVzdElkOiBhY3Rpb24ubWV0YS5yZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgZnVsZmlsbGVkVGltZVN0YW1wOiBhY3Rpb24ubWV0YS50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgYmFzZVF1ZXJ5TWV0YToge31cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIC8vIFdlIGtub3cgd2UncmUgdXBzZXJ0aW5nIGhlcmVcbiAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHByZXBhcmU6IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgY29uc3QgcXVlcnlEZXNjcmlwdGlvbnMgPSBwYXlsb2FkLm1hcCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgZW5kcG9pbnROYW1lLFxuICAgICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9ID0gZW50cnk7XG4gICAgICAgICAgICBjb25zdCBlbmRwb2ludERlZmluaXRpb24gPSBkZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdO1xuICAgICAgICAgICAgY29uc3QgcXVlcnlEZXNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJxdWVyeVwiLFxuICAgICAgICAgICAgICBlbmRwb2ludE5hbWUsXG4gICAgICAgICAgICAgIG9yaWdpbmFsQXJnczogZW50cnkuYXJnLFxuICAgICAgICAgICAgICBxdWVyeUNhY2hlS2V5OiBzZXJpYWxpemVRdWVyeUFyZ3Moe1xuICAgICAgICAgICAgICAgIHF1ZXJ5QXJnczogYXJnLFxuICAgICAgICAgICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbixcbiAgICAgICAgICAgICAgICBlbmRwb2ludE5hbWVcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBxdWVyeURlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBwYXlsb2FkOiBxdWVyeURlc2NyaXB0aW9ucyxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgW1NIT1VMRF9BVVRPQkFUQ0hdOiB0cnVlLFxuICAgICAgICAgICAgICByZXF1ZXN0SWQ6IG5hbm9pZCgpLFxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBxdWVyeVJlc3VsdFBhdGNoZWQ6IHtcbiAgICAgICAgcmVkdWNlcihkcmFmdCwge1xuICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgICAgICBwYXRjaGVzXG4gICAgICAgICAgfVxuICAgICAgICB9KSB7XG4gICAgICAgICAgdXBkYXRlUXVlcnlTdWJzdGF0ZUlmRXhpc3RzKGRyYWZ0LCBxdWVyeUNhY2hlS2V5LCAoc3Vic3RhdGUpID0+IHtcbiAgICAgICAgICAgIHN1YnN0YXRlLmRhdGEgPSBhcHBseVBhdGNoZXMoc3Vic3RhdGUuZGF0YSwgcGF0Y2hlcy5jb25jYXQoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZXBhcmU6IHByZXBhcmVBdXRvQmF0Y2hlZCgpXG4gICAgICB9XG4gICAgfSxcbiAgICBleHRyYVJlZHVjZXJzKGJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuYWRkQ2FzZShxdWVyeVRodW5rLnBlbmRpbmcsIChkcmFmdCwge1xuICAgICAgICBtZXRhLFxuICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgYXJnXG4gICAgICAgIH1cbiAgICAgIH0pID0+IHtcbiAgICAgICAgY29uc3QgdXBzZXJ0aW5nID0gaXNVcHNlcnRRdWVyeShhcmcpO1xuICAgICAgICB3cml0ZVBlbmRpbmdDYWNoZUVudHJ5KGRyYWZ0LCBhcmcsIHVwc2VydGluZywgbWV0YSk7XG4gICAgICB9KS5hZGRDYXNlKHF1ZXJ5VGh1bmsuZnVsZmlsbGVkLCAoZHJhZnQsIHtcbiAgICAgICAgbWV0YSxcbiAgICAgICAgcGF5bG9hZFxuICAgICAgfSkgPT4ge1xuICAgICAgICBjb25zdCB1cHNlcnRpbmcgPSBpc1Vwc2VydFF1ZXJ5KG1ldGEuYXJnKTtcbiAgICAgICAgd3JpdGVGdWxmaWxsZWRDYWNoZUVudHJ5KGRyYWZ0LCBtZXRhLCBwYXlsb2FkLCB1cHNlcnRpbmcpO1xuICAgICAgfSkuYWRkQ2FzZShxdWVyeVRodW5rLnJlamVjdGVkLCAoZHJhZnQsIHtcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgIGNvbmRpdGlvbixcbiAgICAgICAgICBhcmcsXG4gICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yLFxuICAgICAgICBwYXlsb2FkXG4gICAgICB9KSA9PiB7XG4gICAgICAgIHVwZGF0ZVF1ZXJ5U3Vic3RhdGVJZkV4aXN0cyhkcmFmdCwgYXJnLnF1ZXJ5Q2FjaGVLZXksIChzdWJzdGF0ZSkgPT4ge1xuICAgICAgICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN1YnN0YXRlLnJlcXVlc3RJZCAhPT0gcmVxdWVzdElkKSByZXR1cm47XG4gICAgICAgICAgICBzdWJzdGF0ZS5zdGF0dXMgPSBcInJlamVjdGVkXCIgLyogcmVqZWN0ZWQgKi87XG4gICAgICAgICAgICBzdWJzdGF0ZS5lcnJvciA9IHBheWxvYWQgPz8gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pLmFkZE1hdGNoZXIoaGFzUmVoeWRyYXRpb25JbmZvLCAoZHJhZnQsIGFjdGlvbikgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcXVlcmllc1xuICAgICAgICB9ID0gZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyhhY3Rpb24pO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGVudHJ5XSBvZiBPYmplY3QuZW50cmllcyhxdWVyaWVzKSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIGRvIG5vdCByZWh5ZHJhdGUgZW50cmllcyB0aGF0IHdlcmUgY3VycmVudGx5IGluIGZsaWdodC5cbiAgICAgICAgICAgIGVudHJ5Py5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIgLyogZnVsZmlsbGVkICovIHx8IGVudHJ5Py5zdGF0dXMgPT09IFwicmVqZWN0ZWRcIiAvKiByZWplY3RlZCAqL1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgZHJhZnRba2V5XSA9IGVudHJ5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgbXV0YXRpb25TbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgICBuYW1lOiBgJHtyZWR1Y2VyUGF0aH0vbXV0YXRpb25zYCxcbiAgICBpbml0aWFsU3RhdGUsXG4gICAgcmVkdWNlcnM6IHtcbiAgICAgIHJlbW92ZU11dGF0aW9uUmVzdWx0OiB7XG4gICAgICAgIHJlZHVjZXIoZHJhZnQsIHtcbiAgICAgICAgICBwYXlsb2FkXG4gICAgICAgIH0pIHtcbiAgICAgICAgICBjb25zdCBjYWNoZUtleSA9IGdldE11dGF0aW9uQ2FjaGVLZXkocGF5bG9hZCk7XG4gICAgICAgICAgaWYgKGNhY2hlS2V5IGluIGRyYWZ0KSB7XG4gICAgICAgICAgICBkZWxldGUgZHJhZnRbY2FjaGVLZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyZTogcHJlcGFyZUF1dG9CYXRjaGVkKClcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4dHJhUmVkdWNlcnMoYnVpbGRlcikge1xuICAgICAgYnVpbGRlci5hZGRDYXNlKG11dGF0aW9uVGh1bmsucGVuZGluZywgKGRyYWZ0LCB7XG4gICAgICAgIG1ldGEsXG4gICAgICAgIG1ldGE6IHtcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgYXJnLFxuICAgICAgICAgIHN0YXJ0ZWRUaW1lU3RhbXBcbiAgICAgICAgfVxuICAgICAgfSkgPT4ge1xuICAgICAgICBpZiAoIWFyZy50cmFjaykgcmV0dXJuO1xuICAgICAgICBkcmFmdFtnZXRNdXRhdGlvbkNhY2hlS2V5KG1ldGEpXSA9IHtcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIiAvKiBwZW5kaW5nICovLFxuICAgICAgICAgIGVuZHBvaW50TmFtZTogYXJnLmVuZHBvaW50TmFtZSxcbiAgICAgICAgICBzdGFydGVkVGltZVN0YW1wXG4gICAgICAgIH07XG4gICAgICB9KS5hZGRDYXNlKG11dGF0aW9uVGh1bmsuZnVsZmlsbGVkLCAoZHJhZnQsIHtcbiAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgbWV0YVxuICAgICAgfSkgPT4ge1xuICAgICAgICBpZiAoIW1ldGEuYXJnLnRyYWNrKSByZXR1cm47XG4gICAgICAgIHVwZGF0ZU11dGF0aW9uU3Vic3RhdGVJZkV4aXN0cyhkcmFmdCwgbWV0YSwgKHN1YnN0YXRlKSA9PiB7XG4gICAgICAgICAgaWYgKHN1YnN0YXRlLnJlcXVlc3RJZCAhPT0gbWV0YS5yZXF1ZXN0SWQpIHJldHVybjtcbiAgICAgICAgICBzdWJzdGF0ZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiIC8qIGZ1bGZpbGxlZCAqLztcbiAgICAgICAgICBzdWJzdGF0ZS5kYXRhID0gcGF5bG9hZDtcbiAgICAgICAgICBzdWJzdGF0ZS5mdWxmaWxsZWRUaW1lU3RhbXAgPSBtZXRhLmZ1bGZpbGxlZFRpbWVTdGFtcDtcbiAgICAgICAgfSk7XG4gICAgICB9KS5hZGRDYXNlKG11dGF0aW9uVGh1bmsucmVqZWN0ZWQsIChkcmFmdCwge1xuICAgICAgICBwYXlsb2FkLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgbWV0YVxuICAgICAgfSkgPT4ge1xuICAgICAgICBpZiAoIW1ldGEuYXJnLnRyYWNrKSByZXR1cm47XG4gICAgICAgIHVwZGF0ZU11dGF0aW9uU3Vic3RhdGVJZkV4aXN0cyhkcmFmdCwgbWV0YSwgKHN1YnN0YXRlKSA9PiB7XG4gICAgICAgICAgaWYgKHN1YnN0YXRlLnJlcXVlc3RJZCAhPT0gbWV0YS5yZXF1ZXN0SWQpIHJldHVybjtcbiAgICAgICAgICBzdWJzdGF0ZS5zdGF0dXMgPSBcInJlamVjdGVkXCIgLyogcmVqZWN0ZWQgKi87XG4gICAgICAgICAgc3Vic3RhdGUuZXJyb3IgPSBwYXlsb2FkID8/IGVycm9yO1xuICAgICAgICB9KTtcbiAgICAgIH0pLmFkZE1hdGNoZXIoaGFzUmVoeWRyYXRpb25JbmZvLCAoZHJhZnQsIGFjdGlvbikgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbXV0YXRpb25zXG4gICAgICAgIH0gPSBleHRyYWN0UmVoeWRyYXRpb25JbmZvKGFjdGlvbik7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgZW50cnldIG9mIE9iamVjdC5lbnRyaWVzKG11dGF0aW9ucykpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBkbyBub3QgcmVoeWRyYXRlIGVudHJpZXMgdGhhdCB3ZXJlIGN1cnJlbnRseSBpbiBmbGlnaHQuXG4gICAgICAgICAgICAoZW50cnk/LnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIiAvKiBmdWxmaWxsZWQgKi8gfHwgZW50cnk/LnN0YXR1cyA9PT0gXCJyZWplY3RlZFwiIC8qIHJlamVjdGVkICovKSAmJiAvLyBvbmx5IHJlaHlkcmF0ZSBlbmRwb2ludHMgdGhhdCB3ZXJlIHBlcnNpc3RlZCB1c2luZyBhIGBmaXhlZENhY2hlS2V5YFxuICAgICAgICAgICAga2V5ICE9PSBlbnRyeT8ucmVxdWVzdElkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBkcmFmdFtrZXldID0gZW50cnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBpbnZhbGlkYXRpb25TbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgICBuYW1lOiBgJHtyZWR1Y2VyUGF0aH0vaW52YWxpZGF0aW9uYCxcbiAgICBpbml0aWFsU3RhdGUsXG4gICAgcmVkdWNlcnM6IHtcbiAgICAgIHVwZGF0ZVByb3ZpZGVkQnk6IHtcbiAgICAgICAgcmVkdWNlcihkcmFmdCwgYWN0aW9uKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgICAgICAgIHByb3ZpZGVkVGFnc1xuICAgICAgICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgICBmb3IgKGNvbnN0IHRhZ1R5cGVTdWJzY3JpcHRpb25zIG9mIE9iamVjdC52YWx1ZXMoZHJhZnQpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkU3Vic2NyaXB0aW9ucyBvZiBPYmplY3QudmFsdWVzKHRhZ1R5cGVTdWJzY3JpcHRpb25zKSkge1xuICAgICAgICAgICAgICBjb25zdCBmb3VuZEF0ID0gaWRTdWJzY3JpcHRpb25zLmluZGV4T2YocXVlcnlDYWNoZUtleSk7XG4gICAgICAgICAgICAgIGlmIChmb3VuZEF0ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlkU3Vic2NyaXB0aW9ucy5zcGxpY2UoZm91bmRBdCwgMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgaWRcbiAgICAgICAgICB9IG9mIHByb3ZpZGVkVGFncykge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlZFF1ZXJpZXMgPSAoZHJhZnRbdHlwZV0gPz89IHt9KVtpZCB8fCBcIl9faW50ZXJuYWxfd2l0aG91dF9pZFwiXSA/Pz0gW107XG4gICAgICAgICAgICBjb25zdCBhbHJlYWR5U3Vic2NyaWJlZCA9IHN1YnNjcmliZWRRdWVyaWVzLmluY2x1ZGVzKHF1ZXJ5Q2FjaGVLZXkpO1xuICAgICAgICAgICAgaWYgKCFhbHJlYWR5U3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICBzdWJzY3JpYmVkUXVlcmllcy5wdXNoKHF1ZXJ5Q2FjaGVLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyZTogcHJlcGFyZUF1dG9CYXRjaGVkKClcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4dHJhUmVkdWNlcnMoYnVpbGRlcikge1xuICAgICAgYnVpbGRlci5hZGRDYXNlKHF1ZXJ5U2xpY2UuYWN0aW9ucy5yZW1vdmVRdWVyeVJlc3VsdCwgKGRyYWZ0LCB7XG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICBxdWVyeUNhY2hlS2V5XG4gICAgICAgIH1cbiAgICAgIH0pID0+IHtcbiAgICAgICAgZm9yIChjb25zdCB0YWdUeXBlU3Vic2NyaXB0aW9ucyBvZiBPYmplY3QudmFsdWVzKGRyYWZ0KSkge1xuICAgICAgICAgIGZvciAoY29uc3QgaWRTdWJzY3JpcHRpb25zIG9mIE9iamVjdC52YWx1ZXModGFnVHlwZVN1YnNjcmlwdGlvbnMpKSB7XG4gICAgICAgICAgICBjb25zdCBmb3VuZEF0ID0gaWRTdWJzY3JpcHRpb25zLmluZGV4T2YocXVlcnlDYWNoZUtleSk7XG4gICAgICAgICAgICBpZiAoZm91bmRBdCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgaWRTdWJzY3JpcHRpb25zLnNwbGljZShmb3VuZEF0LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLmFkZE1hdGNoZXIoaGFzUmVoeWRyYXRpb25JbmZvLCAoZHJhZnQsIGFjdGlvbikgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcHJvdmlkZWRcbiAgICAgICAgfSA9IGV4dHJhY3RSZWh5ZHJhdGlvbkluZm8oYWN0aW9uKTtcbiAgICAgICAgZm9yIChjb25zdCBbdHlwZSwgaW5jb21pbmdUYWdzXSBvZiBPYmplY3QuZW50cmllcyhwcm92aWRlZCkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtpZCwgY2FjaGVLZXlzXSBvZiBPYmplY3QuZW50cmllcyhpbmNvbWluZ1RhZ3MpKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVkUXVlcmllcyA9IChkcmFmdFt0eXBlXSA/Pz0ge30pW2lkIHx8IFwiX19pbnRlcm5hbF93aXRob3V0X2lkXCJdID8/PSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcXVlcnlDYWNoZUtleSBvZiBjYWNoZUtleXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgYWxyZWFkeVN1YnNjcmliZWQgPSBzdWJzY3JpYmVkUXVlcmllcy5pbmNsdWRlcyhxdWVyeUNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgaWYgKCFhbHJlYWR5U3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZWRRdWVyaWVzLnB1c2gocXVlcnlDYWNoZUtleSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLmFkZE1hdGNoZXIoaXNBbnlPZihpc0Z1bGZpbGxlZChxdWVyeVRodW5rKSwgaXNSZWplY3RlZFdpdGhWYWx1ZShxdWVyeVRodW5rKSksIChkcmFmdCwgYWN0aW9uKSA9PiB7XG4gICAgICAgIHdyaXRlUHJvdmlkZWRUYWdzRm9yUXVlcnkoZHJhZnQsIGFjdGlvbik7XG4gICAgICB9KS5hZGRNYXRjaGVyKHF1ZXJ5U2xpY2UuYWN0aW9ucy5jYWNoZUVudHJpZXNVcHNlcnRlZC5tYXRjaCwgKGRyYWZ0LCBhY3Rpb24pID0+IHtcbiAgICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgICAgcXVlcnlEZXNjcmlwdGlvbjogYXJnLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0gb2YgYWN0aW9uLnBheWxvYWQpIHtcbiAgICAgICAgICBjb25zdCBhY3Rpb24yID0ge1xuICAgICAgICAgICAgdHlwZTogXCJVTktOT1dOXCIsXG4gICAgICAgICAgICBwYXlsb2FkOiB2YWx1ZSxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgcmVxdWVzdFN0YXR1czogXCJmdWxmaWxsZWRcIixcbiAgICAgICAgICAgICAgcmVxdWVzdElkOiBcIlVOS05PV05cIixcbiAgICAgICAgICAgICAgYXJnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3cml0ZVByb3ZpZGVkVGFnc0ZvclF1ZXJ5KGRyYWZ0LCBhY3Rpb24yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gd3JpdGVQcm92aWRlZFRhZ3NGb3JRdWVyeShkcmFmdCwgYWN0aW9uKSB7XG4gICAgY29uc3QgcHJvdmlkZWRUYWdzID0gY2FsY3VsYXRlUHJvdmlkZWRCeVRodW5rKGFjdGlvbiwgXCJwcm92aWRlc1RhZ3NcIiwgZGVmaW5pdGlvbnMsIGFzc2VydFRhZ1R5cGUpO1xuICAgIGNvbnN0IHtcbiAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICB9ID0gYWN0aW9uLm1ldGEuYXJnO1xuICAgIGludmFsaWRhdGlvblNsaWNlLmNhc2VSZWR1Y2Vycy51cGRhdGVQcm92aWRlZEJ5KGRyYWZ0LCBpbnZhbGlkYXRpb25TbGljZS5hY3Rpb25zLnVwZGF0ZVByb3ZpZGVkQnkoe1xuICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgIHByb3ZpZGVkVGFnc1xuICAgIH0pKTtcbiAgfVxuICBjb25zdCBzdWJzY3JpcHRpb25TbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgICBuYW1lOiBgJHtyZWR1Y2VyUGF0aH0vc3Vic2NyaXB0aW9uc2AsXG4gICAgaW5pdGlhbFN0YXRlLFxuICAgIHJlZHVjZXJzOiB7XG4gICAgICB1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zKGQsIGEpIHtcbiAgICAgIH0sXG4gICAgICB1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0KGQsIGEpIHtcbiAgICAgIH0sXG4gICAgICBpbnRlcm5hbF9nZXRSVEtRU3Vic2NyaXB0aW9ucygpIHtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBjb25zdCBpbnRlcm5hbFN1YnNjcmlwdGlvbnNTbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgICBuYW1lOiBgJHtyZWR1Y2VyUGF0aH0vaW50ZXJuYWxTdWJzY3JpcHRpb25zYCxcbiAgICBpbml0aWFsU3RhdGUsXG4gICAgcmVkdWNlcnM6IHtcbiAgICAgIHN1YnNjcmlwdGlvbnNVcGRhdGVkOiB7XG4gICAgICAgIHJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgICAgICAgIHJldHVybiBhcHBseVBhdGNoZXMoc3RhdGUsIGFjdGlvbi5wYXlsb2FkKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyZTogcHJlcGFyZUF1dG9CYXRjaGVkKClcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBjb25zdCBjb25maWdTbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgICBuYW1lOiBgJHtyZWR1Y2VyUGF0aH0vY29uZmlnYCxcbiAgICBpbml0aWFsU3RhdGU6IHtcbiAgICAgIG9ubGluZTogaXNPbmxpbmUoKSxcbiAgICAgIGZvY3VzZWQ6IGlzRG9jdW1lbnRWaXNpYmxlKCksXG4gICAgICBtaWRkbGV3YXJlUmVnaXN0ZXJlZDogZmFsc2UsXG4gICAgICAuLi5jb25maWdcbiAgICB9LFxuICAgIHJlZHVjZXJzOiB7XG4gICAgICBtaWRkbGV3YXJlUmVnaXN0ZXJlZChzdGF0ZSwge1xuICAgICAgICBwYXlsb2FkXG4gICAgICB9KSB7XG4gICAgICAgIHN0YXRlLm1pZGRsZXdhcmVSZWdpc3RlcmVkID0gc3RhdGUubWlkZGxld2FyZVJlZ2lzdGVyZWQgPT09IFwiY29uZmxpY3RcIiB8fCBhcGlVaWQgIT09IHBheWxvYWQgPyBcImNvbmZsaWN0XCIgOiB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXh0cmFSZWR1Y2VyczogKGJ1aWxkZXIpID0+IHtcbiAgICAgIGJ1aWxkZXIuYWRkQ2FzZShvbk9ubGluZSwgKHN0YXRlKSA9PiB7XG4gICAgICAgIHN0YXRlLm9ubGluZSA9IHRydWU7XG4gICAgICB9KS5hZGRDYXNlKG9uT2ZmbGluZSwgKHN0YXRlKSA9PiB7XG4gICAgICAgIHN0YXRlLm9ubGluZSA9IGZhbHNlO1xuICAgICAgfSkuYWRkQ2FzZShvbkZvY3VzLCAoc3RhdGUpID0+IHtcbiAgICAgICAgc3RhdGUuZm9jdXNlZCA9IHRydWU7XG4gICAgICB9KS5hZGRDYXNlKG9uRm9jdXNMb3N0LCAoc3RhdGUpID0+IHtcbiAgICAgICAgc3RhdGUuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgfSkuYWRkTWF0Y2hlcihoYXNSZWh5ZHJhdGlvbkluZm8sIChkcmFmdCkgPT4gKHtcbiAgICAgICAgLi4uZHJhZnRcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBjb21iaW5lZFJlZHVjZXIgPSBjb21iaW5lUmVkdWNlcnMoe1xuICAgIHF1ZXJpZXM6IHF1ZXJ5U2xpY2UucmVkdWNlcixcbiAgICBtdXRhdGlvbnM6IG11dGF0aW9uU2xpY2UucmVkdWNlcixcbiAgICBwcm92aWRlZDogaW52YWxpZGF0aW9uU2xpY2UucmVkdWNlcixcbiAgICBzdWJzY3JpcHRpb25zOiBpbnRlcm5hbFN1YnNjcmlwdGlvbnNTbGljZS5yZWR1Y2VyLFxuICAgIGNvbmZpZzogY29uZmlnU2xpY2UucmVkdWNlclxuICB9KTtcbiAgY29uc3QgcmVkdWNlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiBjb21iaW5lZFJlZHVjZXIocmVzZXRBcGlTdGF0ZS5tYXRjaChhY3Rpb24pID8gdm9pZCAwIDogc3RhdGUsIGFjdGlvbik7XG4gIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgLi4uY29uZmlnU2xpY2UuYWN0aW9ucyxcbiAgICAuLi5xdWVyeVNsaWNlLmFjdGlvbnMsXG4gICAgLi4uc3Vic2NyaXB0aW9uU2xpY2UuYWN0aW9ucyxcbiAgICAuLi5pbnRlcm5hbFN1YnNjcmlwdGlvbnNTbGljZS5hY3Rpb25zLFxuICAgIC4uLm11dGF0aW9uU2xpY2UuYWN0aW9ucyxcbiAgICAuLi5pbnZhbGlkYXRpb25TbGljZS5hY3Rpb25zLFxuICAgIHJlc2V0QXBpU3RhdGVcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICByZWR1Y2VyLFxuICAgIGFjdGlvbnNcbiAgfTtcbn1cblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRTZWxlY3RvcnMudHNcbnZhciBza2lwVG9rZW4gPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcIlJUS1Evc2tpcFRva2VuXCIpO1xudmFyIGluaXRpYWxTdWJTdGF0ZSA9IHtcbiAgc3RhdHVzOiBcInVuaW5pdGlhbGl6ZWRcIiAvKiB1bmluaXRpYWxpemVkICovXG59O1xudmFyIGRlZmF1bHRRdWVyeVN1YlN0YXRlID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZU5leHRTdGF0ZShpbml0aWFsU3ViU3RhdGUsICgpID0+IHtcbn0pO1xudmFyIGRlZmF1bHRNdXRhdGlvblN1YlN0YXRlID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZU5leHRTdGF0ZShpbml0aWFsU3ViU3RhdGUsICgpID0+IHtcbn0pO1xuZnVuY3Rpb24gYnVpbGRTZWxlY3RvcnMoe1xuICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gIHJlZHVjZXJQYXRoLFxuICBjcmVhdGVTZWxlY3RvcjogY3JlYXRlU2VsZWN0b3IyXG59KSB7XG4gIGNvbnN0IHNlbGVjdFNraXBwZWRRdWVyeSA9IChzdGF0ZSkgPT4gZGVmYXVsdFF1ZXJ5U3ViU3RhdGU7XG4gIGNvbnN0IHNlbGVjdFNraXBwZWRNdXRhdGlvbiA9IChzdGF0ZSkgPT4gZGVmYXVsdE11dGF0aW9uU3ViU3RhdGU7XG4gIHJldHVybiB7XG4gICAgYnVpbGRRdWVyeVNlbGVjdG9yLFxuICAgIGJ1aWxkSW5maW5pdGVRdWVyeVNlbGVjdG9yLFxuICAgIGJ1aWxkTXV0YXRpb25TZWxlY3RvcixcbiAgICBzZWxlY3RJbnZhbGlkYXRlZEJ5LFxuICAgIHNlbGVjdENhY2hlZEFyZ3NGb3JRdWVyeSxcbiAgICBzZWxlY3RBcGlTdGF0ZSxcbiAgICBzZWxlY3RRdWVyaWVzLFxuICAgIHNlbGVjdE11dGF0aW9ucyxcbiAgICBzZWxlY3RRdWVyeUVudHJ5LFxuICAgIHNlbGVjdENvbmZpZ1xuICB9O1xuICBmdW5jdGlvbiB3aXRoUmVxdWVzdEZsYWdzKHN1YnN0YXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1YnN0YXRlLFxuICAgICAgLi4uZ2V0UmVxdWVzdFN0YXR1c0ZsYWdzKHN1YnN0YXRlLnN0YXR1cylcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdEFwaVN0YXRlKHJvb3RTdGF0ZSkge1xuICAgIGNvbnN0IHN0YXRlID0gcm9vdFN0YXRlW3JlZHVjZXJQYXRoXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgIGlmIChzZWxlY3RBcGlTdGF0ZS50cmlnZ2VyZWQpIHJldHVybiBzdGF0ZTtcbiAgICAgICAgc2VsZWN0QXBpU3RhdGUudHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3I6IE5vIGRhdGEgZm91bmQgYXQgXFxgc3RhdGUuJHtyZWR1Y2VyUGF0aH1cXGAuIERpZCB5b3UgZm9yZ2V0IHRvIGFkZCB0aGUgcmVkdWNlciB0byB0aGUgc3RvcmU/YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiBzZWxlY3RRdWVyaWVzKHJvb3RTdGF0ZSkge1xuICAgIHJldHVybiBzZWxlY3RBcGlTdGF0ZShyb290U3RhdGUpPy5xdWVyaWVzO1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdFF1ZXJ5RW50cnkocm9vdFN0YXRlLCBjYWNoZUtleSkge1xuICAgIHJldHVybiBzZWxlY3RRdWVyaWVzKHJvb3RTdGF0ZSk/LltjYWNoZUtleV07XG4gIH1cbiAgZnVuY3Rpb24gc2VsZWN0TXV0YXRpb25zKHJvb3RTdGF0ZSkge1xuICAgIHJldHVybiBzZWxlY3RBcGlTdGF0ZShyb290U3RhdGUpPy5tdXRhdGlvbnM7XG4gIH1cbiAgZnVuY3Rpb24gc2VsZWN0Q29uZmlnKHJvb3RTdGF0ZSkge1xuICAgIHJldHVybiBzZWxlY3RBcGlTdGF0ZShyb290U3RhdGUpPy5jb25maWc7XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRBbnlRdWVyeVNlbGVjdG9yKGVuZHBvaW50TmFtZSwgZW5kcG9pbnREZWZpbml0aW9uLCBjb21iaW5lcikge1xuICAgIHJldHVybiAocXVlcnlBcmdzKSA9PiB7XG4gICAgICBpZiAocXVlcnlBcmdzID09PSBza2lwVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTa2lwcGVkUXVlcnksIGNvbWJpbmVyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRBcmdzID0gc2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgICAgcXVlcnlBcmdzLFxuICAgICAgICBlbmRwb2ludERlZmluaXRpb24sXG4gICAgICAgIGVuZHBvaW50TmFtZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBzZWxlY3RRdWVyeVN1YnN0YXRlID0gKHN0YXRlKSA9PiBzZWxlY3RRdWVyeUVudHJ5KHN0YXRlLCBzZXJpYWxpemVkQXJncykgPz8gZGVmYXVsdFF1ZXJ5U3ViU3RhdGU7XG4gICAgICByZXR1cm4gY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFF1ZXJ5U3Vic3RhdGUsIGNvbWJpbmVyKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkUXVlcnlTZWxlY3RvcihlbmRwb2ludE5hbWUsIGVuZHBvaW50RGVmaW5pdGlvbikge1xuICAgIHJldHVybiBidWlsZEFueVF1ZXJ5U2VsZWN0b3IoZW5kcG9pbnROYW1lLCBlbmRwb2ludERlZmluaXRpb24sIHdpdGhSZXF1ZXN0RmxhZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkSW5maW5pdGVRdWVyeVNlbGVjdG9yKGVuZHBvaW50TmFtZSwgZW5kcG9pbnREZWZpbml0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgaW5maW5pdGVRdWVyeU9wdGlvbnNcbiAgICB9ID0gZW5kcG9pbnREZWZpbml0aW9uO1xuICAgIGZ1bmN0aW9uIHdpdGhJbmZpbml0ZVF1ZXJ5UmVzdWx0RmxhZ3Moc3Vic3RhdGUpIHtcbiAgICAgIGNvbnN0IHN0YXRlV2l0aFJlcXVlc3RGbGFncyA9IHtcbiAgICAgICAgLi4uc3Vic3RhdGUsXG4gICAgICAgIC4uLmdldFJlcXVlc3RTdGF0dXNGbGFncyhzdWJzdGF0ZS5zdGF0dXMpXG4gICAgICB9O1xuICAgICAgY29uc3Qge1xuICAgICAgICBpc0xvYWRpbmcsXG4gICAgICAgIGlzRXJyb3IsXG4gICAgICAgIGRpcmVjdGlvblxuICAgICAgfSA9IHN0YXRlV2l0aFJlcXVlc3RGbGFncztcbiAgICAgIGNvbnN0IGlzRm9yd2FyZCA9IGRpcmVjdGlvbiA9PT0gXCJmb3J3YXJkXCI7XG4gICAgICBjb25zdCBpc0JhY2t3YXJkID0gZGlyZWN0aW9uID09PSBcImJhY2t3YXJkXCI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZVdpdGhSZXF1ZXN0RmxhZ3MsXG4gICAgICAgIGhhc05leHRQYWdlOiBnZXRIYXNOZXh0UGFnZShpbmZpbml0ZVF1ZXJ5T3B0aW9ucywgc3RhdGVXaXRoUmVxdWVzdEZsYWdzLmRhdGEpLFxuICAgICAgICBoYXNQcmV2aW91c1BhZ2U6IGdldEhhc1ByZXZpb3VzUGFnZShpbmZpbml0ZVF1ZXJ5T3B0aW9ucywgc3RhdGVXaXRoUmVxdWVzdEZsYWdzLmRhdGEpLFxuICAgICAgICBpc0ZldGNoaW5nTmV4dFBhZ2U6IGlzTG9hZGluZyAmJiBpc0ZvcndhcmQsXG4gICAgICAgIGlzRmV0Y2hpbmdQcmV2aW91c1BhZ2U6IGlzTG9hZGluZyAmJiBpc0JhY2t3YXJkLFxuICAgICAgICBpc0ZldGNoTmV4dFBhZ2VFcnJvcjogaXNFcnJvciAmJiBpc0ZvcndhcmQsXG4gICAgICAgIGlzRmV0Y2hQcmV2aW91c1BhZ2VFcnJvcjogaXNFcnJvciAmJiBpc0JhY2t3YXJkXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYnVpbGRBbnlRdWVyeVNlbGVjdG9yKGVuZHBvaW50TmFtZSwgZW5kcG9pbnREZWZpbml0aW9uLCB3aXRoSW5maW5pdGVRdWVyeVJlc3VsdEZsYWdzKTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZE11dGF0aW9uU2VsZWN0b3IoKSB7XG4gICAgcmV0dXJuIChpZCkgPT4ge1xuICAgICAgbGV0IG11dGF0aW9uSWQ7XG4gICAgICBpZiAodHlwZW9mIGlkID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG11dGF0aW9uSWQgPSBnZXRNdXRhdGlvbkNhY2hlS2V5KGlkKSA/PyBza2lwVG9rZW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdXRhdGlvbklkID0gaWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBzZWxlY3RNdXRhdGlvblN1YnN0YXRlID0gKHN0YXRlKSA9PiBzZWxlY3RBcGlTdGF0ZShzdGF0ZSk/Lm11dGF0aW9ucz8uW211dGF0aW9uSWRdID8/IGRlZmF1bHRNdXRhdGlvblN1YlN0YXRlO1xuICAgICAgY29uc3QgZmluYWxTZWxlY3RNdXRhdGlvblN1YnN0YXRlID0gbXV0YXRpb25JZCA9PT0gc2tpcFRva2VuID8gc2VsZWN0U2tpcHBlZE11dGF0aW9uIDogc2VsZWN0TXV0YXRpb25TdWJzdGF0ZTtcbiAgICAgIHJldHVybiBjcmVhdGVTZWxlY3RvcjIoZmluYWxTZWxlY3RNdXRhdGlvblN1YnN0YXRlLCB3aXRoUmVxdWVzdEZsYWdzKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdEludmFsaWRhdGVkQnkoc3RhdGUsIHRhZ3MpIHtcbiAgICBjb25zdCBhcGlTdGF0ZSA9IHN0YXRlW3JlZHVjZXJQYXRoXTtcbiAgICBjb25zdCB0b0ludmFsaWRhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MuZmlsdGVyKGlzTm90TnVsbGlzaCkubWFwKGV4cGFuZFRhZ0Rlc2NyaXB0aW9uKSkge1xuICAgICAgY29uc3QgcHJvdmlkZWQgPSBhcGlTdGF0ZS5wcm92aWRlZFt0YWcudHlwZV07XG4gICAgICBpZiAoIXByb3ZpZGVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IGludmFsaWRhdGVTdWJzY3JpcHRpb25zID0gKHRhZy5pZCAhPT0gdm9pZCAwID8gKFxuICAgICAgICAvLyBpZCBnaXZlbjogaW52YWxpZGF0ZSBhbGwgcXVlcmllcyB0aGF0IHByb3ZpZGUgdGhpcyB0eXBlICYgaWRcbiAgICAgICAgcHJvdmlkZWRbdGFnLmlkXVxuICAgICAgKSA6IChcbiAgICAgICAgLy8gbm8gaWQ6IGludmFsaWRhdGUgYWxsIHF1ZXJpZXMgdGhhdCBwcm92aWRlIHRoaXMgdHlwZVxuICAgICAgICBmbGF0dGVuKE9iamVjdC52YWx1ZXMocHJvdmlkZWQpKVxuICAgICAgKSkgPz8gW107XG4gICAgICBmb3IgKGNvbnN0IGludmFsaWRhdGUgb2YgaW52YWxpZGF0ZVN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgdG9JbnZhbGlkYXRlLmFkZChpbnZhbGlkYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZsYXR0ZW4oQXJyYXkuZnJvbSh0b0ludmFsaWRhdGUudmFsdWVzKCkpLm1hcCgocXVlcnlDYWNoZUtleSkgPT4ge1xuICAgICAgY29uc3QgcXVlcnlTdWJTdGF0ZSA9IGFwaVN0YXRlLnF1ZXJpZXNbcXVlcnlDYWNoZUtleV07XG4gICAgICByZXR1cm4gcXVlcnlTdWJTdGF0ZSA/IFt7XG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgIGVuZHBvaW50TmFtZTogcXVlcnlTdWJTdGF0ZS5lbmRwb2ludE5hbWUsXG4gICAgICAgIG9yaWdpbmFsQXJnczogcXVlcnlTdWJTdGF0ZS5vcmlnaW5hbEFyZ3NcbiAgICAgIH1dIDogW107XG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdENhY2hlZEFyZ3NGb3JRdWVyeShzdGF0ZSwgcXVlcnlOYW1lKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoc2VsZWN0UXVlcmllcyhzdGF0ZSkpLmZpbHRlcigoZW50cnkpID0+IGVudHJ5Py5lbmRwb2ludE5hbWUgPT09IHF1ZXJ5TmFtZSAmJiBlbnRyeS5zdGF0dXMgIT09IFwidW5pbml0aWFsaXplZFwiIC8qIHVuaW5pdGlhbGl6ZWQgKi8pLm1hcCgoZW50cnkpID0+IGVudHJ5Lm9yaWdpbmFsQXJncyk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SGFzTmV4dFBhZ2Uob3B0aW9ucywgZGF0YSkge1xuICAgIGlmICghZGF0YSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBnZXROZXh0UGFnZVBhcmFtKG9wdGlvbnMsIGRhdGEpICE9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SGFzUHJldmlvdXNQYWdlKG9wdGlvbnMsIGRhdGEpIHtcbiAgICBpZiAoIWRhdGEgfHwgIW9wdGlvbnMuZ2V0UHJldmlvdXNQYWdlUGFyYW0pIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gZ2V0UHJldmlvdXNQYWdlUGFyYW0ob3B0aW9ucywgZGF0YSkgIT0gbnVsbDtcbiAgfVxufVxuXG4vLyBzcmMvcXVlcnkvY3JlYXRlQXBpLnRzXG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMiwgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIyLCBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMyB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5cbi8vIHNyYy9xdWVyeS9kZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzLnRzXG52YXIgY2FjaGUgPSBXZWFrTWFwID8gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkgOiB2b2lkIDA7XG52YXIgZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncyA9ICh7XG4gIGVuZHBvaW50TmFtZSxcbiAgcXVlcnlBcmdzXG59KSA9PiB7XG4gIGxldCBzZXJpYWxpemVkID0gXCJcIjtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGU/LmdldChxdWVyeUFyZ3MpO1xuICBpZiAodHlwZW9mIGNhY2hlZCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHNlcmlhbGl6ZWQgPSBjYWNoZWQ7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc3RyaW5naWZpZWQgPSBKU09OLnN0cmluZ2lmeShxdWVyeUFyZ3MsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICB2YWx1ZSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIiA/IHtcbiAgICAgICAgJGJpZ2ludDogdmFsdWUudG9TdHJpbmcoKVxuICAgICAgfSA6IHZhbHVlO1xuICAgICAgdmFsdWUgPSBpc1BsYWluT2JqZWN0KHZhbHVlKSA/IE9iamVjdC5rZXlzKHZhbHVlKS5zb3J0KCkucmVkdWNlKChhY2MsIGtleTIpID0+IHtcbiAgICAgICAgYWNjW2tleTJdID0gdmFsdWVba2V5Ml07XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSkgOiB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChxdWVyeUFyZ3MpKSB7XG4gICAgICBjYWNoZT8uc2V0KHF1ZXJ5QXJncywgc3RyaW5naWZpZWQpO1xuICAgIH1cbiAgICBzZXJpYWxpemVkID0gc3RyaW5naWZpZWQ7XG4gIH1cbiAgcmV0dXJuIGAke2VuZHBvaW50TmFtZX0oJHtzZXJpYWxpemVkfSlgO1xufTtcblxuLy8gc3JjL3F1ZXJ5L2NyZWF0ZUFwaS50c1xuaW1wb3J0IHsgd2Vha01hcE1lbW9pemUgfSBmcm9tIFwicmVzZWxlY3RcIjtcbmZ1bmN0aW9uIGJ1aWxkQ3JlYXRlQXBpKC4uLm1vZHVsZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJhc2VDcmVhdGVBcGkob3B0aW9ucykge1xuICAgIGNvbnN0IGV4dHJhY3RSZWh5ZHJhdGlvbkluZm8gPSB3ZWFrTWFwTWVtb2l6ZSgoYWN0aW9uKSA9PiBvcHRpb25zLmV4dHJhY3RSZWh5ZHJhdGlvbkluZm8/LihhY3Rpb24sIHtcbiAgICAgIHJlZHVjZXJQYXRoOiBvcHRpb25zLnJlZHVjZXJQYXRoID8/IFwiYXBpXCJcbiAgICB9KSk7XG4gICAgY29uc3Qgb3B0aW9uc1dpdGhEZWZhdWx0cyA9IHtcbiAgICAgIHJlZHVjZXJQYXRoOiBcImFwaVwiLFxuICAgICAga2VlcFVudXNlZERhdGFGb3I6IDYwLFxuICAgICAgcmVmZXRjaE9uTW91bnRPckFyZ0NoYW5nZTogZmFsc2UsXG4gICAgICByZWZldGNoT25Gb2N1czogZmFsc2UsXG4gICAgICByZWZldGNoT25SZWNvbm5lY3Q6IGZhbHNlLFxuICAgICAgaW52YWxpZGF0aW9uQmVoYXZpb3I6IFwiZGVsYXllZFwiLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGV4dHJhY3RSZWh5ZHJhdGlvbkluZm8sXG4gICAgICBzZXJpYWxpemVRdWVyeUFyZ3MocXVlcnlBcmdzQXBpKSB7XG4gICAgICAgIGxldCBmaW5hbFNlcmlhbGl6ZVF1ZXJ5QXJncyA9IGRlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3M7XG4gICAgICAgIGlmIChcInNlcmlhbGl6ZVF1ZXJ5QXJnc1wiIGluIHF1ZXJ5QXJnc0FwaS5lbmRwb2ludERlZmluaXRpb24pIHtcbiAgICAgICAgICBjb25zdCBlbmRwb2ludFNRQSA9IHF1ZXJ5QXJnc0FwaS5lbmRwb2ludERlZmluaXRpb24uc2VyaWFsaXplUXVlcnlBcmdzO1xuICAgICAgICAgIGZpbmFsU2VyaWFsaXplUXVlcnlBcmdzID0gKHF1ZXJ5QXJnc0FwaTIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxSZXN1bHQgPSBlbmRwb2ludFNRQShxdWVyeUFyZ3NBcGkyKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5pdGlhbFJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICByZXR1cm4gaW5pdGlhbFJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgICAgICAgICAgICAuLi5xdWVyeUFyZ3NBcGkyLFxuICAgICAgICAgICAgICAgIHF1ZXJ5QXJnczogaW5pdGlhbFJlc3VsdFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2VyaWFsaXplUXVlcnlBcmdzKSB7XG4gICAgICAgICAgZmluYWxTZXJpYWxpemVRdWVyeUFyZ3MgPSBvcHRpb25zLnNlcmlhbGl6ZVF1ZXJ5QXJncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluYWxTZXJpYWxpemVRdWVyeUFyZ3MocXVlcnlBcmdzQXBpKTtcbiAgICAgIH0sXG4gICAgICB0YWdUeXBlczogWy4uLm9wdGlvbnMudGFnVHlwZXMgfHwgW11dXG4gICAgfTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgZW5kcG9pbnREZWZpbml0aW9uczoge30sXG4gICAgICBiYXRjaChmbikge1xuICAgICAgICBmbigpO1xuICAgICAgfSxcbiAgICAgIGFwaVVpZDogbmFub2lkKCksXG4gICAgICBleHRyYWN0UmVoeWRyYXRpb25JbmZvLFxuICAgICAgaGFzUmVoeWRyYXRpb25JbmZvOiB3ZWFrTWFwTWVtb2l6ZSgoYWN0aW9uKSA9PiBleHRyYWN0UmVoeWRyYXRpb25JbmZvKGFjdGlvbikgIT0gbnVsbClcbiAgICB9O1xuICAgIGNvbnN0IGFwaSA9IHtcbiAgICAgIGluamVjdEVuZHBvaW50cyxcbiAgICAgIGVuaGFuY2VFbmRwb2ludHMoe1xuICAgICAgICBhZGRUYWdUeXBlcyxcbiAgICAgICAgZW5kcG9pbnRzXG4gICAgICB9KSB7XG4gICAgICAgIGlmIChhZGRUYWdUeXBlcykge1xuICAgICAgICAgIGZvciAoY29uc3QgZVQgb2YgYWRkVGFnVHlwZXMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9uc1dpdGhEZWZhdWx0cy50YWdUeXBlcy5pbmNsdWRlcyhlVCkpIHtcbiAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICBvcHRpb25zV2l0aERlZmF1bHRzLnRhZ1R5cGVzLnB1c2goZVQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kcG9pbnRzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBbZW5kcG9pbnROYW1lLCBwYXJ0aWFsRGVmaW5pdGlvbl0gb2YgT2JqZWN0LmVudHJpZXMoZW5kcG9pbnRzKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0aWFsRGVmaW5pdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHBhcnRpYWxEZWZpbml0aW9uKGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZV0gfHwge30sIHBhcnRpYWxEZWZpbml0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwaTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGluaXRpYWxpemVkTW9kdWxlcyA9IG1vZHVsZXMubWFwKChtKSA9PiBtLmluaXQoYXBpLCBvcHRpb25zV2l0aERlZmF1bHRzLCBjb250ZXh0KSk7XG4gICAgZnVuY3Rpb24gaW5qZWN0RW5kcG9pbnRzKGluamVjdCkge1xuICAgICAgY29uc3QgZXZhbHVhdGVkRW5kcG9pbnRzID0gaW5qZWN0LmVuZHBvaW50cyh7XG4gICAgICAgIHF1ZXJ5OiAoeCkgPT4gKHtcbiAgICAgICAgICAuLi54LFxuICAgICAgICAgIHR5cGU6IFwicXVlcnlcIiAvKiBxdWVyeSAqL1xuICAgICAgICB9KSxcbiAgICAgICAgbXV0YXRpb246ICh4KSA9PiAoe1xuICAgICAgICAgIC4uLngsXG4gICAgICAgICAgdHlwZTogXCJtdXRhdGlvblwiIC8qIG11dGF0aW9uICovXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZpbml0ZVF1ZXJ5OiAoeCkgPT4gKHtcbiAgICAgICAgICAuLi54LFxuICAgICAgICAgIHR5cGU6IFwiaW5maW5pdGVxdWVyeVwiIC8qIGluZmluaXRlcXVlcnkgKi9cbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgZm9yIChjb25zdCBbZW5kcG9pbnROYW1lLCBkZWZpbml0aW9uXSBvZiBPYmplY3QuZW50cmllcyhldmFsdWF0ZWRFbmRwb2ludHMpKSB7XG4gICAgICAgIGlmIChpbmplY3Qub3ZlcnJpZGVFeGlzdGluZyAhPT0gdHJ1ZSAmJiBlbmRwb2ludE5hbWUgaW4gY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zKSB7XG4gICAgICAgICAgaWYgKGluamVjdC5vdmVycmlkZUV4aXN0aW5nID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIoMzkpIDogYGNhbGxlZCBcXGBpbmplY3RFbmRwb2ludHNcXGAgdG8gb3ZlcnJpZGUgYWxyZWFkeS1leGlzdGluZyBlbmRwb2ludE5hbWUgJHtlbmRwb2ludE5hbWV9IHdpdGhvdXQgc3BlY2lmeWluZyBcXGBvdmVycmlkZUV4aXN0aW5nOiB0cnVlXFxgYCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBjYWxsZWQgXFxgaW5qZWN0RW5kcG9pbnRzXFxgIHRvIG92ZXJyaWRlIGFscmVhZHktZXhpc3RpbmcgZW5kcG9pbnROYW1lICR7ZW5kcG9pbnROYW1lfSB3aXRob3V0IHNwZWNpZnlpbmcgXFxgb3ZlcnJpZGVFeGlzdGluZzogdHJ1ZVxcYGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgIGlmIChpc0luZmluaXRlUXVlcnlEZWZpbml0aW9uKGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGluZmluaXRlUXVlcnlPcHRpb25zXG4gICAgICAgICAgICB9ID0gZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgbWF4UGFnZXMsXG4gICAgICAgICAgICAgIGdldFByZXZpb3VzUGFnZVBhcmFtOiBnZXRQcmV2aW91c1BhZ2VQYXJhbTJcbiAgICAgICAgICAgIH0gPSBpbmZpbml0ZVF1ZXJ5T3B0aW9ucztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWF4UGFnZXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgaWYgKG1heFBhZ2VzIDwgMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIyKDQwKSA6IGBtYXhQYWdlcyBmb3IgZW5kcG9pbnQgJyR7ZW5kcG9pbnROYW1lfScgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMGApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZ2V0UHJldmlvdXNQYWdlUGFyYW0yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UzKDQxKSA6IGBnZXRQcmV2aW91c1BhZ2VQYXJhbSBmb3IgZW5kcG9pbnQgJyR7ZW5kcG9pbnROYW1lfScgbXVzdCBiZSBhIGZ1bmN0aW9uIGlmIG1heFBhZ2VzIGlzIHVzZWRgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXSA9IGRlZmluaXRpb247XG4gICAgICAgIGZvciAoY29uc3QgbSBvZiBpbml0aWFsaXplZE1vZHVsZXMpIHtcbiAgICAgICAgICBtLmluamVjdEVuZHBvaW50KGVuZHBvaW50TmFtZSwgZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcGk7XG4gICAgfVxuICAgIHJldHVybiBhcGkuaW5qZWN0RW5kcG9pbnRzKHtcbiAgICAgIGVuZHBvaW50czogb3B0aW9ucy5lbmRwb2ludHNcbiAgICB9KTtcbiAgfTtcbn1cblxuLy8gc3JjL3F1ZXJ5L2Zha2VCYXNlUXVlcnkudHNcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U0IH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbnZhciBfTkVWRVIgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKCk7XG5mdW5jdGlvbiBmYWtlQmFzZVF1ZXJ5KCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNCgzMykgOiBcIldoZW4gdXNpbmcgYGZha2VCYXNlUXVlcnlgLCBhbGwgcXVlcmllcyAmIG11dGF0aW9ucyBtdXN0IHVzZSB0aGUgYHF1ZXJ5Rm5gIGRlZmluaXRpb24gc3ludGF4LlwiKTtcbiAgfTtcbn1cblxuLy8gc3JjL3F1ZXJ5L2NvcmUvbW9kdWxlLnRzXG5pbXBvcnQgeyBlbmFibGVQYXRjaGVzIH0gZnJvbSBcImltbWVyXCI7XG5cbi8vIHNyYy9xdWVyeS90c0hlbHBlcnMudHNcbmZ1bmN0aW9uIGFzc2VydENhc3Qodikge1xufVxuZnVuY3Rpb24gc2FmZUFzc2lnbih0YXJnZXQsIC4uLmFyZ3MpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGFyZ2V0LCAuLi5hcmdzKTtcbn1cblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL2JhdGNoQWN0aW9ucy50c1xuaW1wb3J0IHsgcHJvZHVjZVdpdGhQYXRjaGVzIGFzIHByb2R1Y2VXaXRoUGF0Y2hlczIgfSBmcm9tIFwiaW1tZXJcIjtcbnZhciBidWlsZEJhdGNoZWRBY3Rpb25zSGFuZGxlciA9ICh7XG4gIGFwaSxcbiAgcXVlcnlUaHVuayxcbiAgaW50ZXJuYWxTdGF0ZVxufSkgPT4ge1xuICBjb25zdCBzdWJzY3JpcHRpb25zUHJlZml4ID0gYCR7YXBpLnJlZHVjZXJQYXRofS9zdWJzY3JpcHRpb25zYDtcbiAgbGV0IHByZXZpb3VzU3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gIGxldCB1cGRhdGVTeW5jVGltZXIgPSBudWxsO1xuICBjb25zdCB7XG4gICAgdXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9ucyxcbiAgICB1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0XG4gIH0gPSBhcGkuaW50ZXJuYWxBY3Rpb25zO1xuICBjb25zdCBhY3R1YWxseU11dGF0ZVN1YnNjcmlwdGlvbnMgPSAobXV0YWJsZVN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICBpZiAodXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9ucy5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgaWYgKG11dGFibGVTdGF0ZT8uW3F1ZXJ5Q2FjaGVLZXldPy5bcmVxdWVzdElkXSkge1xuICAgICAgICBtdXRhYmxlU3RhdGVbcXVlcnlDYWNoZUtleV1bcmVxdWVzdElkXSA9IG9wdGlvbnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHVuc3Vic2NyaWJlUXVlcnlSZXN1bHQubWF0Y2goYWN0aW9uKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgICByZXF1ZXN0SWRcbiAgICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgIGlmIChtdXRhYmxlU3RhdGVbcXVlcnlDYWNoZUtleV0pIHtcbiAgICAgICAgZGVsZXRlIG11dGFibGVTdGF0ZVtxdWVyeUNhY2hlS2V5XVtyZXF1ZXN0SWRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChhcGkuaW50ZXJuYWxBY3Rpb25zLnJlbW92ZVF1ZXJ5UmVzdWx0Lm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGRlbGV0ZSBtdXRhYmxlU3RhdGVbYWN0aW9uLnBheWxvYWQucXVlcnlDYWNoZUtleV07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5VGh1bmsucGVuZGluZy5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1ldGE6IHtcbiAgICAgICAgICBhcmcsXG4gICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgIH1cbiAgICAgIH0gPSBhY3Rpb247XG4gICAgICBjb25zdCBzdWJzdGF0ZSA9IG11dGFibGVTdGF0ZVthcmcucXVlcnlDYWNoZUtleV0gPz89IHt9O1xuICAgICAgc3Vic3RhdGVbYCR7cmVxdWVzdElkfV9ydW5uaW5nYF0gPSB7fTtcbiAgICAgIGlmIChhcmcuc3Vic2NyaWJlKSB7XG4gICAgICAgIHN1YnN0YXRlW3JlcXVlc3RJZF0gPSBhcmcuc3Vic2NyaXB0aW9uT3B0aW9ucyA/PyBzdWJzdGF0ZVtyZXF1ZXN0SWRdID8/IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBtdXRhdGVkID0gZmFsc2U7XG4gICAgaWYgKHF1ZXJ5VGh1bmsuZnVsZmlsbGVkLm1hdGNoKGFjdGlvbikgfHwgcXVlcnlUaHVuay5yZWplY3RlZC5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IG11dGFibGVTdGF0ZVthY3Rpb24ubWV0YS5hcmcucXVlcnlDYWNoZUtleV0gfHwge307XG4gICAgICBjb25zdCBrZXkgPSBgJHthY3Rpb24ubWV0YS5yZXF1ZXN0SWR9X3J1bm5pbmdgO1xuICAgICAgbXV0YXRlZCB8fD0gISFzdGF0ZVtrZXldO1xuICAgICAgZGVsZXRlIHN0YXRlW2tleV07XG4gICAgfVxuICAgIGlmIChxdWVyeVRodW5rLnJlamVjdGVkLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgIGNvbmRpdGlvbixcbiAgICAgICAgICBhcmcsXG4gICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgIH1cbiAgICAgIH0gPSBhY3Rpb247XG4gICAgICBpZiAoY29uZGl0aW9uICYmIGFyZy5zdWJzY3JpYmUpIHtcbiAgICAgICAgY29uc3Qgc3Vic3RhdGUgPSBtdXRhYmxlU3RhdGVbYXJnLnF1ZXJ5Q2FjaGVLZXldID8/PSB7fTtcbiAgICAgICAgc3Vic3RhdGVbcmVxdWVzdElkXSA9IGFyZy5zdWJzY3JpcHRpb25PcHRpb25zID8/IHN1YnN0YXRlW3JlcXVlc3RJZF0gPz8ge307XG4gICAgICAgIG11dGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbXV0YXRlZDtcbiAgfTtcbiAgY29uc3QgZ2V0U3Vic2NyaXB0aW9ucyA9ICgpID0+IGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnM7XG4gIGNvbnN0IGdldFN1YnNjcmlwdGlvbkNvdW50ID0gKHF1ZXJ5Q2FjaGVLZXkpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gZ2V0U3Vic2NyaXB0aW9ucygpO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnNGb3JRdWVyeUFyZyA9IHN1YnNjcmlwdGlvbnNbcXVlcnlDYWNoZUtleV0gPz8ge307XG4gICAgcmV0dXJuIGNvdW50T2JqZWN0S2V5cyhzdWJzY3JpcHRpb25zRm9yUXVlcnlBcmcpO1xuICB9O1xuICBjb25zdCBpc1JlcXVlc3RTdWJzY3JpYmVkID0gKHF1ZXJ5Q2FjaGVLZXksIHJlcXVlc3RJZCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBnZXRTdWJzY3JpcHRpb25zKCk7XG4gICAgcmV0dXJuICEhc3Vic2NyaXB0aW9ucz8uW3F1ZXJ5Q2FjaGVLZXldPy5bcmVxdWVzdElkXTtcbiAgfTtcbiAgY29uc3Qgc3Vic2NyaXB0aW9uU2VsZWN0b3JzID0ge1xuICAgIGdldFN1YnNjcmlwdGlvbnMsXG4gICAgZ2V0U3Vic2NyaXB0aW9uQ291bnQsXG4gICAgaXNSZXF1ZXN0U3Vic2NyaWJlZFxuICB9O1xuICByZXR1cm4gKGFjdGlvbiwgbXdBcGkpID0+IHtcbiAgICBpZiAoIXByZXZpb3VzU3Vic2NyaXB0aW9ucykge1xuICAgICAgcHJldmlvdXNTdWJzY3JpcHRpb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbnRlcm5hbFN0YXRlLmN1cnJlbnRTdWJzY3JpcHRpb25zKSk7XG4gICAgfVxuICAgIGlmIChhcGkudXRpbC5yZXNldEFwaVN0YXRlLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHByZXZpb3VzU3Vic2NyaXB0aW9ucyA9IGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnMgPSB7fTtcbiAgICAgIHVwZGF0ZVN5bmNUaW1lciA9IG51bGw7XG4gICAgICByZXR1cm4gW3RydWUsIGZhbHNlXTtcbiAgICB9XG4gICAgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMuaW50ZXJuYWxfZ2V0UlRLUVN1YnNjcmlwdGlvbnMubWF0Y2goYWN0aW9uKSkge1xuICAgICAgcmV0dXJuIFtmYWxzZSwgc3Vic2NyaXB0aW9uU2VsZWN0b3JzXTtcbiAgICB9XG4gICAgY29uc3QgZGlkTXV0YXRlID0gYWN0dWFsbHlNdXRhdGVTdWJzY3JpcHRpb25zKGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnMsIGFjdGlvbik7XG4gICAgbGV0IGFjdGlvblNob3VsZENvbnRpbnVlID0gdHJ1ZTtcbiAgICBpZiAoZGlkTXV0YXRlKSB7XG4gICAgICBpZiAoIXVwZGF0ZVN5bmNUaW1lcikge1xuICAgICAgICB1cGRhdGVTeW5jVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjb25zdCBuZXdTdWJzY3JpcHRpb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbnRlcm5hbFN0YXRlLmN1cnJlbnRTdWJzY3JpcHRpb25zKSk7XG4gICAgICAgICAgY29uc3QgWywgcGF0Y2hlc10gPSBwcm9kdWNlV2l0aFBhdGNoZXMyKHByZXZpb3VzU3Vic2NyaXB0aW9ucywgKCkgPT4gbmV3U3Vic2NyaXB0aW9ucyk7XG4gICAgICAgICAgbXdBcGkubmV4dChhcGkuaW50ZXJuYWxBY3Rpb25zLnN1YnNjcmlwdGlvbnNVcGRhdGVkKHBhdGNoZXMpKTtcbiAgICAgICAgICBwcmV2aW91c1N1YnNjcmlwdGlvbnMgPSBuZXdTdWJzY3JpcHRpb25zO1xuICAgICAgICAgIHVwZGF0ZVN5bmNUaW1lciA9IG51bGw7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpc1N1YnNjcmlwdGlvblNsaWNlQWN0aW9uID0gdHlwZW9mIGFjdGlvbi50eXBlID09IFwic3RyaW5nXCIgJiYgISFhY3Rpb24udHlwZS5zdGFydHNXaXRoKHN1YnNjcmlwdGlvbnNQcmVmaXgpO1xuICAgICAgY29uc3QgaXNBZGRpdGlvbmFsU3Vic2NyaXB0aW9uQWN0aW9uID0gcXVlcnlUaHVuay5yZWplY3RlZC5tYXRjaChhY3Rpb24pICYmIGFjdGlvbi5tZXRhLmNvbmRpdGlvbiAmJiAhIWFjdGlvbi5tZXRhLmFyZy5zdWJzY3JpYmU7XG4gICAgICBhY3Rpb25TaG91bGRDb250aW51ZSA9ICFpc1N1YnNjcmlwdGlvblNsaWNlQWN0aW9uICYmICFpc0FkZGl0aW9uYWxTdWJzY3JpcHRpb25BY3Rpb247XG4gICAgfVxuICAgIHJldHVybiBbYWN0aW9uU2hvdWxkQ29udGludWUsIGZhbHNlXTtcbiAgfTtcbn07XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9jYWNoZUNvbGxlY3Rpb24udHNcbmZ1bmN0aW9uIGlzT2JqZWN0RW1wdHkob2JqKSB7XG4gIGZvciAoY29uc3QgayBpbiBvYmopIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG52YXIgVEhJUlRZX1RXT19CSVRfTUFYX1RJTUVSX1NFQ09ORFMgPSAyMTQ3NDgzNjQ3IC8gMWUzIC0gMTtcbnZhciBidWlsZENhY2hlQ29sbGVjdGlvbkhhbmRsZXIgPSAoe1xuICByZWR1Y2VyUGF0aCxcbiAgYXBpLFxuICBxdWVyeVRodW5rLFxuICBjb250ZXh0LFxuICBpbnRlcm5hbFN0YXRlLFxuICBzZWxlY3RvcnM6IHtcbiAgICBzZWxlY3RRdWVyeUVudHJ5LFxuICAgIHNlbGVjdENvbmZpZ1xuICB9XG59KSA9PiB7XG4gIGNvbnN0IHtcbiAgICByZW1vdmVRdWVyeVJlc3VsdCxcbiAgICB1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0LFxuICAgIGNhY2hlRW50cmllc1Vwc2VydGVkXG4gIH0gPSBhcGkuaW50ZXJuYWxBY3Rpb25zO1xuICBjb25zdCBjYW5UcmlnZ2VyVW5zdWJzY3JpYmUgPSBpc0FueU9mKHVuc3Vic2NyaWJlUXVlcnlSZXN1bHQubWF0Y2gsIHF1ZXJ5VGh1bmsuZnVsZmlsbGVkLCBxdWVyeVRodW5rLnJlamVjdGVkLCBjYWNoZUVudHJpZXNVcHNlcnRlZC5tYXRjaCk7XG4gIGZ1bmN0aW9uIGFueVN1YnNjcmlwdGlvbnNSZW1haW5pbmdGb3JLZXkocXVlcnlDYWNoZUtleSkge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBpbnRlcm5hbFN0YXRlLmN1cnJlbnRTdWJzY3JpcHRpb25zW3F1ZXJ5Q2FjaGVLZXldO1xuICAgIHJldHVybiAhIXN1YnNjcmlwdGlvbnMgJiYgIWlzT2JqZWN0RW1wdHkoc3Vic2NyaXB0aW9ucyk7XG4gIH1cbiAgY29uc3QgY3VycmVudFJlbW92YWxUaW1lb3V0cyA9IHt9O1xuICBjb25zdCBoYW5kbGVyID0gKGFjdGlvbiwgbXdBcGksIGludGVybmFsU3RhdGUyKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBtd0FwaS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHNlbGVjdENvbmZpZyhzdGF0ZSk7XG4gICAgaWYgKGNhblRyaWdnZXJVbnN1YnNjcmliZShhY3Rpb24pKSB7XG4gICAgICBsZXQgcXVlcnlDYWNoZUtleXM7XG4gICAgICBpZiAoY2FjaGVFbnRyaWVzVXBzZXJ0ZWQubWF0Y2goYWN0aW9uKSkge1xuICAgICAgICBxdWVyeUNhY2hlS2V5cyA9IGFjdGlvbi5wYXlsb2FkLm1hcCgoZW50cnkpID0+IGVudHJ5LnF1ZXJ5RGVzY3JpcHRpb24ucXVlcnlDYWNoZUtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcXVlcnlDYWNoZUtleVxuICAgICAgICB9ID0gdW5zdWJzY3JpYmVRdWVyeVJlc3VsdC5tYXRjaChhY3Rpb24pID8gYWN0aW9uLnBheWxvYWQgOiBhY3Rpb24ubWV0YS5hcmc7XG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXlzID0gW3F1ZXJ5Q2FjaGVLZXldO1xuICAgICAgfVxuICAgICAgaGFuZGxlVW5zdWJzY3JpYmVNYW55KHF1ZXJ5Q2FjaGVLZXlzLCBtd0FwaSwgY29uZmlnKTtcbiAgICB9XG4gICAgaWYgKGFwaS51dGlsLnJlc2V0QXBpU3RhdGUubWF0Y2goYWN0aW9uKSkge1xuICAgICAgZm9yIChjb25zdCBba2V5LCB0aW1lb3V0XSBvZiBPYmplY3QuZW50cmllcyhjdXJyZW50UmVtb3ZhbFRpbWVvdXRzKSkge1xuICAgICAgICBpZiAodGltZW91dCkgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBkZWxldGUgY3VycmVudFJlbW92YWxUaW1lb3V0c1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGV4dC5oYXNSZWh5ZHJhdGlvbkluZm8oYWN0aW9uKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBxdWVyaWVzXG4gICAgICB9ID0gY29udGV4dC5leHRyYWN0UmVoeWRyYXRpb25JbmZvKGFjdGlvbik7XG4gICAgICBoYW5kbGVVbnN1YnNjcmliZU1hbnkoT2JqZWN0LmtleXMocXVlcmllcyksIG13QXBpLCBjb25maWcpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gaGFuZGxlVW5zdWJzY3JpYmVNYW55KGNhY2hlS2V5cywgYXBpMiwgY29uZmlnKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBhcGkyLmdldFN0YXRlKCk7XG4gICAgZm9yIChjb25zdCBxdWVyeUNhY2hlS2V5IG9mIGNhY2hlS2V5cykge1xuICAgICAgY29uc3QgZW50cnkgPSBzZWxlY3RRdWVyeUVudHJ5KHN0YXRlLCBxdWVyeUNhY2hlS2V5KTtcbiAgICAgIGhhbmRsZVVuc3Vic2NyaWJlKHF1ZXJ5Q2FjaGVLZXksIGVudHJ5Py5lbmRwb2ludE5hbWUsIGFwaTIsIGNvbmZpZyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVVuc3Vic2NyaWJlKHF1ZXJ5Q2FjaGVLZXksIGVuZHBvaW50TmFtZSwgYXBpMiwgY29uZmlnKSB7XG4gICAgY29uc3QgZW5kcG9pbnREZWZpbml0aW9uID0gY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZV07XG4gICAgY29uc3Qga2VlcFVudXNlZERhdGFGb3IgPSBlbmRwb2ludERlZmluaXRpb24/LmtlZXBVbnVzZWREYXRhRm9yID8/IGNvbmZpZy5rZWVwVW51c2VkRGF0YUZvcjtcbiAgICBpZiAoa2VlcFVudXNlZERhdGFGb3IgPT09IEluZmluaXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZpbmFsS2VlcFVudXNlZERhdGFGb3IgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihrZWVwVW51c2VkRGF0YUZvciwgVEhJUlRZX1RXT19CSVRfTUFYX1RJTUVSX1NFQ09ORFMpKTtcbiAgICBpZiAoIWFueVN1YnNjcmlwdGlvbnNSZW1haW5pbmdGb3JLZXkocXVlcnlDYWNoZUtleSkpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lb3V0ID0gY3VycmVudFJlbW92YWxUaW1lb3V0c1txdWVyeUNhY2hlS2V5XTtcbiAgICAgIGlmIChjdXJyZW50VGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoY3VycmVudFRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgY3VycmVudFJlbW92YWxUaW1lb3V0c1txdWVyeUNhY2hlS2V5XSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoIWFueVN1YnNjcmlwdGlvbnNSZW1haW5pbmdGb3JLZXkocXVlcnlDYWNoZUtleSkpIHtcbiAgICAgICAgICBhcGkyLmRpc3BhdGNoKHJlbW92ZVF1ZXJ5UmVzdWx0KHtcbiAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGN1cnJlbnRSZW1vdmFsVGltZW91dHNbcXVlcnlDYWNoZUtleV07XG4gICAgICB9LCBmaW5hbEtlZXBVbnVzZWREYXRhRm9yICogMWUzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhbmRsZXI7XG59O1xuXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZE1pZGRsZXdhcmUvY2FjaGVMaWZlY3ljbGUudHNcbnZhciBuZXZlclJlc29sdmVkRXJyb3IgPSBuZXcgRXJyb3IoXCJQcm9taXNlIG5ldmVyIHJlc29sdmVkIGJlZm9yZSBjYWNoZUVudHJ5UmVtb3ZlZC5cIik7XG52YXIgYnVpbGRDYWNoZUxpZmVjeWNsZUhhbmRsZXIgPSAoe1xuICBhcGksXG4gIHJlZHVjZXJQYXRoLFxuICBjb250ZXh0LFxuICBxdWVyeVRodW5rLFxuICBtdXRhdGlvblRodW5rLFxuICBpbnRlcm5hbFN0YXRlLFxuICBzZWxlY3RvcnM6IHtcbiAgICBzZWxlY3RRdWVyeUVudHJ5LFxuICAgIHNlbGVjdEFwaVN0YXRlXG4gIH1cbn0pID0+IHtcbiAgY29uc3QgaXNRdWVyeVRodW5rID0gaXNBc3luY1RodW5rQWN0aW9uKHF1ZXJ5VGh1bmspO1xuICBjb25zdCBpc011dGF0aW9uVGh1bmsgPSBpc0FzeW5jVGh1bmtBY3Rpb24obXV0YXRpb25UaHVuayk7XG4gIGNvbnN0IGlzRnVsZmlsbGVkVGh1bmsgPSBpc0Z1bGZpbGxlZChxdWVyeVRodW5rLCBtdXRhdGlvblRodW5rKTtcbiAgY29uc3QgbGlmZWN5Y2xlTWFwID0ge307XG4gIGZ1bmN0aW9uIHJlc29sdmVMaWZlY3ljbGVFbnRyeShjYWNoZUtleSwgZGF0YSwgbWV0YSkge1xuICAgIGNvbnN0IGxpZmVjeWNsZSA9IGxpZmVjeWNsZU1hcFtjYWNoZUtleV07XG4gICAgaWYgKGxpZmVjeWNsZT8udmFsdWVSZXNvbHZlZCkge1xuICAgICAgbGlmZWN5Y2xlLnZhbHVlUmVzb2x2ZWQoe1xuICAgICAgICBkYXRhLFxuICAgICAgICBtZXRhXG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSBsaWZlY3ljbGUudmFsdWVSZXNvbHZlZDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlTGlmZWN5Y2xlRW50cnkoY2FjaGVLZXkpIHtcbiAgICBjb25zdCBsaWZlY3ljbGUgPSBsaWZlY3ljbGVNYXBbY2FjaGVLZXldO1xuICAgIGlmIChsaWZlY3ljbGUpIHtcbiAgICAgIGRlbGV0ZSBsaWZlY3ljbGVNYXBbY2FjaGVLZXldO1xuICAgICAgbGlmZWN5Y2xlLmNhY2hlRW50cnlSZW1vdmVkKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGhhbmRsZXIgPSAoYWN0aW9uLCBtd0FwaSwgc3RhdGVCZWZvcmUpID0+IHtcbiAgICBjb25zdCBjYWNoZUtleSA9IGdldENhY2hlS2V5KGFjdGlvbik7XG4gICAgZnVuY3Rpb24gY2hlY2tGb3JOZXdDYWNoZUtleShlbmRwb2ludE5hbWUsIGNhY2hlS2V5MiwgcmVxdWVzdElkLCBvcmlnaW5hbEFyZ3MpIHtcbiAgICAgIGNvbnN0IG9sZEVudHJ5ID0gc2VsZWN0UXVlcnlFbnRyeShzdGF0ZUJlZm9yZSwgY2FjaGVLZXkyKTtcbiAgICAgIGNvbnN0IG5ld0VudHJ5ID0gc2VsZWN0UXVlcnlFbnRyeShtd0FwaS5nZXRTdGF0ZSgpLCBjYWNoZUtleTIpO1xuICAgICAgaWYgKCFvbGRFbnRyeSAmJiBuZXdFbnRyeSkge1xuICAgICAgICBoYW5kbGVOZXdLZXkoZW5kcG9pbnROYW1lLCBvcmlnaW5hbEFyZ3MsIGNhY2hlS2V5MiwgbXdBcGksIHJlcXVlc3RJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxdWVyeVRodW5rLnBlbmRpbmcubWF0Y2goYWN0aW9uKSkge1xuICAgICAgY2hlY2tGb3JOZXdDYWNoZUtleShhY3Rpb24ubWV0YS5hcmcuZW5kcG9pbnROYW1lLCBjYWNoZUtleSwgYWN0aW9uLm1ldGEucmVxdWVzdElkLCBhY3Rpb24ubWV0YS5hcmcub3JpZ2luYWxBcmdzKTtcbiAgICB9IGVsc2UgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMuY2FjaGVFbnRyaWVzVXBzZXJ0ZWQubWF0Y2goYWN0aW9uKSkge1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIHF1ZXJ5RGVzY3JpcHRpb24sXG4gICAgICAgIHZhbHVlXG4gICAgICB9IG9mIGFjdGlvbi5wYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBlbmRwb2ludE5hbWUsXG4gICAgICAgICAgb3JpZ2luYWxBcmdzLFxuICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgICAgfSA9IHF1ZXJ5RGVzY3JpcHRpb247XG4gICAgICAgIGNoZWNrRm9yTmV3Q2FjaGVLZXkoZW5kcG9pbnROYW1lLCBxdWVyeUNhY2hlS2V5LCBhY3Rpb24ubWV0YS5yZXF1ZXN0SWQsIG9yaWdpbmFsQXJncyk7XG4gICAgICAgIHJlc29sdmVMaWZlY3ljbGVFbnRyeShxdWVyeUNhY2hlS2V5LCB2YWx1ZSwge30pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXV0YXRpb25UaHVuay5wZW5kaW5nLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gbXdBcGkuZ2V0U3RhdGUoKVtyZWR1Y2VyUGF0aF0ubXV0YXRpb25zW2NhY2hlS2V5XTtcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBoYW5kbGVOZXdLZXkoYWN0aW9uLm1ldGEuYXJnLmVuZHBvaW50TmFtZSwgYWN0aW9uLm1ldGEuYXJnLm9yaWdpbmFsQXJncywgY2FjaGVLZXksIG13QXBpLCBhY3Rpb24ubWV0YS5yZXF1ZXN0SWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNGdWxmaWxsZWRUaHVuayhhY3Rpb24pKSB7XG4gICAgICByZXNvbHZlTGlmZWN5Y2xlRW50cnkoY2FjaGVLZXksIGFjdGlvbi5wYXlsb2FkLCBhY3Rpb24ubWV0YS5iYXNlUXVlcnlNZXRhKTtcbiAgICB9IGVsc2UgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMucmVtb3ZlUXVlcnlSZXN1bHQubWF0Y2goYWN0aW9uKSB8fCBhcGkuaW50ZXJuYWxBY3Rpb25zLnJlbW92ZU11dGF0aW9uUmVzdWx0Lm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHJlbW92ZUxpZmVjeWNsZUVudHJ5KGNhY2hlS2V5KTtcbiAgICB9IGVsc2UgaWYgKGFwaS51dGlsLnJlc2V0QXBpU3RhdGUubWF0Y2goYWN0aW9uKSkge1xuICAgICAgZm9yIChjb25zdCBjYWNoZUtleTIgb2YgT2JqZWN0LmtleXMobGlmZWN5Y2xlTWFwKSkge1xuICAgICAgICByZW1vdmVMaWZlY3ljbGVFbnRyeShjYWNoZUtleTIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZ2V0Q2FjaGVLZXkoYWN0aW9uKSB7XG4gICAgaWYgKGlzUXVlcnlUaHVuayhhY3Rpb24pKSByZXR1cm4gYWN0aW9uLm1ldGEuYXJnLnF1ZXJ5Q2FjaGVLZXk7XG4gICAgaWYgKGlzTXV0YXRpb25UaHVuayhhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gYWN0aW9uLm1ldGEuYXJnLmZpeGVkQ2FjaGVLZXkgPz8gYWN0aW9uLm1ldGEucmVxdWVzdElkO1xuICAgIH1cbiAgICBpZiAoYXBpLmludGVybmFsQWN0aW9ucy5yZW1vdmVRdWVyeVJlc3VsdC5tYXRjaChhY3Rpb24pKSByZXR1cm4gYWN0aW9uLnBheWxvYWQucXVlcnlDYWNoZUtleTtcbiAgICBpZiAoYXBpLmludGVybmFsQWN0aW9ucy5yZW1vdmVNdXRhdGlvblJlc3VsdC5tYXRjaChhY3Rpb24pKSByZXR1cm4gZ2V0TXV0YXRpb25DYWNoZUtleShhY3Rpb24ucGF5bG9hZCk7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlTmV3S2V5KGVuZHBvaW50TmFtZSwgb3JpZ2luYWxBcmdzLCBxdWVyeUNhY2hlS2V5LCBtd0FwaSwgcmVxdWVzdElkKSB7XG4gICAgY29uc3QgZW5kcG9pbnREZWZpbml0aW9uID0gY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZV07XG4gICAgY29uc3Qgb25DYWNoZUVudHJ5QWRkZWQgPSBlbmRwb2ludERlZmluaXRpb24/Lm9uQ2FjaGVFbnRyeUFkZGVkO1xuICAgIGlmICghb25DYWNoZUVudHJ5QWRkZWQpIHJldHVybjtcbiAgICBjb25zdCBsaWZlY3ljbGUgPSB7fTtcbiAgICBjb25zdCBjYWNoZUVudHJ5UmVtb3ZlZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBsaWZlY3ljbGUuY2FjaGVFbnRyeVJlbW92ZWQgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGNvbnN0IGNhY2hlRGF0YUxvYWRlZCA9IFByb21pc2UucmFjZShbbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGxpZmVjeWNsZS52YWx1ZVJlc29sdmVkID0gcmVzb2x2ZTtcbiAgICB9KSwgY2FjaGVFbnRyeVJlbW92ZWQudGhlbigoKSA9PiB7XG4gICAgICB0aHJvdyBuZXZlclJlc29sdmVkRXJyb3I7XG4gICAgfSldKTtcbiAgICBjYWNoZURhdGFMb2FkZWQuY2F0Y2goKCkgPT4ge1xuICAgIH0pO1xuICAgIGxpZmVjeWNsZU1hcFtxdWVyeUNhY2hlS2V5XSA9IGxpZmVjeWNsZTtcbiAgICBjb25zdCBzZWxlY3RvciA9IGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXS5zZWxlY3QoZW5kcG9pbnREZWZpbml0aW9uLnR5cGUgPT09IFwicXVlcnlcIiAvKiBxdWVyeSAqLyA/IG9yaWdpbmFsQXJncyA6IHF1ZXJ5Q2FjaGVLZXkpO1xuICAgIGNvbnN0IGV4dHJhID0gbXdBcGkuZGlzcGF0Y2goKF8sIF9fLCBleHRyYTIpID0+IGV4dHJhMik7XG4gICAgY29uc3QgbGlmZWN5Y2xlQXBpID0ge1xuICAgICAgLi4ubXdBcGksXG4gICAgICBnZXRDYWNoZUVudHJ5OiAoKSA9PiBzZWxlY3Rvcihtd0FwaS5nZXRTdGF0ZSgpKSxcbiAgICAgIHJlcXVlc3RJZCxcbiAgICAgIGV4dHJhLFxuICAgICAgdXBkYXRlQ2FjaGVkRGF0YTogZW5kcG9pbnREZWZpbml0aW9uLnR5cGUgPT09IFwicXVlcnlcIiAvKiBxdWVyeSAqLyA/ICh1cGRhdGVSZWNpcGUpID0+IG13QXBpLmRpc3BhdGNoKGFwaS51dGlsLnVwZGF0ZVF1ZXJ5RGF0YShlbmRwb2ludE5hbWUsIG9yaWdpbmFsQXJncywgdXBkYXRlUmVjaXBlKSkgOiB2b2lkIDAsXG4gICAgICBjYWNoZURhdGFMb2FkZWQsXG4gICAgICBjYWNoZUVudHJ5UmVtb3ZlZFxuICAgIH07XG4gICAgY29uc3QgcnVubmluZ0hhbmRsZXIgPSBvbkNhY2hlRW50cnlBZGRlZChvcmlnaW5hbEFyZ3MsIGxpZmVjeWNsZUFwaSk7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHJ1bm5pbmdIYW5kbGVyKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgaWYgKGUgPT09IG5ldmVyUmVzb2x2ZWRFcnJvcikgcmV0dXJuO1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaGFuZGxlcjtcbn07XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9kZXZNaWRkbGV3YXJlLnRzXG52YXIgYnVpbGREZXZDaGVja0hhbmRsZXIgPSAoe1xuICBhcGksXG4gIGNvbnRleHQ6IHtcbiAgICBhcGlVaWRcbiAgfSxcbiAgcmVkdWNlclBhdGhcbn0pID0+IHtcbiAgcmV0dXJuIChhY3Rpb24sIG13QXBpKSA9PiB7XG4gICAgaWYgKGFwaS51dGlsLnJlc2V0QXBpU3RhdGUubWF0Y2goYWN0aW9uKSkge1xuICAgICAgbXdBcGkuZGlzcGF0Y2goYXBpLmludGVybmFsQWN0aW9ucy5taWRkbGV3YXJlUmVnaXN0ZXJlZChhcGlVaWQpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgIGlmIChhcGkuaW50ZXJuYWxBY3Rpb25zLm1pZGRsZXdhcmVSZWdpc3RlcmVkLm1hdGNoKGFjdGlvbikgJiYgYWN0aW9uLnBheWxvYWQgPT09IGFwaVVpZCAmJiBtd0FwaS5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXT8uY29uZmlnPy5taWRkbGV3YXJlUmVnaXN0ZXJlZCA9PT0gXCJjb25mbGljdFwiKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgVGhlcmUgaXMgYSBtaXNtYXRjaCBiZXR3ZWVuIHNsaWNlIGFuZCBtaWRkbGV3YXJlIGZvciB0aGUgcmVkdWNlclBhdGggXCIke3JlZHVjZXJQYXRofVwiLlxuWW91IGNhbiBvbmx5IGhhdmUgb25lIGFwaSBwZXIgcmVkdWNlciBwYXRoLCB0aGlzIHdpbGwgbGVhZCB0byBjcmFzaGVzIGluIHZhcmlvdXMgc2l0dWF0aW9ucyEke3JlZHVjZXJQYXRoID09PSBcImFwaVwiID8gYFxuSWYgeW91IGhhdmUgbXVsdGlwbGUgYXBpcywgeW91ICpoYXZlKiB0byBzcGVjaWZ5IHRoZSByZWR1Y2VyUGF0aCBvcHRpb24gd2hlbiB1c2luZyBjcmVhdGVBcGkhYCA6IFwiXCJ9YCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL2ludmFsaWRhdGlvbkJ5VGFncy50c1xudmFyIGJ1aWxkSW52YWxpZGF0aW9uQnlUYWdzSGFuZGxlciA9ICh7XG4gIHJlZHVjZXJQYXRoLFxuICBjb250ZXh0LFxuICBjb250ZXh0OiB7XG4gICAgZW5kcG9pbnREZWZpbml0aW9uc1xuICB9LFxuICBtdXRhdGlvblRodW5rLFxuICBxdWVyeVRodW5rLFxuICBhcGksXG4gIGFzc2VydFRhZ1R5cGUsXG4gIHJlZmV0Y2hRdWVyeSxcbiAgaW50ZXJuYWxTdGF0ZVxufSkgPT4ge1xuICBjb25zdCB7XG4gICAgcmVtb3ZlUXVlcnlSZXN1bHRcbiAgfSA9IGFwaS5pbnRlcm5hbEFjdGlvbnM7XG4gIGNvbnN0IGlzVGh1bmtBY3Rpb25XaXRoVGFncyA9IGlzQW55T2YoaXNGdWxmaWxsZWQobXV0YXRpb25UaHVuayksIGlzUmVqZWN0ZWRXaXRoVmFsdWUobXV0YXRpb25UaHVuaykpO1xuICBjb25zdCBpc1F1ZXJ5RW5kID0gaXNBbnlPZihpc0Z1bGZpbGxlZChtdXRhdGlvblRodW5rLCBxdWVyeVRodW5rKSwgaXNSZWplY3RlZChtdXRhdGlvblRodW5rLCBxdWVyeVRodW5rKSk7XG4gIGxldCBwZW5kaW5nVGFnSW52YWxpZGF0aW9ucyA9IFtdO1xuICBjb25zdCBoYW5kbGVyID0gKGFjdGlvbiwgbXdBcGkpID0+IHtcbiAgICBpZiAoaXNUaHVua0FjdGlvbldpdGhUYWdzKGFjdGlvbikpIHtcbiAgICAgIGludmFsaWRhdGVUYWdzKGNhbGN1bGF0ZVByb3ZpZGVkQnlUaHVuayhhY3Rpb24sIFwiaW52YWxpZGF0ZXNUYWdzXCIsIGVuZHBvaW50RGVmaW5pdGlvbnMsIGFzc2VydFRhZ1R5cGUpLCBtd0FwaSk7XG4gICAgfSBlbHNlIGlmIChpc1F1ZXJ5RW5kKGFjdGlvbikpIHtcbiAgICAgIGludmFsaWRhdGVUYWdzKFtdLCBtd0FwaSk7XG4gICAgfSBlbHNlIGlmIChhcGkudXRpbC5pbnZhbGlkYXRlVGFncy5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBpbnZhbGlkYXRlVGFncyhjYWxjdWxhdGVQcm92aWRlZEJ5KGFjdGlvbi5wYXlsb2FkLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGFzc2VydFRhZ1R5cGUpLCBtd0FwaSk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBoYXNQZW5kaW5nUmVxdWVzdHMoc3RhdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBxdWVyaWVzLFxuICAgICAgbXV0YXRpb25zXG4gICAgfSA9IHN0YXRlO1xuICAgIGZvciAoY29uc3QgY2FjaGVSZWNvcmQgb2YgW3F1ZXJpZXMsIG11dGF0aW9uc10pIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGNhY2hlUmVjb3JkKSB7XG4gICAgICAgIGlmIChjYWNoZVJlY29yZFtrZXldPy5zdGF0dXMgPT09IFwicGVuZGluZ1wiIC8qIHBlbmRpbmcgKi8pIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gaW52YWxpZGF0ZVRhZ3MobmV3VGFncywgbXdBcGkpIHtcbiAgICBjb25zdCByb290U3RhdGUgPSBtd0FwaS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHN0YXRlID0gcm9vdFN0YXRlW3JlZHVjZXJQYXRoXTtcbiAgICBwZW5kaW5nVGFnSW52YWxpZGF0aW9ucy5wdXNoKC4uLm5ld1RhZ3MpO1xuICAgIGlmIChzdGF0ZS5jb25maWcuaW52YWxpZGF0aW9uQmVoYXZpb3IgPT09IFwiZGVsYXllZFwiICYmIGhhc1BlbmRpbmdSZXF1ZXN0cyhzdGF0ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFncyA9IHBlbmRpbmdUYWdJbnZhbGlkYXRpb25zO1xuICAgIHBlbmRpbmdUYWdJbnZhbGlkYXRpb25zID0gW107XG4gICAgaWYgKHRhZ3MubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgY29uc3QgdG9JbnZhbGlkYXRlID0gYXBpLnV0aWwuc2VsZWN0SW52YWxpZGF0ZWRCeShyb290U3RhdGUsIHRhZ3MpO1xuICAgIGNvbnRleHQuYmF0Y2goKCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWVzQXJyYXkgPSBBcnJheS5mcm9tKHRvSW52YWxpZGF0ZS52YWx1ZXMoKSk7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgcXVlcnlDYWNoZUtleVxuICAgICAgfSBvZiB2YWx1ZXNBcnJheSkge1xuICAgICAgICBjb25zdCBxdWVyeVN1YlN0YXRlID0gc3RhdGUucXVlcmllc1txdWVyeUNhY2hlS2V5XTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uU3ViU3RhdGUgPSBpbnRlcm5hbFN0YXRlLmN1cnJlbnRTdWJzY3JpcHRpb25zW3F1ZXJ5Q2FjaGVLZXldID8/IHt9O1xuICAgICAgICBpZiAocXVlcnlTdWJTdGF0ZSkge1xuICAgICAgICAgIGlmIChjb3VudE9iamVjdEtleXMoc3Vic2NyaXB0aW9uU3ViU3RhdGUpID09PSAwKSB7XG4gICAgICAgICAgICBtd0FwaS5kaXNwYXRjaChyZW1vdmVRdWVyeVJlc3VsdCh7XG4gICAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHF1ZXJ5U3ViU3RhdGUuc3RhdHVzICE9PSBcInVuaW5pdGlhbGl6ZWRcIiAvKiB1bmluaXRpYWxpemVkICovKSB7XG4gICAgICAgICAgICBtd0FwaS5kaXNwYXRjaChyZWZldGNoUXVlcnkocXVlcnlTdWJTdGF0ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBoYW5kbGVyO1xufTtcblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL3BvbGxpbmcudHNcbnZhciBidWlsZFBvbGxpbmdIYW5kbGVyID0gKHtcbiAgcmVkdWNlclBhdGgsXG4gIHF1ZXJ5VGh1bmssXG4gIGFwaSxcbiAgcmVmZXRjaFF1ZXJ5LFxuICBpbnRlcm5hbFN0YXRlXG59KSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRQb2xscyA9IHt9O1xuICBjb25zdCBoYW5kbGVyID0gKGFjdGlvbiwgbXdBcGkpID0+IHtcbiAgICBpZiAoYXBpLmludGVybmFsQWN0aW9ucy51cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zLm1hdGNoKGFjdGlvbikgfHwgYXBpLmludGVybmFsQWN0aW9ucy51bnN1YnNjcmliZVF1ZXJ5UmVzdWx0Lm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHVwZGF0ZVBvbGxpbmdJbnRlcnZhbChhY3Rpb24ucGF5bG9hZCwgbXdBcGkpO1xuICAgIH1cbiAgICBpZiAocXVlcnlUaHVuay5wZW5kaW5nLm1hdGNoKGFjdGlvbikgfHwgcXVlcnlUaHVuay5yZWplY3RlZC5tYXRjaChhY3Rpb24pICYmIGFjdGlvbi5tZXRhLmNvbmRpdGlvbikge1xuICAgICAgdXBkYXRlUG9sbGluZ0ludGVydmFsKGFjdGlvbi5tZXRhLmFyZywgbXdBcGkpO1xuICAgIH1cbiAgICBpZiAocXVlcnlUaHVuay5mdWxmaWxsZWQubWF0Y2goYWN0aW9uKSB8fCBxdWVyeVRodW5rLnJlamVjdGVkLm1hdGNoKGFjdGlvbikgJiYgIWFjdGlvbi5tZXRhLmNvbmRpdGlvbikge1xuICAgICAgc3RhcnROZXh0UG9sbChhY3Rpb24ubWV0YS5hcmcsIG13QXBpKTtcbiAgICB9XG4gICAgaWYgKGFwaS51dGlsLnJlc2V0QXBpU3RhdGUubWF0Y2goYWN0aW9uKSkge1xuICAgICAgY2xlYXJQb2xscygpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZ2V0Q2FjaGVFbnRyeVN1YnNjcmlwdGlvbnMocXVlcnlDYWNoZUtleSwgYXBpMikge1xuICAgIGNvbnN0IHN0YXRlID0gYXBpMi5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXTtcbiAgICBjb25zdCBxdWVyeVN1YlN0YXRlID0gc3RhdGUucXVlcmllc1txdWVyeUNhY2hlS2V5XTtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9uc1txdWVyeUNhY2hlS2V5XTtcbiAgICBpZiAoIXF1ZXJ5U3ViU3RhdGUgfHwgcXVlcnlTdWJTdGF0ZS5zdGF0dXMgPT09IFwidW5pbml0aWFsaXplZFwiIC8qIHVuaW5pdGlhbGl6ZWQgKi8pIHJldHVybjtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9ucztcbiAgfVxuICBmdW5jdGlvbiBzdGFydE5leHRQb2xsKHtcbiAgICBxdWVyeUNhY2hlS2V5XG4gIH0sIGFwaTIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGFwaTIuZ2V0U3RhdGUoKVtyZWR1Y2VyUGF0aF07XG4gICAgY29uc3QgcXVlcnlTdWJTdGF0ZSA9IHN0YXRlLnF1ZXJpZXNbcXVlcnlDYWNoZUtleV07XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnNbcXVlcnlDYWNoZUtleV07XG4gICAgaWYgKCFxdWVyeVN1YlN0YXRlIHx8IHF1ZXJ5U3ViU3RhdGUuc3RhdHVzID09PSBcInVuaW5pdGlhbGl6ZWRcIiAvKiB1bmluaXRpYWxpemVkICovKSByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgbG93ZXN0UG9sbGluZ0ludGVydmFsLFxuICAgICAgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZFxuICAgIH0gPSBmaW5kTG93ZXN0UG9sbGluZ0ludGVydmFsKHN1YnNjcmlwdGlvbnMpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGxvd2VzdFBvbGxpbmdJbnRlcnZhbCkpIHJldHVybjtcbiAgICBjb25zdCBjdXJyZW50UG9sbCA9IGN1cnJlbnRQb2xsc1txdWVyeUNhY2hlS2V5XTtcbiAgICBpZiAoY3VycmVudFBvbGw/LnRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChjdXJyZW50UG9sbC50aW1lb3V0KTtcbiAgICAgIGN1cnJlbnRQb2xsLnRpbWVvdXQgPSB2b2lkIDA7XG4gICAgfVxuICAgIGNvbnN0IG5leHRQb2xsVGltZXN0YW1wID0gRGF0ZS5ub3coKSArIGxvd2VzdFBvbGxpbmdJbnRlcnZhbDtcbiAgICBjdXJyZW50UG9sbHNbcXVlcnlDYWNoZUtleV0gPSB7XG4gICAgICBuZXh0UG9sbFRpbWVzdGFtcCxcbiAgICAgIHBvbGxpbmdJbnRlcnZhbDogbG93ZXN0UG9sbGluZ0ludGVydmFsLFxuICAgICAgdGltZW91dDogc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZS5jb25maWcuZm9jdXNlZCB8fCAhc2tpcFBvbGxpbmdJZlVuZm9jdXNlZCkge1xuICAgICAgICAgIGFwaTIuZGlzcGF0Y2gocmVmZXRjaFF1ZXJ5KHF1ZXJ5U3ViU3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGFydE5leHRQb2xsKHtcbiAgICAgICAgICBxdWVyeUNhY2hlS2V5XG4gICAgICAgIH0sIGFwaTIpO1xuICAgICAgfSwgbG93ZXN0UG9sbGluZ0ludGVydmFsKVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUG9sbGluZ0ludGVydmFsKHtcbiAgICBxdWVyeUNhY2hlS2V5XG4gIH0sIGFwaTIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGFwaTIuZ2V0U3RhdGUoKVtyZWR1Y2VyUGF0aF07XG4gICAgY29uc3QgcXVlcnlTdWJTdGF0ZSA9IHN0YXRlLnF1ZXJpZXNbcXVlcnlDYWNoZUtleV07XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnNbcXVlcnlDYWNoZUtleV07XG4gICAgaWYgKCFxdWVyeVN1YlN0YXRlIHx8IHF1ZXJ5U3ViU3RhdGUuc3RhdHVzID09PSBcInVuaW5pdGlhbGl6ZWRcIiAvKiB1bmluaXRpYWxpemVkICovKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxvd2VzdFBvbGxpbmdJbnRlcnZhbFxuICAgIH0gPSBmaW5kTG93ZXN0UG9sbGluZ0ludGVydmFsKHN1YnNjcmlwdGlvbnMpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGxvd2VzdFBvbGxpbmdJbnRlcnZhbCkpIHtcbiAgICAgIGNsZWFudXBQb2xsRm9yS2V5KHF1ZXJ5Q2FjaGVLZXkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50UG9sbCA9IGN1cnJlbnRQb2xsc1txdWVyeUNhY2hlS2V5XTtcbiAgICBjb25zdCBuZXh0UG9sbFRpbWVzdGFtcCA9IERhdGUubm93KCkgKyBsb3dlc3RQb2xsaW5nSW50ZXJ2YWw7XG4gICAgaWYgKCFjdXJyZW50UG9sbCB8fCBuZXh0UG9sbFRpbWVzdGFtcCA8IGN1cnJlbnRQb2xsLm5leHRQb2xsVGltZXN0YW1wKSB7XG4gICAgICBzdGFydE5leHRQb2xsKHtcbiAgICAgICAgcXVlcnlDYWNoZUtleVxuICAgICAgfSwgYXBpMik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNsZWFudXBQb2xsRm9yS2V5KGtleSkge1xuICAgIGNvbnN0IGV4aXN0aW5nUG9sbCA9IGN1cnJlbnRQb2xsc1trZXldO1xuICAgIGlmIChleGlzdGluZ1BvbGw/LnRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChleGlzdGluZ1BvbGwudGltZW91dCk7XG4gICAgfVxuICAgIGRlbGV0ZSBjdXJyZW50UG9sbHNba2V5XTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhclBvbGxzKCkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGN1cnJlbnRQb2xscykpIHtcbiAgICAgIGNsZWFudXBQb2xsRm9yS2V5KGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGZpbmRMb3dlc3RQb2xsaW5nSW50ZXJ2YWwoc3Vic2NyaWJlcnMgPSB7fSkge1xuICAgIGxldCBza2lwUG9sbGluZ0lmVW5mb2N1c2VkID0gZmFsc2U7XG4gICAgbGV0IGxvd2VzdFBvbGxpbmdJbnRlcnZhbCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBmb3IgKGxldCBrZXkgaW4gc3Vic2NyaWJlcnMpIHtcbiAgICAgIGlmICghIXN1YnNjcmliZXJzW2tleV0ucG9sbGluZ0ludGVydmFsKSB7XG4gICAgICAgIGxvd2VzdFBvbGxpbmdJbnRlcnZhbCA9IE1hdGgubWluKHN1YnNjcmliZXJzW2tleV0ucG9sbGluZ0ludGVydmFsLCBsb3dlc3RQb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICBza2lwUG9sbGluZ0lmVW5mb2N1c2VkID0gc3Vic2NyaWJlcnNba2V5XS5za2lwUG9sbGluZ0lmVW5mb2N1c2VkIHx8IHNraXBQb2xsaW5nSWZVbmZvY3VzZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBsb3dlc3RQb2xsaW5nSW50ZXJ2YWwsXG4gICAgICBza2lwUG9sbGluZ0lmVW5mb2N1c2VkXG4gICAgfTtcbiAgfVxuICByZXR1cm4gaGFuZGxlcjtcbn07XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9xdWVyeUxpZmVjeWNsZS50c1xudmFyIGJ1aWxkUXVlcnlMaWZlY3ljbGVIYW5kbGVyID0gKHtcbiAgYXBpLFxuICBjb250ZXh0LFxuICBxdWVyeVRodW5rLFxuICBtdXRhdGlvblRodW5rXG59KSA9PiB7XG4gIGNvbnN0IGlzUGVuZGluZ1RodW5rID0gaXNQZW5kaW5nKHF1ZXJ5VGh1bmssIG11dGF0aW9uVGh1bmspO1xuICBjb25zdCBpc1JlamVjdGVkVGh1bmsgPSBpc1JlamVjdGVkKHF1ZXJ5VGh1bmssIG11dGF0aW9uVGh1bmspO1xuICBjb25zdCBpc0Z1bGxmaWxsZWRUaHVuayA9IGlzRnVsZmlsbGVkKHF1ZXJ5VGh1bmssIG11dGF0aW9uVGh1bmspO1xuICBjb25zdCBsaWZlY3ljbGVNYXAgPSB7fTtcbiAgY29uc3QgaGFuZGxlciA9IChhY3Rpb24sIG13QXBpKSA9PiB7XG4gICAgaWYgKGlzUGVuZGluZ1RodW5rKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICBhcmc6IHtcbiAgICAgICAgICBlbmRwb2ludE5hbWUsXG4gICAgICAgICAgb3JpZ2luYWxBcmdzXG4gICAgICAgIH1cbiAgICAgIH0gPSBhY3Rpb24ubWV0YTtcbiAgICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdO1xuICAgICAgY29uc3Qgb25RdWVyeVN0YXJ0ZWQgPSBlbmRwb2ludERlZmluaXRpb24/Lm9uUXVlcnlTdGFydGVkO1xuICAgICAgaWYgKG9uUXVlcnlTdGFydGVkKSB7XG4gICAgICAgIGNvbnN0IGxpZmVjeWNsZSA9IHt9O1xuICAgICAgICBjb25zdCBxdWVyeUZ1bGZpbGxlZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBsaWZlY3ljbGUucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgbGlmZWN5Y2xlLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHF1ZXJ5RnVsZmlsbGVkLmNhdGNoKCgpID0+IHtcbiAgICAgICAgfSk7XG4gICAgICAgIGxpZmVjeWNsZU1hcFtyZXF1ZXN0SWRdID0gbGlmZWN5Y2xlO1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9IGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXS5zZWxlY3QoZW5kcG9pbnREZWZpbml0aW9uLnR5cGUgPT09IFwicXVlcnlcIiAvKiBxdWVyeSAqLyA/IG9yaWdpbmFsQXJncyA6IHJlcXVlc3RJZCk7XG4gICAgICAgIGNvbnN0IGV4dHJhID0gbXdBcGkuZGlzcGF0Y2goKF8sIF9fLCBleHRyYTIpID0+IGV4dHJhMik7XG4gICAgICAgIGNvbnN0IGxpZmVjeWNsZUFwaSA9IHtcbiAgICAgICAgICAuLi5td0FwaSxcbiAgICAgICAgICBnZXRDYWNoZUVudHJ5OiAoKSA9PiBzZWxlY3Rvcihtd0FwaS5nZXRTdGF0ZSgpKSxcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgdXBkYXRlQ2FjaGVkRGF0YTogZW5kcG9pbnREZWZpbml0aW9uLnR5cGUgPT09IFwicXVlcnlcIiAvKiBxdWVyeSAqLyA/ICh1cGRhdGVSZWNpcGUpID0+IG13QXBpLmRpc3BhdGNoKGFwaS51dGlsLnVwZGF0ZVF1ZXJ5RGF0YShlbmRwb2ludE5hbWUsIG9yaWdpbmFsQXJncywgdXBkYXRlUmVjaXBlKSkgOiB2b2lkIDAsXG4gICAgICAgICAgcXVlcnlGdWxmaWxsZWRcbiAgICAgICAgfTtcbiAgICAgICAgb25RdWVyeVN0YXJ0ZWQob3JpZ2luYWxBcmdzLCBsaWZlY3ljbGVBcGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNGdWxsZmlsbGVkVGh1bmsoYWN0aW9uKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIGJhc2VRdWVyeU1ldGFcbiAgICAgIH0gPSBhY3Rpb24ubWV0YTtcbiAgICAgIGxpZmVjeWNsZU1hcFtyZXF1ZXN0SWRdPy5yZXNvbHZlKHtcbiAgICAgICAgZGF0YTogYWN0aW9uLnBheWxvYWQsXG4gICAgICAgIG1ldGE6IGJhc2VRdWVyeU1ldGFcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIGxpZmVjeWNsZU1hcFtyZXF1ZXN0SWRdO1xuICAgIH0gZWxzZSBpZiAoaXNSZWplY3RlZFRodW5rKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZWplY3RlZFdpdGhWYWx1ZSxcbiAgICAgICAgYmFzZVF1ZXJ5TWV0YVxuICAgICAgfSA9IGFjdGlvbi5tZXRhO1xuICAgICAgbGlmZWN5Y2xlTWFwW3JlcXVlc3RJZF0/LnJlamVjdCh7XG4gICAgICAgIGVycm9yOiBhY3Rpb24ucGF5bG9hZCA/PyBhY3Rpb24uZXJyb3IsXG4gICAgICAgIGlzVW5oYW5kbGVkRXJyb3I6ICFyZWplY3RlZFdpdGhWYWx1ZSxcbiAgICAgICAgbWV0YTogYmFzZVF1ZXJ5TWV0YVxuICAgICAgfSk7XG4gICAgICBkZWxldGUgbGlmZWN5Y2xlTWFwW3JlcXVlc3RJZF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGFuZGxlcjtcbn07XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS93aW5kb3dFdmVudEhhbmRsaW5nLnRzXG52YXIgYnVpbGRXaW5kb3dFdmVudEhhbmRsZXIgPSAoe1xuICByZWR1Y2VyUGF0aCxcbiAgY29udGV4dCxcbiAgYXBpLFxuICByZWZldGNoUXVlcnksXG4gIGludGVybmFsU3RhdGVcbn0pID0+IHtcbiAgY29uc3Qge1xuICAgIHJlbW92ZVF1ZXJ5UmVzdWx0XG4gIH0gPSBhcGkuaW50ZXJuYWxBY3Rpb25zO1xuICBjb25zdCBoYW5kbGVyID0gKGFjdGlvbiwgbXdBcGkpID0+IHtcbiAgICBpZiAob25Gb2N1cy5tYXRjaChhY3Rpb24pKSB7XG4gICAgICByZWZldGNoVmFsaWRRdWVyaWVzKG13QXBpLCBcInJlZmV0Y2hPbkZvY3VzXCIpO1xuICAgIH1cbiAgICBpZiAob25PbmxpbmUubWF0Y2goYWN0aW9uKSkge1xuICAgICAgcmVmZXRjaFZhbGlkUXVlcmllcyhtd0FwaSwgXCJyZWZldGNoT25SZWNvbm5lY3RcIik7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiByZWZldGNoVmFsaWRRdWVyaWVzKGFwaTIsIHR5cGUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGFwaTIuZ2V0U3RhdGUoKVtyZWR1Y2VyUGF0aF07XG4gICAgY29uc3QgcXVlcmllcyA9IHN0YXRlLnF1ZXJpZXM7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnM7XG4gICAgY29udGV4dC5iYXRjaCgoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHF1ZXJ5Q2FjaGVLZXkgb2YgT2JqZWN0LmtleXMoc3Vic2NyaXB0aW9ucykpIHtcbiAgICAgICAgY29uc3QgcXVlcnlTdWJTdGF0ZSA9IHF1ZXJpZXNbcXVlcnlDYWNoZUtleV07XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvblN1YlN0YXRlID0gc3Vic2NyaXB0aW9uc1txdWVyeUNhY2hlS2V5XTtcbiAgICAgICAgaWYgKCFzdWJzY3JpcHRpb25TdWJTdGF0ZSB8fCAhcXVlcnlTdWJTdGF0ZSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IHNob3VsZFJlZmV0Y2ggPSBPYmplY3QudmFsdWVzKHN1YnNjcmlwdGlvblN1YlN0YXRlKS5zb21lKChzdWIpID0+IHN1Ylt0eXBlXSA9PT0gdHJ1ZSkgfHwgT2JqZWN0LnZhbHVlcyhzdWJzY3JpcHRpb25TdWJTdGF0ZSkuZXZlcnkoKHN1YikgPT4gc3ViW3R5cGVdID09PSB2b2lkIDApICYmIHN0YXRlLmNvbmZpZ1t0eXBlXTtcbiAgICAgICAgaWYgKHNob3VsZFJlZmV0Y2gpIHtcbiAgICAgICAgICBpZiAoY291bnRPYmplY3RLZXlzKHN1YnNjcmlwdGlvblN1YlN0YXRlKSA9PT0gMCkge1xuICAgICAgICAgICAgYXBpMi5kaXNwYXRjaChyZW1vdmVRdWVyeVJlc3VsdCh7XG4gICAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHF1ZXJ5U3ViU3RhdGUuc3RhdHVzICE9PSBcInVuaW5pdGlhbGl6ZWRcIiAvKiB1bmluaXRpYWxpemVkICovKSB7XG4gICAgICAgICAgICBhcGkyLmRpc3BhdGNoKHJlZmV0Y2hRdWVyeShxdWVyeVN1YlN0YXRlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZXI7XG59O1xuXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZE1pZGRsZXdhcmUvaW5kZXgudHNcbmZ1bmN0aW9uIGJ1aWxkTWlkZGxld2FyZShpbnB1dCkge1xuICBjb25zdCB7XG4gICAgcmVkdWNlclBhdGgsXG4gICAgcXVlcnlUaHVuayxcbiAgICBhcGksXG4gICAgY29udGV4dFxuICB9ID0gaW5wdXQ7XG4gIGNvbnN0IHtcbiAgICBhcGlVaWRcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgaW52YWxpZGF0ZVRhZ3M6IGNyZWF0ZUFjdGlvbihgJHtyZWR1Y2VyUGF0aH0vaW52YWxpZGF0ZVRhZ3NgKVxuICB9O1xuICBjb25zdCBpc1RoaXNBcGlTbGljZUFjdGlvbiA9IChhY3Rpb24pID0+IGFjdGlvbi50eXBlLnN0YXJ0c1dpdGgoYCR7cmVkdWNlclBhdGh9L2ApO1xuICBjb25zdCBoYW5kbGVyQnVpbGRlcnMgPSBbYnVpbGREZXZDaGVja0hhbmRsZXIsIGJ1aWxkQ2FjaGVDb2xsZWN0aW9uSGFuZGxlciwgYnVpbGRJbnZhbGlkYXRpb25CeVRhZ3NIYW5kbGVyLCBidWlsZFBvbGxpbmdIYW5kbGVyLCBidWlsZENhY2hlTGlmZWN5Y2xlSGFuZGxlciwgYnVpbGRRdWVyeUxpZmVjeWNsZUhhbmRsZXJdO1xuICBjb25zdCBtaWRkbGV3YXJlID0gKG13QXBpKSA9PiB7XG4gICAgbGV0IGluaXRpYWxpemVkMiA9IGZhbHNlO1xuICAgIGNvbnN0IGludGVybmFsU3RhdGUgPSB7XG4gICAgICBjdXJyZW50U3Vic2NyaXB0aW9uczoge31cbiAgICB9O1xuICAgIGNvbnN0IGJ1aWxkZXJBcmdzID0ge1xuICAgICAgLi4uaW5wdXQsXG4gICAgICBpbnRlcm5hbFN0YXRlLFxuICAgICAgcmVmZXRjaFF1ZXJ5LFxuICAgICAgaXNUaGlzQXBpU2xpY2VBY3Rpb25cbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZXJzID0gaGFuZGxlckJ1aWxkZXJzLm1hcCgoYnVpbGQpID0+IGJ1aWxkKGJ1aWxkZXJBcmdzKSk7XG4gICAgY29uc3QgYmF0Y2hlZEFjdGlvbnNIYW5kbGVyID0gYnVpbGRCYXRjaGVkQWN0aW9uc0hhbmRsZXIoYnVpbGRlckFyZ3MpO1xuICAgIGNvbnN0IHdpbmRvd0V2ZW50c0hhbmRsZXIgPSBidWlsZFdpbmRvd0V2ZW50SGFuZGxlcihidWlsZGVyQXJncyk7XG4gICAgcmV0dXJuIChuZXh0KSA9PiB7XG4gICAgICByZXR1cm4gKGFjdGlvbikgPT4ge1xuICAgICAgICBpZiAoIWlzQWN0aW9uKGFjdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5pdGlhbGl6ZWQyKSB7XG4gICAgICAgICAgaW5pdGlhbGl6ZWQyID0gdHJ1ZTtcbiAgICAgICAgICBtd0FwaS5kaXNwYXRjaChhcGkuaW50ZXJuYWxBY3Rpb25zLm1pZGRsZXdhcmVSZWdpc3RlcmVkKGFwaVVpZCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG13QXBpV2l0aE5leHQgPSB7XG4gICAgICAgICAgLi4ubXdBcGksXG4gICAgICAgICAgbmV4dFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdGF0ZUJlZm9yZSA9IG13QXBpLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IFthY3Rpb25TaG91bGRDb250aW51ZSwgaW50ZXJuYWxQcm9iZVJlc3VsdF0gPSBiYXRjaGVkQWN0aW9uc0hhbmRsZXIoYWN0aW9uLCBtd0FwaVdpdGhOZXh0LCBzdGF0ZUJlZm9yZSk7XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIGlmIChhY3Rpb25TaG91bGRDb250aW51ZSkge1xuICAgICAgICAgIHJlcyA9IG5leHQoYWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMgPSBpbnRlcm5hbFByb2JlUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghIW13QXBpLmdldFN0YXRlKClbcmVkdWNlclBhdGhdKSB7XG4gICAgICAgICAgd2luZG93RXZlbnRzSGFuZGxlcihhY3Rpb24sIG13QXBpV2l0aE5leHQsIHN0YXRlQmVmb3JlKTtcbiAgICAgICAgICBpZiAoaXNUaGlzQXBpU2xpY2VBY3Rpb24oYWN0aW9uKSB8fCBjb250ZXh0Lmhhc1JlaHlkcmF0aW9uSW5mbyhhY3Rpb24pKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgaGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgaGFuZGxlcihhY3Rpb24sIG13QXBpV2l0aE5leHQsIHN0YXRlQmVmb3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBtaWRkbGV3YXJlLFxuICAgIGFjdGlvbnNcbiAgfTtcbiAgZnVuY3Rpb24gcmVmZXRjaFF1ZXJ5KHF1ZXJ5U3ViU3RhdGUpIHtcbiAgICByZXR1cm4gaW5wdXQuYXBpLmVuZHBvaW50c1txdWVyeVN1YlN0YXRlLmVuZHBvaW50TmFtZV0uaW5pdGlhdGUocXVlcnlTdWJTdGF0ZS5vcmlnaW5hbEFyZ3MsIHtcbiAgICAgIHN1YnNjcmliZTogZmFsc2UsXG4gICAgICBmb3JjZVJlZmV0Y2g6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBzcmMvcXVlcnkvY29yZS9tb2R1bGUudHNcbnZhciBjb3JlTW9kdWxlTmFtZSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woKTtcbnZhciBjb3JlTW9kdWxlID0gKHtcbiAgY3JlYXRlU2VsZWN0b3I6IGNyZWF0ZVNlbGVjdG9yMiA9IGNyZWF0ZVNlbGVjdG9yXG59ID0ge30pID0+ICh7XG4gIG5hbWU6IGNvcmVNb2R1bGVOYW1lLFxuICBpbml0KGFwaSwge1xuICAgIGJhc2VRdWVyeSxcbiAgICB0YWdUeXBlcyxcbiAgICByZWR1Y2VyUGF0aCxcbiAgICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gICAga2VlcFVudXNlZERhdGFGb3IsXG4gICAgcmVmZXRjaE9uTW91bnRPckFyZ0NoYW5nZSxcbiAgICByZWZldGNoT25Gb2N1cyxcbiAgICByZWZldGNoT25SZWNvbm5lY3QsXG4gICAgaW52YWxpZGF0aW9uQmVoYXZpb3JcbiAgfSwgY29udGV4dCkge1xuICAgIGVuYWJsZVBhdGNoZXMoKTtcbiAgICBhc3NlcnRDYXN0KHNlcmlhbGl6ZVF1ZXJ5QXJncyk7XG4gICAgY29uc3QgYXNzZXJ0VGFnVHlwZSA9ICh0YWcpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgIGlmICghdGFnVHlwZXMuaW5jbHVkZXModGFnLnR5cGUpKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgVGFnIHR5cGUgJyR7dGFnLnR5cGV9JyB3YXMgdXNlZCwgYnV0IG5vdCBzcGVjaWZpZWQgaW4gXFxgdGFnVHlwZXNcXGAhYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWc7XG4gICAgfTtcbiAgICBPYmplY3QuYXNzaWduKGFwaSwge1xuICAgICAgcmVkdWNlclBhdGgsXG4gICAgICBlbmRwb2ludHM6IHt9LFxuICAgICAgaW50ZXJuYWxBY3Rpb25zOiB7XG4gICAgICAgIG9uT25saW5lLFxuICAgICAgICBvbk9mZmxpbmUsXG4gICAgICAgIG9uRm9jdXMsXG4gICAgICAgIG9uRm9jdXNMb3N0XG4gICAgICB9LFxuICAgICAgdXRpbDoge31cbiAgICB9KTtcbiAgICBjb25zdCBzZWxlY3RvcnMgPSBidWlsZFNlbGVjdG9ycyh7XG4gICAgICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gICAgICByZWR1Y2VyUGF0aCxcbiAgICAgIGNyZWF0ZVNlbGVjdG9yOiBjcmVhdGVTZWxlY3RvcjJcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBzZWxlY3RJbnZhbGlkYXRlZEJ5LFxuICAgICAgc2VsZWN0Q2FjaGVkQXJnc0ZvclF1ZXJ5LFxuICAgICAgYnVpbGRRdWVyeVNlbGVjdG9yLFxuICAgICAgYnVpbGRJbmZpbml0ZVF1ZXJ5U2VsZWN0b3IsXG4gICAgICBidWlsZE11dGF0aW9uU2VsZWN0b3JcbiAgICB9ID0gc2VsZWN0b3JzO1xuICAgIHNhZmVBc3NpZ24oYXBpLnV0aWwsIHtcbiAgICAgIHNlbGVjdEludmFsaWRhdGVkQnksXG4gICAgICBzZWxlY3RDYWNoZWRBcmdzRm9yUXVlcnlcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBxdWVyeVRodW5rLFxuICAgICAgaW5maW5pdGVRdWVyeVRodW5rLFxuICAgICAgbXV0YXRpb25UaHVuayxcbiAgICAgIHBhdGNoUXVlcnlEYXRhLFxuICAgICAgdXBkYXRlUXVlcnlEYXRhLFxuICAgICAgdXBzZXJ0UXVlcnlEYXRhLFxuICAgICAgcHJlZmV0Y2gsXG4gICAgICBidWlsZE1hdGNoVGh1bmtBY3Rpb25zXG4gICAgfSA9IGJ1aWxkVGh1bmtzKHtcbiAgICAgIGJhc2VRdWVyeSxcbiAgICAgIHJlZHVjZXJQYXRoLFxuICAgICAgY29udGV4dCxcbiAgICAgIGFwaSxcbiAgICAgIHNlcmlhbGl6ZVF1ZXJ5QXJncyxcbiAgICAgIGFzc2VydFRhZ1R5cGUsXG4gICAgICBzZWxlY3RvcnNcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICByZWR1Y2VyLFxuICAgICAgYWN0aW9uczogc2xpY2VBY3Rpb25zXG4gICAgfSA9IGJ1aWxkU2xpY2Uoe1xuICAgICAgY29udGV4dCxcbiAgICAgIHF1ZXJ5VGh1bmssXG4gICAgICBpbmZpbml0ZVF1ZXJ5VGh1bmssXG4gICAgICBtdXRhdGlvblRodW5rLFxuICAgICAgc2VyaWFsaXplUXVlcnlBcmdzLFxuICAgICAgcmVkdWNlclBhdGgsXG4gICAgICBhc3NlcnRUYWdUeXBlLFxuICAgICAgY29uZmlnOiB7XG4gICAgICAgIHJlZmV0Y2hPbkZvY3VzLFxuICAgICAgICByZWZldGNoT25SZWNvbm5lY3QsXG4gICAgICAgIHJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2UsXG4gICAgICAgIGtlZXBVbnVzZWREYXRhRm9yLFxuICAgICAgICByZWR1Y2VyUGF0aCxcbiAgICAgICAgaW52YWxpZGF0aW9uQmVoYXZpb3JcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzYWZlQXNzaWduKGFwaS51dGlsLCB7XG4gICAgICBwYXRjaFF1ZXJ5RGF0YSxcbiAgICAgIHVwZGF0ZVF1ZXJ5RGF0YSxcbiAgICAgIHVwc2VydFF1ZXJ5RGF0YSxcbiAgICAgIHByZWZldGNoLFxuICAgICAgcmVzZXRBcGlTdGF0ZTogc2xpY2VBY3Rpb25zLnJlc2V0QXBpU3RhdGUsXG4gICAgICB1cHNlcnRRdWVyeUVudHJpZXM6IHNsaWNlQWN0aW9ucy5jYWNoZUVudHJpZXNVcHNlcnRlZFxuICAgIH0pO1xuICAgIHNhZmVBc3NpZ24oYXBpLmludGVybmFsQWN0aW9ucywgc2xpY2VBY3Rpb25zKTtcbiAgICBjb25zdCB7XG4gICAgICBtaWRkbGV3YXJlLFxuICAgICAgYWN0aW9uczogbWlkZGxld2FyZUFjdGlvbnNcbiAgICB9ID0gYnVpbGRNaWRkbGV3YXJlKHtcbiAgICAgIHJlZHVjZXJQYXRoLFxuICAgICAgY29udGV4dCxcbiAgICAgIHF1ZXJ5VGh1bmssXG4gICAgICBtdXRhdGlvblRodW5rLFxuICAgICAgaW5maW5pdGVRdWVyeVRodW5rLFxuICAgICAgYXBpLFxuICAgICAgYXNzZXJ0VGFnVHlwZSxcbiAgICAgIHNlbGVjdG9yc1xuICAgIH0pO1xuICAgIHNhZmVBc3NpZ24oYXBpLnV0aWwsIG1pZGRsZXdhcmVBY3Rpb25zKTtcbiAgICBzYWZlQXNzaWduKGFwaSwge1xuICAgICAgcmVkdWNlcixcbiAgICAgIG1pZGRsZXdhcmVcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBidWlsZEluaXRpYXRlUXVlcnksXG4gICAgICBidWlsZEluaXRpYXRlSW5maW5pdGVRdWVyeSxcbiAgICAgIGJ1aWxkSW5pdGlhdGVNdXRhdGlvbixcbiAgICAgIGdldFJ1bm5pbmdNdXRhdGlvblRodW5rLFxuICAgICAgZ2V0UnVubmluZ011dGF0aW9uc1RodW5rLFxuICAgICAgZ2V0UnVubmluZ1F1ZXJpZXNUaHVuayxcbiAgICAgIGdldFJ1bm5pbmdRdWVyeVRodW5rXG4gICAgfSA9IGJ1aWxkSW5pdGlhdGUoe1xuICAgICAgcXVlcnlUaHVuayxcbiAgICAgIG11dGF0aW9uVGh1bmssXG4gICAgICBpbmZpbml0ZVF1ZXJ5VGh1bmssXG4gICAgICBhcGksXG4gICAgICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gICAgICBjb250ZXh0XG4gICAgfSk7XG4gICAgc2FmZUFzc2lnbihhcGkudXRpbCwge1xuICAgICAgZ2V0UnVubmluZ011dGF0aW9uVGh1bmssXG4gICAgICBnZXRSdW5uaW5nTXV0YXRpb25zVGh1bmssXG4gICAgICBnZXRSdW5uaW5nUXVlcnlUaHVuayxcbiAgICAgIGdldFJ1bm5pbmdRdWVyaWVzVGh1bmtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogY29yZU1vZHVsZU5hbWUsXG4gICAgICBpbmplY3RFbmRwb2ludChlbmRwb2ludE5hbWUsIGRlZmluaXRpb24pIHtcbiAgICAgICAgY29uc3QgYW55QXBpID0gYXBpO1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IGFueUFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXSA/Pz0ge307XG4gICAgICAgIGlmIChpc1F1ZXJ5RGVmaW5pdGlvbihkZWZpbml0aW9uKSkge1xuICAgICAgICAgIHNhZmVBc3NpZ24oZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIG5hbWU6IGVuZHBvaW50TmFtZSxcbiAgICAgICAgICAgIHNlbGVjdDogYnVpbGRRdWVyeVNlbGVjdG9yKGVuZHBvaW50TmFtZSwgZGVmaW5pdGlvbiksXG4gICAgICAgICAgICBpbml0aWF0ZTogYnVpbGRJbml0aWF0ZVF1ZXJ5KGVuZHBvaW50TmFtZSwgZGVmaW5pdGlvbilcbiAgICAgICAgICB9LCBidWlsZE1hdGNoVGh1bmtBY3Rpb25zKHF1ZXJ5VGh1bmssIGVuZHBvaW50TmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc011dGF0aW9uRGVmaW5pdGlvbihkZWZpbml0aW9uKSkge1xuICAgICAgICAgIHNhZmVBc3NpZ24oZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIG5hbWU6IGVuZHBvaW50TmFtZSxcbiAgICAgICAgICAgIHNlbGVjdDogYnVpbGRNdXRhdGlvblNlbGVjdG9yKCksXG4gICAgICAgICAgICBpbml0aWF0ZTogYnVpbGRJbml0aWF0ZU11dGF0aW9uKGVuZHBvaW50TmFtZSlcbiAgICAgICAgICB9LCBidWlsZE1hdGNoVGh1bmtBY3Rpb25zKG11dGF0aW9uVGh1bmssIGVuZHBvaW50TmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0luZmluaXRlUXVlcnlEZWZpbml0aW9uKGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgc2FmZUFzc2lnbihlbmRwb2ludCwge1xuICAgICAgICAgICAgbmFtZTogZW5kcG9pbnROYW1lLFxuICAgICAgICAgICAgc2VsZWN0OiBidWlsZEluZmluaXRlUXVlcnlTZWxlY3RvcihlbmRwb2ludE5hbWUsIGRlZmluaXRpb24pLFxuICAgICAgICAgICAgaW5pdGlhdGU6IGJ1aWxkSW5pdGlhdGVJbmZpbml0ZVF1ZXJ5KGVuZHBvaW50TmFtZSwgZGVmaW5pdGlvbilcbiAgICAgICAgICB9LCBidWlsZE1hdGNoVGh1bmtBY3Rpb25zKHF1ZXJ5VGh1bmssIGVuZHBvaW50TmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2luZGV4LnRzXG52YXIgY3JlYXRlQXBpID0gLyogQF9fUFVSRV9fICovIGJ1aWxkQ3JlYXRlQXBpKGNvcmVNb2R1bGUoKSk7XG5leHBvcnQge1xuICBRdWVyeVN0YXR1cyxcbiAgX05FVkVSLFxuICBidWlsZENyZWF0ZUFwaSxcbiAgY29weVdpdGhTdHJ1Y3R1cmFsU2hhcmluZyxcbiAgY29yZU1vZHVsZSxcbiAgY29yZU1vZHVsZU5hbWUsXG4gIGNyZWF0ZUFwaSxcbiAgZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncyxcbiAgZmFrZUJhc2VRdWVyeSxcbiAgZmV0Y2hCYXNlUXVlcnksXG4gIHJldHJ5LFxuICBzZXR1cExpc3RlbmVycyxcbiAgc2tpcFRva2VuXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnRrLXF1ZXJ5Lm1vZGVybi5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReducerType: () => (/* binding */ ReducerType),\n/* harmony export */   SHOULD_AUTOBATCH: () => (/* binding */ SHOULD_AUTOBATCH),\n/* harmony export */   TaskAbortError: () => (/* binding */ TaskAbortError),\n/* harmony export */   Tuple: () => (/* binding */ Tuple),\n/* harmony export */   __DO_NOT_USE__ActionTypes: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.__DO_NOT_USE__ActionTypes),\n/* harmony export */   addListener: () => (/* binding */ addListener),\n/* harmony export */   applyMiddleware: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware),\n/* harmony export */   asyncThunkCreator: () => (/* binding */ asyncThunkCreator),\n/* harmony export */   autoBatchEnhancer: () => (/* binding */ autoBatchEnhancer),\n/* harmony export */   bindActionCreators: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.bindActionCreators),\n/* harmony export */   buildCreateSlice: () => (/* binding */ buildCreateSlice),\n/* harmony export */   clearAllListeners: () => (/* binding */ clearAllListeners),\n/* harmony export */   combineReducers: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers),\n/* harmony export */   combineSlices: () => (/* binding */ combineSlices),\n/* harmony export */   compose: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.compose),\n/* harmony export */   configureStore: () => (/* binding */ configureStore),\n/* harmony export */   createAction: () => (/* binding */ createAction),\n/* harmony export */   createActionCreatorInvariantMiddleware: () => (/* binding */ createActionCreatorInvariantMiddleware),\n/* harmony export */   createAsyncThunk: () => (/* binding */ createAsyncThunk),\n/* harmony export */   createDraftSafeSelector: () => (/* binding */ createDraftSafeSelector),\n/* harmony export */   createDraftSafeSelectorCreator: () => (/* binding */ createDraftSafeSelectorCreator),\n/* harmony export */   createDynamicMiddleware: () => (/* binding */ createDynamicMiddleware),\n/* harmony export */   createEntityAdapter: () => (/* binding */ createEntityAdapter),\n/* harmony export */   createImmutableStateInvariantMiddleware: () => (/* binding */ createImmutableStateInvariantMiddleware),\n/* harmony export */   createListenerMiddleware: () => (/* binding */ createListenerMiddleware),\n/* harmony export */   createNextState: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.produce),\n/* harmony export */   createReducer: () => (/* binding */ createReducer),\n/* harmony export */   createSelector: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector),\n/* harmony export */   createSelectorCreator: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator),\n/* harmony export */   createSerializableStateInvariantMiddleware: () => (/* binding */ createSerializableStateInvariantMiddleware),\n/* harmony export */   createSlice: () => (/* binding */ createSlice),\n/* harmony export */   createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.createStore),\n/* harmony export */   current: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.current),\n/* harmony export */   findNonSerializableValue: () => (/* binding */ findNonSerializableValue),\n/* harmony export */   formatProdErrorMessage: () => (/* binding */ formatProdErrorMessage),\n/* harmony export */   freeze: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.freeze),\n/* harmony export */   isAction: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isAction),\n/* harmony export */   isActionCreator: () => (/* binding */ isActionCreator),\n/* harmony export */   isAllOf: () => (/* binding */ isAllOf),\n/* harmony export */   isAnyOf: () => (/* binding */ isAnyOf),\n/* harmony export */   isAsyncThunkAction: () => (/* binding */ isAsyncThunkAction),\n/* harmony export */   isDraft: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.isDraft),\n/* harmony export */   isFluxStandardAction: () => (/* binding */ isFSA),\n/* harmony export */   isFulfilled: () => (/* binding */ isFulfilled),\n/* harmony export */   isImmutableDefault: () => (/* binding */ isImmutableDefault),\n/* harmony export */   isPending: () => (/* binding */ isPending),\n/* harmony export */   isPlain: () => (/* binding */ isPlain),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject),\n/* harmony export */   isRejected: () => (/* binding */ isRejected),\n/* harmony export */   isRejectedWithValue: () => (/* binding */ isRejectedWithValue),\n/* harmony export */   legacy_createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.legacy_createStore),\n/* harmony export */   lruMemoize: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.lruMemoize),\n/* harmony export */   miniSerializeError: () => (/* binding */ miniSerializeError),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   original: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.original),\n/* harmony export */   prepareAutoBatched: () => (/* binding */ prepareAutoBatched),\n/* harmony export */   removeListener: () => (/* binding */ removeListener),\n/* harmony export */   unwrapResult: () => (/* binding */ unwrapResult),\n/* harmony export */   weakMapMemoize: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize)\n/* harmony export */ });\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.mjs\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/reselect.mjs\");\n/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-thunk */ \"(ssr)/./node_modules/@reduxjs/toolkit/node_modules/redux-thunk/dist/redux-thunk.mjs\");\n// src/index.ts\n\n\n\n\n// src/createDraftSafeSelector.ts\n\n\nvar createDraftSafeSelectorCreator = (...args) => {\n  const createSelector2 = (0,reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator)(...args);\n  const createDraftSafeSelector2 = Object.assign((...args2) => {\n    const selector = createSelector2(...args2);\n    const wrappedSelector = (value, ...rest) => selector((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value, ...rest);\n    Object.assign(wrappedSelector, selector);\n    return wrappedSelector;\n  }, {\n    withTypes: () => createDraftSafeSelector2\n  });\n  return createDraftSafeSelector2;\n};\nvar createDraftSafeSelector = /* @__PURE__ */ createDraftSafeSelectorCreator(reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize);\n\n// src/configureStore.ts\n\n\n// src/devtoolsExtension.ts\n\nvar composeWithDevTools = typeof window !== \"undefined\" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {\n  if (arguments.length === 0) return void 0;\n  if (typeof arguments[0] === \"object\") return redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n  return redux__WEBPACK_IMPORTED_MODULE_0__.compose.apply(null, arguments);\n};\nvar devToolsEnhancer = typeof window !== \"undefined\" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {\n  return function(noop3) {\n    return noop3;\n  };\n};\n\n// src/getDefaultMiddleware.ts\n\n\n// src/createAction.ts\n\n\n// src/tsHelpers.ts\nvar hasMatchFunction = (v) => {\n  return v && typeof v.match === \"function\";\n};\n\n// src/createAction.ts\nfunction createAction(type, prepareAction) {\n  function actionCreator(...args) {\n    if (prepareAction) {\n      let prepared = prepareAction(...args);\n      if (!prepared) {\n        throw new Error( false ? 0 : \"prepareAction did not return an object\");\n      }\n      return {\n        type,\n        payload: prepared.payload,\n        ...\"meta\" in prepared && {\n          meta: prepared.meta\n        },\n        ...\"error\" in prepared && {\n          error: prepared.error\n        }\n      };\n    }\n    return {\n      type,\n      payload: args[0]\n    };\n  }\n  actionCreator.toString = () => `${type}`;\n  actionCreator.type = type;\n  actionCreator.match = (action) => (0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && action.type === type;\n  return actionCreator;\n}\nfunction isActionCreator(action) {\n  return typeof action === \"function\" && \"type\" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it\n  hasMatchFunction(action);\n}\nfunction isFSA(action) {\n  return (0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && Object.keys(action).every(isValidKey);\n}\nfunction isValidKey(key) {\n  return [\"type\", \"payload\", \"error\", \"meta\"].indexOf(key) > -1;\n}\n\n// src/actionCreatorInvariantMiddleware.ts\nfunction getMessage(type) {\n  const splitType = type ? `${type}`.split(\"/\") : [];\n  const actionName = splitType[splitType.length - 1] || \"actionCreator\";\n  return `Detected an action creator with type \"${type || \"unknown\"}\" being dispatched. \nMake sure you're calling the action creator before dispatching, i.e. \\`dispatch(${actionName}())\\` instead of \\`dispatch(${actionName})\\`. This is necessary even if the action has no payload.`;\n}\nfunction createActionCreatorInvariantMiddleware(options = {}) {\n  if (false) {}\n  const {\n    isActionCreator: isActionCreator2 = isActionCreator\n  } = options;\n  return () => (next) => (action) => {\n    if (isActionCreator2(action)) {\n      console.warn(getMessage(action.type));\n    }\n    return next(action);\n  };\n}\n\n// src/utils.ts\n\nfunction getTimeMeasureUtils(maxDelay, fnName) {\n  let elapsed = 0;\n  return {\n    measureTime(fn) {\n      const started = Date.now();\n      try {\n        return fn();\n      } finally {\n        const finished = Date.now();\n        elapsed += finished - started;\n      }\n    },\n    warnIfExceeded() {\n      if (elapsed > maxDelay) {\n        console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that.`);\n      }\n    }\n  };\n}\nvar Tuple = class _Tuple extends Array {\n  constructor(...items) {\n    super(...items);\n    Object.setPrototypeOf(this, _Tuple.prototype);\n  }\n  static get [Symbol.species]() {\n    return _Tuple;\n  }\n  concat(...arr) {\n    return super.concat.apply(this, arr);\n  }\n  prepend(...arr) {\n    if (arr.length === 1 && Array.isArray(arr[0])) {\n      return new _Tuple(...arr[0].concat(this));\n    }\n    return new _Tuple(...arr.concat(this));\n  }\n};\nfunction freezeDraftable(val) {\n  return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(val) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(val, () => {\n  }) : val;\n}\nfunction getOrInsertComputed(map, key, compute) {\n  if (map.has(key)) return map.get(key);\n  return map.set(key, compute(key)).get(key);\n}\n\n// src/immutableStateInvariantMiddleware.ts\nfunction isImmutableDefault(value) {\n  return typeof value !== \"object\" || value == null || Object.isFrozen(value);\n}\nfunction trackForMutations(isImmutable, ignorePaths, obj) {\n  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);\n  return {\n    detectMutations() {\n      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);\n    }\n  };\n}\nfunction trackProperties(isImmutable, ignorePaths = [], obj, path = \"\", checkedObjects = /* @__PURE__ */ new Set()) {\n  const tracked = {\n    value: obj\n  };\n  if (!isImmutable(obj) && !checkedObjects.has(obj)) {\n    checkedObjects.add(obj);\n    tracked.children = {};\n    for (const key in obj) {\n      const childPath = path ? path + \".\" + key : key;\n      if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\n        continue;\n      }\n      tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);\n    }\n  }\n  return tracked;\n}\nfunction detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path = \"\") {\n  const prevObj = trackedProperty ? trackedProperty.value : void 0;\n  const sameRef = prevObj === obj;\n  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\n    return {\n      wasMutated: true,\n      path\n    };\n  }\n  if (isImmutable(prevObj) || isImmutable(obj)) {\n    return {\n      wasMutated: false\n    };\n  }\n  const keysToDetect = {};\n  for (let key in trackedProperty.children) {\n    keysToDetect[key] = true;\n  }\n  for (let key in obj) {\n    keysToDetect[key] = true;\n  }\n  const hasIgnoredPaths = ignoredPaths.length > 0;\n  for (let key in keysToDetect) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (hasIgnoredPaths) {\n      const hasMatches = ignoredPaths.some((ignored) => {\n        if (ignored instanceof RegExp) {\n          return ignored.test(nestedPath);\n        }\n        return nestedPath === ignored;\n      });\n      if (hasMatches) {\n        continue;\n      }\n    }\n    const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);\n    if (result.wasMutated) {\n      return result;\n    }\n  }\n  return {\n    wasMutated: false\n  };\n}\nfunction createImmutableStateInvariantMiddleware(options = {}) {\n  if (false) {} else {\n    let stringify2 = function(obj, serializer, indent, decycler) {\n      return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);\n    }, getSerialize2 = function(serializer, decycler) {\n      let stack = [], keys = [];\n      if (!decycler) decycler = function(_, value) {\n        if (stack[0] === value) return \"[Circular ~]\";\n        return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n      };\n      return function(key, value) {\n        if (stack.length > 0) {\n          var thisPos = stack.indexOf(this);\n          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n          ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n          if (~stack.indexOf(value)) value = decycler.call(this, key, value);\n        } else stack.push(value);\n        return serializer == null ? value : serializer.call(this, key, value);\n      };\n    };\n    var stringify = stringify2, getSerialize = getSerialize2;\n    let {\n      isImmutable = isImmutableDefault,\n      ignoredPaths,\n      warnAfter = 32\n    } = options;\n    const track = trackForMutations.bind(null, isImmutable, ignoredPaths);\n    return ({\n      getState\n    }) => {\n      let state = getState();\n      let tracker = track(state);\n      let result;\n      return (next) => (action) => {\n        const measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\n        measureUtils.measureTime(() => {\n          state = getState();\n          result = tracker.detectMutations();\n          tracker = track(state);\n          if (result.wasMutated) {\n            throw new Error( false ? 0 : `A state mutation was detected between dispatches, in the path '${result.path || \"\"}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n          }\n        });\n        const dispatchedAction = next(action);\n        measureUtils.measureTime(() => {\n          state = getState();\n          result = tracker.detectMutations();\n          tracker = track(state);\n          if (result.wasMutated) {\n            throw new Error( false ? 0 : `A state mutation was detected inside a dispatch, in the path: ${result.path || \"\"}. Take a look at the reducer(s) handling the action ${stringify2(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n          }\n        });\n        measureUtils.warnIfExceeded();\n        return dispatchedAction;\n      };\n    };\n  }\n}\n\n// src/serializableStateInvariantMiddleware.ts\n\nfunction isPlain(val) {\n  const type = typeof val;\n  return val == null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || (0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(val);\n}\nfunction findNonSerializableValue(value, path = \"\", isSerializable = isPlain, getEntries, ignoredPaths = [], cache) {\n  let foundNestedSerializable;\n  if (!isSerializable(value)) {\n    return {\n      keyPath: path || \"<root>\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  if (cache?.has(value)) return false;\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value);\n  const hasIgnoredPaths = ignoredPaths.length > 0;\n  for (const [key, nestedValue] of entries) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (hasIgnoredPaths) {\n      const hasMatches = ignoredPaths.some((ignored) => {\n        if (ignored instanceof RegExp) {\n          return ignored.test(nestedPath);\n        }\n        return nestedPath === ignored;\n      });\n      if (hasMatches) {\n        continue;\n      }\n    }\n    if (!isSerializable(nestedValue)) {\n      return {\n        keyPath: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);\n      if (foundNestedSerializable) {\n        return foundNestedSerializable;\n      }\n    }\n  }\n  if (cache && isNestedFrozen(value)) cache.add(value);\n  return false;\n}\nfunction isNestedFrozen(value) {\n  if (!Object.isFrozen(value)) return false;\n  for (const nestedValue of Object.values(value)) {\n    if (typeof nestedValue !== \"object\" || nestedValue === null) continue;\n    if (!isNestedFrozen(nestedValue)) return false;\n  }\n  return true;\n}\nfunction createSerializableStateInvariantMiddleware(options = {}) {\n  if (false) {} else {\n    const {\n      isSerializable = isPlain,\n      getEntries,\n      ignoredActions = [],\n      ignoredActionPaths = [\"meta.arg\", \"meta.baseQueryMeta\"],\n      ignoredPaths = [],\n      warnAfter = 32,\n      ignoreState = false,\n      ignoreActions = false,\n      disableCache = false\n    } = options;\n    const cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;\n    return (storeAPI) => (next) => (action) => {\n      if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n        return next(action);\n      }\n      const result = next(action);\n      const measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\n      if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\n        measureUtils.measureTime(() => {\n          const foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths, cache);\n          if (foundActionNonSerializableValue) {\n            const {\n              keyPath,\n              value\n            } = foundActionNonSerializableValue;\n            console.error(`A non-serializable value was detected in an action, in the path: \\`${keyPath}\\`. Value:`, value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\n          }\n        });\n      }\n      if (!ignoreState) {\n        measureUtils.measureTime(() => {\n          const state = storeAPI.getState();\n          const foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths, cache);\n          if (foundStateNonSerializableValue) {\n            const {\n              keyPath,\n              value\n            } = foundStateNonSerializableValue;\n            console.error(`A non-serializable value was detected in the state, in the path: \\`${keyPath}\\`. Value:`, value, `\nTake a look at the reducer(s) handling this action type: ${action.type}.\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);\n          }\n        });\n        measureUtils.warnIfExceeded();\n      }\n      return result;\n    };\n  }\n}\n\n// src/getDefaultMiddleware.ts\nfunction isBoolean(x) {\n  return typeof x === \"boolean\";\n}\nvar buildGetDefaultMiddleware = () => function getDefaultMiddleware(options) {\n  const {\n    thunk = true,\n    immutableCheck = true,\n    serializableCheck = true,\n    actionCreatorCheck = true\n  } = options ?? {};\n  let middlewareArray = new Tuple();\n  if (thunk) {\n    if (isBoolean(thunk)) {\n      middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__.thunk);\n    } else {\n      middlewareArray.push((0,redux_thunk__WEBPACK_IMPORTED_MODULE_3__.withExtraArgument)(thunk.extraArgument));\n    }\n  }\n  if (true) {\n    if (immutableCheck) {\n      let immutableOptions = {};\n      if (!isBoolean(immutableCheck)) {\n        immutableOptions = immutableCheck;\n      }\n      middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));\n    }\n    if (serializableCheck) {\n      let serializableOptions = {};\n      if (!isBoolean(serializableCheck)) {\n        serializableOptions = serializableCheck;\n      }\n      middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));\n    }\n    if (actionCreatorCheck) {\n      let actionCreatorOptions = {};\n      if (!isBoolean(actionCreatorCheck)) {\n        actionCreatorOptions = actionCreatorCheck;\n      }\n      middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));\n    }\n  }\n  return middlewareArray;\n};\n\n// src/autoBatchEnhancer.ts\nvar SHOULD_AUTOBATCH = \"RTK_autoBatch\";\nvar prepareAutoBatched = () => (payload) => ({\n  payload,\n  meta: {\n    [SHOULD_AUTOBATCH]: true\n  }\n});\nvar createQueueWithTimer = (timeout) => {\n  return (notify) => {\n    setTimeout(notify, timeout);\n  };\n};\nvar autoBatchEnhancer = (options = {\n  type: \"raf\"\n}) => (next) => (...args) => {\n  const store = next(...args);\n  let notifying = true;\n  let shouldNotifyAtEndOfTick = false;\n  let notificationQueued = false;\n  const listeners = /* @__PURE__ */ new Set();\n  const queueCallback = options.type === \"tick\" ? queueMicrotask : options.type === \"raf\" ? (\n    // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.\n    typeof window !== \"undefined\" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10)\n  ) : options.type === \"callback\" ? options.queueNotification : createQueueWithTimer(options.timeout);\n  const notifyListeners = () => {\n    notificationQueued = false;\n    if (shouldNotifyAtEndOfTick) {\n      shouldNotifyAtEndOfTick = false;\n      listeners.forEach((l) => l());\n    }\n  };\n  return Object.assign({}, store, {\n    // Override the base `store.subscribe` method to keep original listeners\n    // from running if we're delaying notifications\n    subscribe(listener2) {\n      const wrappedListener = () => notifying && listener2();\n      const unsubscribe = store.subscribe(wrappedListener);\n      listeners.add(listener2);\n      return () => {\n        unsubscribe();\n        listeners.delete(listener2);\n      };\n    },\n    // Override the base `store.dispatch` method so that we can check actions\n    // for the `shouldAutoBatch` flag and determine if batching is active\n    dispatch(action) {\n      try {\n        notifying = !action?.meta?.[SHOULD_AUTOBATCH];\n        shouldNotifyAtEndOfTick = !notifying;\n        if (shouldNotifyAtEndOfTick) {\n          if (!notificationQueued) {\n            notificationQueued = true;\n            queueCallback(notifyListeners);\n          }\n        }\n        return store.dispatch(action);\n      } finally {\n        notifying = true;\n      }\n    }\n  });\n};\n\n// src/getDefaultEnhancers.ts\nvar buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options) {\n  const {\n    autoBatch = true\n  } = options ?? {};\n  let enhancerArray = new Tuple(middlewareEnhancer);\n  if (autoBatch) {\n    enhancerArray.push(autoBatchEnhancer(typeof autoBatch === \"object\" ? autoBatch : void 0));\n  }\n  return enhancerArray;\n};\n\n// src/configureStore.ts\nfunction configureStore(options) {\n  const getDefaultMiddleware = buildGetDefaultMiddleware();\n  const {\n    reducer = void 0,\n    middleware,\n    devTools = true,\n    preloadedState = void 0,\n    enhancers = void 0\n  } = options || {};\n  let rootReducer;\n  if (typeof reducer === \"function\") {\n    rootReducer = reducer;\n  } else if ((0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(reducer)) {\n    rootReducer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducer);\n  } else {\n    throw new Error( false ? 0 : \"`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers\");\n  }\n  if ( true && middleware && typeof middleware !== \"function\") {\n    throw new Error( false ? 0 : \"`middleware` field must be a callback\");\n  }\n  let finalMiddleware;\n  if (typeof middleware === \"function\") {\n    finalMiddleware = middleware(getDefaultMiddleware);\n    if ( true && !Array.isArray(finalMiddleware)) {\n      throw new Error( false ? 0 : \"when using a middleware builder function, an array of middleware must be returned\");\n    }\n  } else {\n    finalMiddleware = getDefaultMiddleware();\n  }\n  if ( true && finalMiddleware.some((item) => typeof item !== \"function\")) {\n    throw new Error( false ? 0 : \"each middleware provided to configureStore must be a function\");\n  }\n  let finalCompose = redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n  if (devTools) {\n    finalCompose = composeWithDevTools({\n      // Enable capture of stack traces for dispatched Redux actions\n      trace: \"development\" !== \"production\",\n      ...typeof devTools === \"object\" && devTools\n    });\n  }\n  const middlewareEnhancer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware)(...finalMiddleware);\n  const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);\n  if ( true && enhancers && typeof enhancers !== \"function\") {\n    throw new Error( false ? 0 : \"`enhancers` field must be a callback\");\n  }\n  let storeEnhancers = typeof enhancers === \"function\" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();\n  if ( true && !Array.isArray(storeEnhancers)) {\n    throw new Error( false ? 0 : \"`enhancers` callback must return an array\");\n  }\n  if ( true && storeEnhancers.some((item) => typeof item !== \"function\")) {\n    throw new Error( false ? 0 : \"each enhancer provided to configureStore must be a function\");\n  }\n  if ( true && finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {\n    console.error(\"middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`\");\n  }\n  const composedEnhancer = finalCompose(...storeEnhancers);\n  return (0,redux__WEBPACK_IMPORTED_MODULE_0__.createStore)(rootReducer, preloadedState, composedEnhancer);\n}\n\n// src/createReducer.ts\n\n\n// src/mapBuilders.ts\nfunction executeReducerBuilderCallback(builderCallback) {\n  const actionsMap = {};\n  const actionMatchers = [];\n  let defaultCaseReducer;\n  const builder = {\n    addCase(typeOrActionCreator, reducer) {\n      if (true) {\n        if (actionMatchers.length > 0) {\n          throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addMatcher`\");\n        }\n        if (defaultCaseReducer) {\n          throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addDefaultCase`\");\n        }\n      }\n      const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n      if (!type) {\n        throw new Error( false ? 0 : \"`builder.addCase` cannot be called with an empty action type\");\n      }\n      if (type in actionsMap) {\n        throw new Error( false ? 0 : `\\`builder.addCase\\` cannot be called with two reducers for the same action type '${type}'`);\n      }\n      actionsMap[type] = reducer;\n      return builder;\n    },\n    addMatcher(matcher, reducer) {\n      if (true) {\n        if (defaultCaseReducer) {\n          throw new Error( false ? 0 : \"`builder.addMatcher` should only be called before calling `builder.addDefaultCase`\");\n        }\n      }\n      actionMatchers.push({\n        matcher,\n        reducer\n      });\n      return builder;\n    },\n    addDefaultCase(reducer) {\n      if (true) {\n        if (defaultCaseReducer) {\n          throw new Error( false ? 0 : \"`builder.addDefaultCase` can only be called once\");\n        }\n      }\n      defaultCaseReducer = reducer;\n      return builder;\n    }\n  };\n  builderCallback(builder);\n  return [actionsMap, actionMatchers, defaultCaseReducer];\n}\n\n// src/createReducer.ts\nfunction isStateFunction(x) {\n  return typeof x === \"function\";\n}\nfunction createReducer(initialState, mapOrBuilderCallback) {\n  if (true) {\n    if (typeof mapOrBuilderCallback === \"object\") {\n      throw new Error( false ? 0 : \"The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer\");\n    }\n  }\n  let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);\n  let getInitialState;\n  if (isStateFunction(initialState)) {\n    getInitialState = () => freezeDraftable(initialState());\n  } else {\n    const frozenInitialState = freezeDraftable(initialState);\n    getInitialState = () => frozenInitialState;\n  }\n  function reducer(state = getInitialState(), action) {\n    let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({\n      matcher\n    }) => matcher(action)).map(({\n      reducer: reducer2\n    }) => reducer2)];\n    if (caseReducers.filter((cr) => !!cr).length === 0) {\n      caseReducers = [finalDefaultCaseReducer];\n    }\n    return caseReducers.reduce((previousState, caseReducer) => {\n      if (caseReducer) {\n        if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(previousState)) {\n          const draft = previousState;\n          const result = caseReducer(draft, action);\n          if (result === void 0) {\n            return previousState;\n          }\n          return result;\n        } else if (!(0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(previousState)) {\n          const result = caseReducer(previousState, action);\n          if (result === void 0) {\n            if (previousState === null) {\n              return previousState;\n            }\n            throw Error(\"A case reducer on a non-draftable value must not return undefined\");\n          }\n          return result;\n        } else {\n          return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(previousState, (draft) => {\n            return caseReducer(draft, action);\n          });\n        }\n      }\n      return previousState;\n    }, state);\n  }\n  reducer.getInitialState = getInitialState;\n  return reducer;\n}\n\n// src/matchers.ts\nvar matches = (matcher, action) => {\n  if (hasMatchFunction(matcher)) {\n    return matcher.match(action);\n  } else {\n    return matcher(action);\n  }\n};\nfunction isAnyOf(...matchers) {\n  return (action) => {\n    return matchers.some((matcher) => matches(matcher, action));\n  };\n}\nfunction isAllOf(...matchers) {\n  return (action) => {\n    return matchers.every((matcher) => matches(matcher, action));\n  };\n}\nfunction hasExpectedRequestMetadata(action, validStatus) {\n  if (!action || !action.meta) return false;\n  const hasValidRequestId = typeof action.meta.requestId === \"string\";\n  const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\n  return hasValidRequestId && hasValidRequestStatus;\n}\nfunction isAsyncThunkArray(a) {\n  return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\n}\nfunction isPending(...asyncThunks) {\n  if (asyncThunks.length === 0) {\n    return (action) => hasExpectedRequestMetadata(action, [\"pending\"]);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isPending()(asyncThunks[0]);\n  }\n  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.pending));\n}\nfunction isRejected(...asyncThunks) {\n  if (asyncThunks.length === 0) {\n    return (action) => hasExpectedRequestMetadata(action, [\"rejected\"]);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isRejected()(asyncThunks[0]);\n  }\n  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.rejected));\n}\nfunction isRejectedWithValue(...asyncThunks) {\n  const hasFlag = (action) => {\n    return action && action.meta && action.meta.rejectedWithValue;\n  };\n  if (asyncThunks.length === 0) {\n    return isAllOf(isRejected(...asyncThunks), hasFlag);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isRejectedWithValue()(asyncThunks[0]);\n  }\n  return isAllOf(isRejected(...asyncThunks), hasFlag);\n}\nfunction isFulfilled(...asyncThunks) {\n  if (asyncThunks.length === 0) {\n    return (action) => hasExpectedRequestMetadata(action, [\"fulfilled\"]);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isFulfilled()(asyncThunks[0]);\n  }\n  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.fulfilled));\n}\nfunction isAsyncThunkAction(...asyncThunks) {\n  if (asyncThunks.length === 0) {\n    return (action) => hasExpectedRequestMetadata(action, [\"pending\", \"fulfilled\", \"rejected\"]);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isAsyncThunkAction()(asyncThunks[0]);\n  }\n  return isAnyOf(...asyncThunks.flatMap((asyncThunk) => [asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled]));\n}\n\n// src/nanoid.ts\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\nvar nanoid = (size = 21) => {\n  let id = \"\";\n  let i = size;\n  while (i--) {\n    id += urlAlphabet[Math.random() * 64 | 0];\n  }\n  return id;\n};\n\n// src/createAsyncThunk.ts\nvar commonProperties = [\"name\", \"message\", \"stack\", \"code\"];\nvar RejectWithValue = class {\n  constructor(payload, meta) {\n    this.payload = payload;\n    this.meta = meta;\n  }\n  /*\n  type-only property to distinguish between RejectWithValue and FulfillWithMeta\n  does not exist at runtime\n  */\n  _type;\n};\nvar FulfillWithMeta = class {\n  constructor(payload, meta) {\n    this.payload = payload;\n    this.meta = meta;\n  }\n  /*\n  type-only property to distinguish between RejectWithValue and FulfillWithMeta\n  does not exist at runtime\n  */\n  _type;\n};\nvar miniSerializeError = (value) => {\n  if (typeof value === \"object\" && value !== null) {\n    const simpleError = {};\n    for (const property of commonProperties) {\n      if (typeof value[property] === \"string\") {\n        simpleError[property] = value[property];\n      }\n    }\n    return simpleError;\n  }\n  return {\n    message: String(value)\n  };\n};\nvar externalAbortMessage = \"External signal was aborted\";\nvar createAsyncThunk = /* @__PURE__ */ (() => {\n  function createAsyncThunk2(typePrefix, payloadCreator, options) {\n    const fulfilled = createAction(typePrefix + \"/fulfilled\", (payload, requestId, arg, meta) => ({\n      payload,\n      meta: {\n        ...meta || {},\n        arg,\n        requestId,\n        requestStatus: \"fulfilled\"\n      }\n    }));\n    const pending = createAction(typePrefix + \"/pending\", (requestId, arg, meta) => ({\n      payload: void 0,\n      meta: {\n        ...meta || {},\n        arg,\n        requestId,\n        requestStatus: \"pending\"\n      }\n    }));\n    const rejected = createAction(typePrefix + \"/rejected\", (error, requestId, arg, payload, meta) => ({\n      payload,\n      error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\n      meta: {\n        ...meta || {},\n        arg,\n        requestId,\n        rejectedWithValue: !!payload,\n        requestStatus: \"rejected\",\n        aborted: error?.name === \"AbortError\",\n        condition: error?.name === \"ConditionError\"\n      }\n    }));\n    function actionCreator(arg, {\n      signal\n    } = {}) {\n      return (dispatch, getState, extra) => {\n        const requestId = options?.idGenerator ? options.idGenerator(arg) : nanoid();\n        const abortController = new AbortController();\n        let abortHandler;\n        let abortReason;\n        function abort(reason) {\n          abortReason = reason;\n          abortController.abort();\n        }\n        if (signal) {\n          if (signal.aborted) {\n            abort(externalAbortMessage);\n          } else {\n            signal.addEventListener(\"abort\", () => abort(externalAbortMessage), {\n              once: true\n            });\n          }\n        }\n        const promise = async function() {\n          let finalAction;\n          try {\n            let conditionResult = options?.condition?.(arg, {\n              getState,\n              extra\n            });\n            if (isThenable(conditionResult)) {\n              conditionResult = await conditionResult;\n            }\n            if (conditionResult === false || abortController.signal.aborted) {\n              throw {\n                name: \"ConditionError\",\n                message: \"Aborted due to condition callback returning false.\"\n              };\n            }\n            const abortedPromise = new Promise((_, reject) => {\n              abortHandler = () => {\n                reject({\n                  name: \"AbortError\",\n                  message: abortReason || \"Aborted\"\n                });\n              };\n              abortController.signal.addEventListener(\"abort\", abortHandler);\n            });\n            dispatch(pending(requestId, arg, options?.getPendingMeta?.({\n              requestId,\n              arg\n            }, {\n              getState,\n              extra\n            })));\n            finalAction = await Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {\n              dispatch,\n              getState,\n              extra,\n              requestId,\n              signal: abortController.signal,\n              abort,\n              rejectWithValue: (value, meta) => {\n                return new RejectWithValue(value, meta);\n              },\n              fulfillWithValue: (value, meta) => {\n                return new FulfillWithMeta(value, meta);\n              }\n            })).then((result) => {\n              if (result instanceof RejectWithValue) {\n                throw result;\n              }\n              if (result instanceof FulfillWithMeta) {\n                return fulfilled(result.payload, requestId, arg, result.meta);\n              }\n              return fulfilled(result, requestId, arg);\n            })]);\n          } catch (err) {\n            finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);\n          } finally {\n            if (abortHandler) {\n              abortController.signal.removeEventListener(\"abort\", abortHandler);\n            }\n          }\n          const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\n          if (!skipDispatch) {\n            dispatch(finalAction);\n          }\n          return finalAction;\n        }();\n        return Object.assign(promise, {\n          abort,\n          requestId,\n          arg,\n          unwrap() {\n            return promise.then(unwrapResult);\n          }\n        });\n      };\n    }\n    return Object.assign(actionCreator, {\n      pending,\n      rejected,\n      fulfilled,\n      settled: isAnyOf(rejected, fulfilled),\n      typePrefix\n    });\n  }\n  createAsyncThunk2.withTypes = () => createAsyncThunk2;\n  return createAsyncThunk2;\n})();\nfunction unwrapResult(action) {\n  if (action.meta && action.meta.rejectedWithValue) {\n    throw action.payload;\n  }\n  if (action.error) {\n    throw action.error;\n  }\n  return action.payload;\n}\nfunction isThenable(value) {\n  return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\n}\n\n// src/createSlice.ts\nvar asyncThunkSymbol = /* @__PURE__ */ Symbol.for(\"rtk-slice-createasyncthunk\");\nvar asyncThunkCreator = {\n  [asyncThunkSymbol]: createAsyncThunk\n};\nvar ReducerType = /* @__PURE__ */ ((ReducerType2) => {\n  ReducerType2[\"reducer\"] = \"reducer\";\n  ReducerType2[\"reducerWithPrepare\"] = \"reducerWithPrepare\";\n  ReducerType2[\"asyncThunk\"] = \"asyncThunk\";\n  return ReducerType2;\n})(ReducerType || {});\nfunction getType(slice, actionKey) {\n  return `${slice}/${actionKey}`;\n}\nfunction buildCreateSlice({\n  creators\n} = {}) {\n  const cAT = creators?.asyncThunk?.[asyncThunkSymbol];\n  return function createSlice2(options) {\n    const {\n      name,\n      reducerPath = name\n    } = options;\n    if (!name) {\n      throw new Error( false ? 0 : \"`name` is a required option for createSlice\");\n    }\n    if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n      if (options.initialState === void 0) {\n        console.error(\"You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`\");\n      }\n    }\n    const reducers = (typeof options.reducers === \"function\" ? options.reducers(buildReducerCreators()) : options.reducers) || {};\n    const reducerNames = Object.keys(reducers);\n    const context = {\n      sliceCaseReducersByName: {},\n      sliceCaseReducersByType: {},\n      actionCreators: {},\n      sliceMatchers: []\n    };\n    const contextMethods = {\n      addCase(typeOrActionCreator, reducer2) {\n        const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n        if (!type) {\n          throw new Error( false ? 0 : \"`context.addCase` cannot be called with an empty action type\");\n        }\n        if (type in context.sliceCaseReducersByType) {\n          throw new Error( false ? 0 : \"`context.addCase` cannot be called with two reducers for the same action type: \" + type);\n        }\n        context.sliceCaseReducersByType[type] = reducer2;\n        return contextMethods;\n      },\n      addMatcher(matcher, reducer2) {\n        context.sliceMatchers.push({\n          matcher,\n          reducer: reducer2\n        });\n        return contextMethods;\n      },\n      exposeAction(name2, actionCreator) {\n        context.actionCreators[name2] = actionCreator;\n        return contextMethods;\n      },\n      exposeCaseReducer(name2, reducer2) {\n        context.sliceCaseReducersByName[name2] = reducer2;\n        return contextMethods;\n      }\n    };\n    reducerNames.forEach((reducerName) => {\n      const reducerDefinition = reducers[reducerName];\n      const reducerDetails = {\n        reducerName,\n        type: getType(name, reducerName),\n        createNotation: typeof options.reducers === \"function\"\n      };\n      if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {\n        handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);\n      } else {\n        handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);\n      }\n    });\n    function buildReducer() {\n      if (true) {\n        if (typeof options.extraReducers === \"object\") {\n          throw new Error( false ? 0 : \"The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice\");\n        }\n      }\n      const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers];\n      const finalCaseReducers = {\n        ...extraReducers,\n        ...context.sliceCaseReducersByType\n      };\n      return createReducer(options.initialState, (builder) => {\n        for (let key in finalCaseReducers) {\n          builder.addCase(key, finalCaseReducers[key]);\n        }\n        for (let sM of context.sliceMatchers) {\n          builder.addMatcher(sM.matcher, sM.reducer);\n        }\n        for (let m of actionMatchers) {\n          builder.addMatcher(m.matcher, m.reducer);\n        }\n        if (defaultCaseReducer) {\n          builder.addDefaultCase(defaultCaseReducer);\n        }\n      });\n    }\n    const selectSelf = (state) => state;\n    const injectedSelectorCache = /* @__PURE__ */ new Map();\n    let _reducer;\n    function reducer(state, action) {\n      if (!_reducer) _reducer = buildReducer();\n      return _reducer(state, action);\n    }\n    function getInitialState() {\n      if (!_reducer) _reducer = buildReducer();\n      return _reducer.getInitialState();\n    }\n    function makeSelectorProps(reducerPath2, injected = false) {\n      function selectSlice(state) {\n        let sliceState = state[reducerPath2];\n        if (typeof sliceState === \"undefined\") {\n          if (injected) {\n            sliceState = getInitialState();\n          } else if (true) {\n            throw new Error( false ? 0 : \"selectSlice returned undefined for an uninjected slice reducer\");\n          }\n        }\n        return sliceState;\n      }\n      function getSelectors(selectState = selectSelf) {\n        const selectorCache = getOrInsertComputed(injectedSelectorCache, injected, () => /* @__PURE__ */ new WeakMap());\n        return getOrInsertComputed(selectorCache, selectState, () => {\n          const map = {};\n          for (const [name2, selector] of Object.entries(options.selectors ?? {})) {\n            map[name2] = wrapSelector(selector, selectState, getInitialState, injected);\n          }\n          return map;\n        });\n      }\n      return {\n        reducerPath: reducerPath2,\n        getSelectors,\n        get selectors() {\n          return getSelectors(selectSlice);\n        },\n        selectSlice\n      };\n    }\n    const slice = {\n      name,\n      reducer,\n      actions: context.actionCreators,\n      caseReducers: context.sliceCaseReducersByName,\n      getInitialState,\n      ...makeSelectorProps(reducerPath),\n      injectInto(injectable, {\n        reducerPath: pathOpt,\n        ...config\n      } = {}) {\n        const newReducerPath = pathOpt ?? reducerPath;\n        injectable.inject({\n          reducerPath: newReducerPath,\n          reducer\n        }, config);\n        return {\n          ...slice,\n          ...makeSelectorProps(newReducerPath, true)\n        };\n      }\n    };\n    return slice;\n  };\n}\nfunction wrapSelector(selector, selectState, getInitialState, injected) {\n  function wrapper(rootState, ...args) {\n    let sliceState = selectState(rootState);\n    if (typeof sliceState === \"undefined\") {\n      if (injected) {\n        sliceState = getInitialState();\n      } else if (true) {\n        throw new Error( false ? 0 : \"selectState returned undefined for an uninjected slice reducer\");\n      }\n    }\n    return selector(sliceState, ...args);\n  }\n  wrapper.unwrapped = selector;\n  return wrapper;\n}\nvar createSlice = /* @__PURE__ */ buildCreateSlice();\nfunction buildReducerCreators() {\n  function asyncThunk(payloadCreator, config) {\n    return {\n      _reducerDefinitionType: \"asyncThunk\" /* asyncThunk */,\n      payloadCreator,\n      ...config\n    };\n  }\n  asyncThunk.withTypes = () => asyncThunk;\n  return {\n    reducer(caseReducer) {\n      return Object.assign({\n        // hack so the wrapping function has the same name as the original\n        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original\n        [caseReducer.name](...args) {\n          return caseReducer(...args);\n        }\n      }[caseReducer.name], {\n        _reducerDefinitionType: \"reducer\" /* reducer */\n      });\n    },\n    preparedReducer(prepare, reducer) {\n      return {\n        _reducerDefinitionType: \"reducerWithPrepare\" /* reducerWithPrepare */,\n        prepare,\n        reducer\n      };\n    },\n    asyncThunk\n  };\n}\nfunction handleNormalReducerDefinition({\n  type,\n  reducerName,\n  createNotation\n}, maybeReducerWithPrepare, context) {\n  let caseReducer;\n  let prepareCallback;\n  if (\"reducer\" in maybeReducerWithPrepare) {\n    if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {\n      throw new Error( false ? 0 : \"Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.\");\n    }\n    caseReducer = maybeReducerWithPrepare.reducer;\n    prepareCallback = maybeReducerWithPrepare.prepare;\n  } else {\n    caseReducer = maybeReducerWithPrepare;\n  }\n  context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));\n}\nfunction isAsyncThunkSliceReducerDefinition(reducerDefinition) {\n  return reducerDefinition._reducerDefinitionType === \"asyncThunk\" /* asyncThunk */;\n}\nfunction isCaseReducerWithPrepareDefinition(reducerDefinition) {\n  return reducerDefinition._reducerDefinitionType === \"reducerWithPrepare\" /* reducerWithPrepare */;\n}\nfunction handleThunkCaseReducerDefinition({\n  type,\n  reducerName\n}, reducerDefinition, context, cAT) {\n  if (!cAT) {\n    throw new Error( false ? 0 : \"Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.\");\n  }\n  const {\n    payloadCreator,\n    fulfilled,\n    pending,\n    rejected,\n    settled,\n    options\n  } = reducerDefinition;\n  const thunk = cAT(type, payloadCreator, options);\n  context.exposeAction(reducerName, thunk);\n  if (fulfilled) {\n    context.addCase(thunk.fulfilled, fulfilled);\n  }\n  if (pending) {\n    context.addCase(thunk.pending, pending);\n  }\n  if (rejected) {\n    context.addCase(thunk.rejected, rejected);\n  }\n  if (settled) {\n    context.addMatcher(thunk.settled, settled);\n  }\n  context.exposeCaseReducer(reducerName, {\n    fulfilled: fulfilled || noop,\n    pending: pending || noop,\n    rejected: rejected || noop,\n    settled: settled || noop\n  });\n}\nfunction noop() {\n}\n\n// src/entities/entity_state.ts\nfunction getInitialEntityState() {\n  return {\n    ids: [],\n    entities: {}\n  };\n}\nfunction createInitialStateFactory(stateAdapter) {\n  function getInitialState(additionalState = {}, entities) {\n    const state = Object.assign(getInitialEntityState(), additionalState);\n    return entities ? stateAdapter.setAll(state, entities) : state;\n  }\n  return {\n    getInitialState\n  };\n}\n\n// src/entities/state_selectors.ts\nfunction createSelectorsFactory() {\n  function getSelectors(selectState, options = {}) {\n    const {\n      createSelector: createSelector2 = createDraftSafeSelector\n    } = options;\n    const selectIds = (state) => state.ids;\n    const selectEntities = (state) => state.entities;\n    const selectAll = createSelector2(selectIds, selectEntities, (ids, entities) => ids.map((id) => entities[id]));\n    const selectId = (_, id) => id;\n    const selectById = (entities, id) => entities[id];\n    const selectTotal = createSelector2(selectIds, (ids) => ids.length);\n    if (!selectState) {\n      return {\n        selectIds,\n        selectEntities,\n        selectAll,\n        selectTotal,\n        selectById: createSelector2(selectEntities, selectId, selectById)\n      };\n    }\n    const selectGlobalizedEntities = createSelector2(selectState, selectEntities);\n    return {\n      selectIds: createSelector2(selectState, selectIds),\n      selectEntities: selectGlobalizedEntities,\n      selectAll: createSelector2(selectState, selectAll),\n      selectTotal: createSelector2(selectState, selectTotal),\n      selectById: createSelector2(selectGlobalizedEntities, selectId, selectById)\n    };\n  }\n  return {\n    getSelectors\n  };\n}\n\n// src/entities/state_adapter.ts\n\nvar isDraftTyped = immer__WEBPACK_IMPORTED_MODULE_2__.isDraft;\nfunction createSingleArgumentStateOperator(mutator) {\n  const operator = createStateOperator((_, state) => mutator(state));\n  return function operation(state) {\n    return operator(state, void 0);\n  };\n}\nfunction createStateOperator(mutator) {\n  return function operation(state, arg) {\n    function isPayloadActionArgument(arg2) {\n      return isFSA(arg2);\n    }\n    const runMutator = (draft) => {\n      if (isPayloadActionArgument(arg)) {\n        mutator(arg.payload, draft);\n      } else {\n        mutator(arg, draft);\n      }\n    };\n    if (isDraftTyped(state)) {\n      runMutator(state);\n      return state;\n    }\n    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(state, runMutator);\n  };\n}\n\n// src/entities/utils.ts\n\nfunction selectIdValue(entity, selectId) {\n  const key = selectId(entity);\n  if ( true && key === void 0) {\n    console.warn(\"The entity passed to the `selectId` implementation returned undefined.\", \"You should probably provide your own `selectId` implementation.\", \"The entity that was passed:\", entity, \"The `selectId` implementation:\", selectId.toString());\n  }\n  return key;\n}\nfunction ensureEntitiesArray(entities) {\n  if (!Array.isArray(entities)) {\n    entities = Object.values(entities);\n  }\n  return entities;\n}\nfunction getCurrent(value) {\n  return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value;\n}\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\n  newEntities = ensureEntitiesArray(newEntities);\n  const existingIdsArray = getCurrent(state.ids);\n  const existingIds = new Set(existingIdsArray);\n  const added = [];\n  const updated = [];\n  for (const entity of newEntities) {\n    const id = selectIdValue(entity, selectId);\n    if (existingIds.has(id)) {\n      updated.push({\n        id,\n        changes: entity\n      });\n    } else {\n      added.push(entity);\n    }\n  }\n  return [added, updated, existingIdsArray];\n}\n\n// src/entities/unsorted_state_adapter.ts\nfunction createUnsortedStateAdapter(selectId) {\n  function addOneMutably(entity, state) {\n    const key = selectIdValue(entity, selectId);\n    if (key in state.entities) {\n      return;\n    }\n    state.ids.push(key);\n    state.entities[key] = entity;\n  }\n  function addManyMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    for (const entity of newEntities) {\n      addOneMutably(entity, state);\n    }\n  }\n  function setOneMutably(entity, state) {\n    const key = selectIdValue(entity, selectId);\n    if (!(key in state.entities)) {\n      state.ids.push(key);\n    }\n    ;\n    state.entities[key] = entity;\n  }\n  function setManyMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    for (const entity of newEntities) {\n      setOneMutably(entity, state);\n    }\n  }\n  function setAllMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    state.ids = [];\n    state.entities = {};\n    addManyMutably(newEntities, state);\n  }\n  function removeOneMutably(key, state) {\n    return removeManyMutably([key], state);\n  }\n  function removeManyMutably(keys, state) {\n    let didMutate = false;\n    keys.forEach((key) => {\n      if (key in state.entities) {\n        delete state.entities[key];\n        didMutate = true;\n      }\n    });\n    if (didMutate) {\n      state.ids = state.ids.filter((id) => id in state.entities);\n    }\n  }\n  function removeAllMutably(state) {\n    Object.assign(state, {\n      ids: [],\n      entities: {}\n    });\n  }\n  function takeNewKey(keys, update, state) {\n    const original3 = state.entities[update.id];\n    if (original3 === void 0) {\n      return false;\n    }\n    const updated = Object.assign({}, original3, update.changes);\n    const newKey = selectIdValue(updated, selectId);\n    const hasNewKey = newKey !== update.id;\n    if (hasNewKey) {\n      keys[update.id] = newKey;\n      delete state.entities[update.id];\n    }\n    ;\n    state.entities[newKey] = updated;\n    return hasNewKey;\n  }\n  function updateOneMutably(update, state) {\n    return updateManyMutably([update], state);\n  }\n  function updateManyMutably(updates, state) {\n    const newKeys = {};\n    const updatesPerEntity = {};\n    updates.forEach((update) => {\n      if (update.id in state.entities) {\n        updatesPerEntity[update.id] = {\n          id: update.id,\n          // Spreads ignore falsy values, so this works even if there isn't\n          // an existing update already at this key\n          changes: {\n            ...updatesPerEntity[update.id]?.changes,\n            ...update.changes\n          }\n        };\n      }\n    });\n    updates = Object.values(updatesPerEntity);\n    const didMutateEntities = updates.length > 0;\n    if (didMutateEntities) {\n      const didMutateIds = updates.filter((update) => takeNewKey(newKeys, update, state)).length > 0;\n      if (didMutateIds) {\n        state.ids = Object.values(state.entities).map((e) => selectIdValue(e, selectId));\n      }\n    }\n  }\n  function upsertOneMutably(entity, state) {\n    return upsertManyMutably([entity], state);\n  }\n  function upsertManyMutably(newEntities, state) {\n    const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\n    updateManyMutably(updated, state);\n    addManyMutably(added, state);\n  }\n  return {\n    removeAll: createSingleArgumentStateOperator(removeAllMutably),\n    addOne: createStateOperator(addOneMutably),\n    addMany: createStateOperator(addManyMutably),\n    setOne: createStateOperator(setOneMutably),\n    setMany: createStateOperator(setManyMutably),\n    setAll: createStateOperator(setAllMutably),\n    updateOne: createStateOperator(updateOneMutably),\n    updateMany: createStateOperator(updateManyMutably),\n    upsertOne: createStateOperator(upsertOneMutably),\n    upsertMany: createStateOperator(upsertManyMutably),\n    removeOne: createStateOperator(removeOneMutably),\n    removeMany: createStateOperator(removeManyMutably)\n  };\n}\n\n// src/entities/sorted_state_adapter.ts\nfunction findInsertIndex(sortedItems, item, comparisonFunction) {\n  let lowIndex = 0;\n  let highIndex = sortedItems.length;\n  while (lowIndex < highIndex) {\n    let middleIndex = lowIndex + highIndex >>> 1;\n    const currentItem = sortedItems[middleIndex];\n    const res = comparisonFunction(item, currentItem);\n    if (res >= 0) {\n      lowIndex = middleIndex + 1;\n    } else {\n      highIndex = middleIndex;\n    }\n  }\n  return lowIndex;\n}\nfunction insert(sortedItems, item, comparisonFunction) {\n  const insertAtIndex = findInsertIndex(sortedItems, item, comparisonFunction);\n  sortedItems.splice(insertAtIndex, 0, item);\n  return sortedItems;\n}\nfunction createSortedStateAdapter(selectId, comparer) {\n  const {\n    removeOne,\n    removeMany,\n    removeAll\n  } = createUnsortedStateAdapter(selectId);\n  function addOneMutably(entity, state) {\n    return addManyMutably([entity], state);\n  }\n  function addManyMutably(newEntities, state, existingIds) {\n    newEntities = ensureEntitiesArray(newEntities);\n    const existingKeys = new Set(existingIds ?? getCurrent(state.ids));\n    const models = newEntities.filter((model) => !existingKeys.has(selectIdValue(model, selectId)));\n    if (models.length !== 0) {\n      mergeFunction(state, models);\n    }\n  }\n  function setOneMutably(entity, state) {\n    return setManyMutably([entity], state);\n  }\n  function setManyMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    if (newEntities.length !== 0) {\n      for (const item of newEntities) {\n        delete state.entities[selectId(item)];\n      }\n      mergeFunction(state, newEntities);\n    }\n  }\n  function setAllMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    state.entities = {};\n    state.ids = [];\n    addManyMutably(newEntities, state, []);\n  }\n  function updateOneMutably(update, state) {\n    return updateManyMutably([update], state);\n  }\n  function updateManyMutably(updates, state) {\n    let appliedUpdates = false;\n    let replacedIds = false;\n    for (let update of updates) {\n      const entity = state.entities[update.id];\n      if (!entity) {\n        continue;\n      }\n      appliedUpdates = true;\n      Object.assign(entity, update.changes);\n      const newId = selectId(entity);\n      if (update.id !== newId) {\n        replacedIds = true;\n        delete state.entities[update.id];\n        const oldIndex = state.ids.indexOf(update.id);\n        state.ids[oldIndex] = newId;\n        state.entities[newId] = entity;\n      }\n    }\n    if (appliedUpdates) {\n      mergeFunction(state, [], appliedUpdates, replacedIds);\n    }\n  }\n  function upsertOneMutably(entity, state) {\n    return upsertManyMutably([entity], state);\n  }\n  function upsertManyMutably(newEntities, state) {\n    const [added, updated, existingIdsArray] = splitAddedUpdatedEntities(newEntities, selectId, state);\n    if (updated.length) {\n      updateManyMutably(updated, state);\n    }\n    if (added.length) {\n      addManyMutably(added, state, existingIdsArray);\n    }\n  }\n  function areArraysEqual(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] === b[i]) {\n        continue;\n      }\n      return false;\n    }\n    return true;\n  }\n  const mergeFunction = (state, addedItems, appliedUpdates, replacedIds) => {\n    const currentEntities = getCurrent(state.entities);\n    const currentIds = getCurrent(state.ids);\n    const stateEntities = state.entities;\n    let ids = currentIds;\n    if (replacedIds) {\n      ids = new Set(currentIds);\n    }\n    let sortedEntities = [];\n    for (const id of ids) {\n      const entity = currentEntities[id];\n      if (entity) {\n        sortedEntities.push(entity);\n      }\n    }\n    const wasPreviouslyEmpty = sortedEntities.length === 0;\n    for (const item of addedItems) {\n      stateEntities[selectId(item)] = item;\n      if (!wasPreviouslyEmpty) {\n        insert(sortedEntities, item, comparer);\n      }\n    }\n    if (wasPreviouslyEmpty) {\n      sortedEntities = addedItems.slice().sort(comparer);\n    } else if (appliedUpdates) {\n      sortedEntities.sort(comparer);\n    }\n    const newSortedIds = sortedEntities.map(selectId);\n    if (!areArraysEqual(currentIds, newSortedIds)) {\n      state.ids = newSortedIds;\n    }\n  };\n  return {\n    removeOne,\n    removeMany,\n    removeAll,\n    addOne: createStateOperator(addOneMutably),\n    updateOne: createStateOperator(updateOneMutably),\n    upsertOne: createStateOperator(upsertOneMutably),\n    setOne: createStateOperator(setOneMutably),\n    setMany: createStateOperator(setManyMutably),\n    setAll: createStateOperator(setAllMutably),\n    addMany: createStateOperator(addManyMutably),\n    updateMany: createStateOperator(updateManyMutably),\n    upsertMany: createStateOperator(upsertManyMutably)\n  };\n}\n\n// src/entities/create_adapter.ts\nfunction createEntityAdapter(options = {}) {\n  const {\n    selectId,\n    sortComparer\n  } = {\n    sortComparer: false,\n    selectId: (instance) => instance.id,\n    ...options\n  };\n  const stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n  const stateFactory = createInitialStateFactory(stateAdapter);\n  const selectorsFactory = createSelectorsFactory();\n  return {\n    selectId,\n    sortComparer,\n    ...stateFactory,\n    ...selectorsFactory,\n    ...stateAdapter\n  };\n}\n\n// src/listenerMiddleware/index.ts\n\n\n// src/listenerMiddleware/exceptions.ts\nvar task = \"task\";\nvar listener = \"listener\";\nvar completed = \"completed\";\nvar cancelled = \"cancelled\";\nvar taskCancelled = `task-${cancelled}`;\nvar taskCompleted = `task-${completed}`;\nvar listenerCancelled = `${listener}-${cancelled}`;\nvar listenerCompleted = `${listener}-${completed}`;\nvar TaskAbortError = class {\n  constructor(code) {\n    this.code = code;\n    this.message = `${task} ${cancelled} (reason: ${code})`;\n  }\n  name = \"TaskAbortError\";\n  message;\n};\n\n// src/listenerMiddleware/utils.ts\nvar assertFunction = (func, expected) => {\n  if (typeof func !== \"function\") {\n    throw new TypeError( false ? 0 : `${expected} is not a function`);\n  }\n};\nvar noop2 = () => {\n};\nvar catchRejection = (promise, onError = noop2) => {\n  promise.catch(onError);\n  return promise;\n};\nvar addAbortSignalListener = (abortSignal, callback) => {\n  abortSignal.addEventListener(\"abort\", callback, {\n    once: true\n  });\n  return () => abortSignal.removeEventListener(\"abort\", callback);\n};\nvar abortControllerWithReason = (abortController, reason) => {\n  const signal = abortController.signal;\n  if (signal.aborted) {\n    return;\n  }\n  if (!(\"reason\" in signal)) {\n    Object.defineProperty(signal, \"reason\", {\n      enumerable: true,\n      value: reason,\n      configurable: true,\n      writable: true\n    });\n  }\n  ;\n  abortController.abort(reason);\n};\n\n// src/listenerMiddleware/task.ts\nvar validateActive = (signal) => {\n  if (signal.aborted) {\n    const {\n      reason\n    } = signal;\n    throw new TaskAbortError(reason);\n  }\n};\nfunction raceWithSignal(signal, promise) {\n  let cleanup = noop2;\n  return new Promise((resolve, reject) => {\n    const notifyRejection = () => reject(new TaskAbortError(signal.reason));\n    if (signal.aborted) {\n      notifyRejection();\n      return;\n    }\n    cleanup = addAbortSignalListener(signal, notifyRejection);\n    promise.finally(() => cleanup()).then(resolve, reject);\n  }).finally(() => {\n    cleanup = noop2;\n  });\n}\nvar runTask = async (task2, cleanUp) => {\n  try {\n    await Promise.resolve();\n    const value = await task2();\n    return {\n      status: \"ok\",\n      value\n    };\n  } catch (error) {\n    return {\n      status: error instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\n      error\n    };\n  } finally {\n    cleanUp?.();\n  }\n};\nvar createPause = (signal) => {\n  return (promise) => {\n    return catchRejection(raceWithSignal(signal, promise).then((output) => {\n      validateActive(signal);\n      return output;\n    }));\n  };\n};\nvar createDelay = (signal) => {\n  const pause = createPause(signal);\n  return (timeoutMs) => {\n    return pause(new Promise((resolve) => setTimeout(resolve, timeoutMs)));\n  };\n};\n\n// src/listenerMiddleware/index.ts\nvar {\n  assign\n} = Object;\nvar INTERNAL_NIL_TOKEN = {};\nvar alm = \"listenerMiddleware\";\nvar createFork = (parentAbortSignal, parentBlockingPromises) => {\n  const linkControllers = (controller) => addAbortSignalListener(parentAbortSignal, () => abortControllerWithReason(controller, parentAbortSignal.reason));\n  return (taskExecutor, opts) => {\n    assertFunction(taskExecutor, \"taskExecutor\");\n    const childAbortController = new AbortController();\n    linkControllers(childAbortController);\n    const result = runTask(async () => {\n      validateActive(parentAbortSignal);\n      validateActive(childAbortController.signal);\n      const result2 = await taskExecutor({\n        pause: createPause(childAbortController.signal),\n        delay: createDelay(childAbortController.signal),\n        signal: childAbortController.signal\n      });\n      validateActive(childAbortController.signal);\n      return result2;\n    }, () => abortControllerWithReason(childAbortController, taskCompleted));\n    if (opts?.autoJoin) {\n      parentBlockingPromises.push(result.catch(noop2));\n    }\n    return {\n      result: createPause(parentAbortSignal)(result),\n      cancel() {\n        abortControllerWithReason(childAbortController, taskCancelled);\n      }\n    };\n  };\n};\nvar createTakePattern = (startListening, signal) => {\n  const take = async (predicate, timeout) => {\n    validateActive(signal);\n    let unsubscribe = () => {\n    };\n    const tuplePromise = new Promise((resolve, reject) => {\n      let stopListening = startListening({\n        predicate,\n        effect: (action, listenerApi) => {\n          listenerApi.unsubscribe();\n          resolve([action, listenerApi.getState(), listenerApi.getOriginalState()]);\n        }\n      });\n      unsubscribe = () => {\n        stopListening();\n        reject();\n      };\n    });\n    const promises = [tuplePromise];\n    if (timeout != null) {\n      promises.push(new Promise((resolve) => setTimeout(resolve, timeout, null)));\n    }\n    try {\n      const output = await raceWithSignal(signal, Promise.race(promises));\n      validateActive(signal);\n      return output;\n    } finally {\n      unsubscribe();\n    }\n  };\n  return (predicate, timeout) => catchRejection(take(predicate, timeout));\n};\nvar getListenerEntryPropsFrom = (options) => {\n  let {\n    type,\n    actionCreator,\n    matcher,\n    predicate,\n    effect\n  } = options;\n  if (type) {\n    predicate = createAction(type).match;\n  } else if (actionCreator) {\n    type = actionCreator.type;\n    predicate = actionCreator.match;\n  } else if (matcher) {\n    predicate = matcher;\n  } else if (predicate) {\n  } else {\n    throw new Error( false ? 0 : \"Creating or removing a listener requires one of the known fields for matching an action\");\n  }\n  assertFunction(effect, \"options.listener\");\n  return {\n    predicate,\n    type,\n    effect\n  };\n};\nvar createListenerEntry = /* @__PURE__ */ assign((options) => {\n  const {\n    type,\n    predicate,\n    effect\n  } = getListenerEntryPropsFrom(options);\n  const entry = {\n    id: nanoid(),\n    effect,\n    type,\n    predicate,\n    pending: /* @__PURE__ */ new Set(),\n    unsubscribe: () => {\n      throw new Error( false ? 0 : \"Unsubscribe not initialized\");\n    }\n  };\n  return entry;\n}, {\n  withTypes: () => createListenerEntry\n});\nvar findListenerEntry = (listenerMap, options) => {\n  const {\n    type,\n    effect,\n    predicate\n  } = getListenerEntryPropsFrom(options);\n  return Array.from(listenerMap.values()).find((entry) => {\n    const matchPredicateOrType = typeof type === \"string\" ? entry.type === type : entry.predicate === predicate;\n    return matchPredicateOrType && entry.effect === effect;\n  });\n};\nvar cancelActiveListeners = (entry) => {\n  entry.pending.forEach((controller) => {\n    abortControllerWithReason(controller, listenerCancelled);\n  });\n};\nvar createClearListenerMiddleware = (listenerMap) => {\n  return () => {\n    listenerMap.forEach(cancelActiveListeners);\n    listenerMap.clear();\n  };\n};\nvar safelyNotifyError = (errorHandler, errorToNotify, errorInfo) => {\n  try {\n    errorHandler(errorToNotify, errorInfo);\n  } catch (errorHandlerError) {\n    setTimeout(() => {\n      throw errorHandlerError;\n    }, 0);\n  }\n};\nvar addListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/add`), {\n  withTypes: () => addListener\n});\nvar clearAllListeners = /* @__PURE__ */ createAction(`${alm}/removeAll`);\nvar removeListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/remove`), {\n  withTypes: () => removeListener\n});\nvar defaultErrorHandler = (...args) => {\n  console.error(`${alm}/error`, ...args);\n};\nvar createListenerMiddleware = (middlewareOptions = {}) => {\n  const listenerMap = /* @__PURE__ */ new Map();\n  const {\n    extra,\n    onError = defaultErrorHandler\n  } = middlewareOptions;\n  assertFunction(onError, \"onError\");\n  const insertEntry = (entry) => {\n    entry.unsubscribe = () => listenerMap.delete(entry.id);\n    listenerMap.set(entry.id, entry);\n    return (cancelOptions) => {\n      entry.unsubscribe();\n      if (cancelOptions?.cancelActive) {\n        cancelActiveListeners(entry);\n      }\n    };\n  };\n  const startListening = (options) => {\n    const entry = findListenerEntry(listenerMap, options) ?? createListenerEntry(options);\n    return insertEntry(entry);\n  };\n  assign(startListening, {\n    withTypes: () => startListening\n  });\n  const stopListening = (options) => {\n    const entry = findListenerEntry(listenerMap, options);\n    if (entry) {\n      entry.unsubscribe();\n      if (options.cancelActive) {\n        cancelActiveListeners(entry);\n      }\n    }\n    return !!entry;\n  };\n  assign(stopListening, {\n    withTypes: () => stopListening\n  });\n  const notifyListener = async (entry, action, api, getOriginalState) => {\n    const internalTaskController = new AbortController();\n    const take = createTakePattern(startListening, internalTaskController.signal);\n    const autoJoinPromises = [];\n    try {\n      entry.pending.add(internalTaskController);\n      await Promise.resolve(entry.effect(\n        action,\n        // Use assign() rather than ... to avoid extra helper functions added to bundle\n        assign({}, api, {\n          getOriginalState,\n          condition: (predicate, timeout) => take(predicate, timeout).then(Boolean),\n          take,\n          delay: createDelay(internalTaskController.signal),\n          pause: createPause(internalTaskController.signal),\n          extra,\n          signal: internalTaskController.signal,\n          fork: createFork(internalTaskController.signal, autoJoinPromises),\n          unsubscribe: entry.unsubscribe,\n          subscribe: () => {\n            listenerMap.set(entry.id, entry);\n          },\n          cancelActiveListeners: () => {\n            entry.pending.forEach((controller, _, set) => {\n              if (controller !== internalTaskController) {\n                abortControllerWithReason(controller, listenerCancelled);\n                set.delete(controller);\n              }\n            });\n          },\n          cancel: () => {\n            abortControllerWithReason(internalTaskController, listenerCancelled);\n            entry.pending.delete(internalTaskController);\n          },\n          throwIfCancelled: () => {\n            validateActive(internalTaskController.signal);\n          }\n        })\n      ));\n    } catch (listenerError) {\n      if (!(listenerError instanceof TaskAbortError)) {\n        safelyNotifyError(onError, listenerError, {\n          raisedBy: \"effect\"\n        });\n      }\n    } finally {\n      await Promise.all(autoJoinPromises);\n      abortControllerWithReason(internalTaskController, listenerCompleted);\n      entry.pending.delete(internalTaskController);\n    }\n  };\n  const clearListenerMiddleware = createClearListenerMiddleware(listenerMap);\n  const middleware = (api) => (next) => (action) => {\n    if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n      return next(action);\n    }\n    if (addListener.match(action)) {\n      return startListening(action.payload);\n    }\n    if (clearAllListeners.match(action)) {\n      clearListenerMiddleware();\n      return;\n    }\n    if (removeListener.match(action)) {\n      return stopListening(action.payload);\n    }\n    let originalState = api.getState();\n    const getOriginalState = () => {\n      if (originalState === INTERNAL_NIL_TOKEN) {\n        throw new Error( false ? 0 : `${alm}: getOriginalState can only be called synchronously`);\n      }\n      return originalState;\n    };\n    let result;\n    try {\n      result = next(action);\n      if (listenerMap.size > 0) {\n        const currentState = api.getState();\n        const listenerEntries = Array.from(listenerMap.values());\n        for (const entry of listenerEntries) {\n          let runListener = false;\n          try {\n            runListener = entry.predicate(action, currentState, originalState);\n          } catch (predicateError) {\n            runListener = false;\n            safelyNotifyError(onError, predicateError, {\n              raisedBy: \"predicate\"\n            });\n          }\n          if (!runListener) {\n            continue;\n          }\n          notifyListener(entry, action, api, getOriginalState);\n        }\n      }\n    } finally {\n      originalState = INTERNAL_NIL_TOKEN;\n    }\n    return result;\n  };\n  return {\n    middleware,\n    startListening,\n    stopListening,\n    clearListeners: clearListenerMiddleware\n  };\n};\n\n// src/dynamicMiddleware/index.ts\n\nvar createMiddlewareEntry = (middleware) => ({\n  middleware,\n  applied: /* @__PURE__ */ new Map()\n});\nvar matchInstance = (instanceId) => (action) => action?.meta?.instanceId === instanceId;\nvar createDynamicMiddleware = () => {\n  const instanceId = nanoid();\n  const middlewareMap = /* @__PURE__ */ new Map();\n  const withMiddleware = Object.assign(createAction(\"dynamicMiddleware/add\", (...middlewares) => ({\n    payload: middlewares,\n    meta: {\n      instanceId\n    }\n  })), {\n    withTypes: () => withMiddleware\n  });\n  const addMiddleware = Object.assign(function addMiddleware2(...middlewares) {\n    middlewares.forEach((middleware2) => {\n      getOrInsertComputed(middlewareMap, middleware2, createMiddlewareEntry);\n    });\n  }, {\n    withTypes: () => addMiddleware\n  });\n  const getFinalMiddleware = (api) => {\n    const appliedMiddleware = Array.from(middlewareMap.values()).map((entry) => getOrInsertComputed(entry.applied, api, entry.middleware));\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.compose)(...appliedMiddleware);\n  };\n  const isWithMiddleware = isAllOf(withMiddleware, matchInstance(instanceId));\n  const middleware = (api) => (next) => (action) => {\n    if (isWithMiddleware(action)) {\n      addMiddleware(...action.payload);\n      return api.dispatch;\n    }\n    return getFinalMiddleware(api)(next)(action);\n  };\n  return {\n    middleware,\n    addMiddleware,\n    withMiddleware,\n    instanceId\n  };\n};\n\n// src/combineSlices.ts\n\nvar isSliceLike = (maybeSliceLike) => \"reducerPath\" in maybeSliceLike && typeof maybeSliceLike.reducerPath === \"string\";\nvar getReducers = (slices) => slices.flatMap((sliceOrMap) => isSliceLike(sliceOrMap) ? [[sliceOrMap.reducerPath, sliceOrMap.reducer]] : Object.entries(sliceOrMap));\nvar ORIGINAL_STATE = Symbol.for(\"rtk-state-proxy-original\");\nvar isStateProxy = (value) => !!value && !!value[ORIGINAL_STATE];\nvar stateProxyMap = /* @__PURE__ */ new WeakMap();\nvar createStateProxy = (state, reducerMap) => getOrInsertComputed(stateProxyMap, state, () => new Proxy(state, {\n  get: (target, prop, receiver) => {\n    if (prop === ORIGINAL_STATE) return target;\n    const result = Reflect.get(target, prop, receiver);\n    if (typeof result === \"undefined\") {\n      const reducer = reducerMap[prop.toString()];\n      if (reducer) {\n        const reducerResult = reducer(void 0, {\n          type: nanoid()\n        });\n        if (typeof reducerResult === \"undefined\") {\n          throw new Error( false ? 0 : `The slice reducer for key \"${prop.toString()}\" returned undefined when called for selector(). If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);\n        }\n        return reducerResult;\n      }\n    }\n    return result;\n  }\n}));\nvar original = (state) => {\n  if (!isStateProxy(state)) {\n    throw new Error( false ? 0 : \"original must be used on state Proxy\");\n  }\n  return state[ORIGINAL_STATE];\n};\nvar noopReducer = (state = {}) => state;\nfunction combineSlices(...slices) {\n  const reducerMap = Object.fromEntries(getReducers(slices));\n  const getReducer = () => Object.keys(reducerMap).length ? (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducerMap) : noopReducer;\n  let reducer = getReducer();\n  function combinedReducer(state, action) {\n    return reducer(state, action);\n  }\n  combinedReducer.withLazyLoadedSlices = () => combinedReducer;\n  const inject = (slice, config = {}) => {\n    const {\n      reducerPath,\n      reducer: reducerToInject\n    } = slice;\n    const currentReducer = reducerMap[reducerPath];\n    if (!config.overrideExisting && currentReducer && currentReducer !== reducerToInject) {\n      if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n        console.error(`called \\`inject\\` to override already-existing reducer ${reducerPath} without specifying \\`overrideExisting: true\\``);\n      }\n      return combinedReducer;\n    }\n    reducerMap[reducerPath] = reducerToInject;\n    reducer = getReducer();\n    return combinedReducer;\n  };\n  const selector = Object.assign(function makeSelector(selectorFn, selectState) {\n    return function selector2(state, ...args) {\n      return selectorFn(createStateProxy(selectState ? selectState(state, ...args) : state, reducerMap), ...args);\n    };\n  }, {\n    original\n  });\n  return Object.assign(combinedReducer, {\n    inject,\n    selector\n  });\n}\n\n// src/formatProdErrorMessage.ts\nfunction formatProdErrorMessage(code) {\n  return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;\n}\n\n//# sourceMappingURL=redux-toolkit.modern.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3JlZHV4LXRvb2xraXQubW9kZXJuLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNzQjtBQUNtRjtBQUNpQzs7QUFFMUk7QUFDeUM7QUFDd0I7QUFDakU7QUFDQSwwQkFBMEIsK0RBQXFCO0FBQy9DO0FBQ0E7QUFDQSx5REFBeUQsOENBQU8sVUFBVSw4Q0FBTztBQUNqRjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw2RUFBNkUsb0RBQWM7O0FBRTNGO0FBQzRIOztBQUU1SDtBQUNnQztBQUNoQztBQUNBO0FBQ0EsK0NBQStDLDBDQUFPO0FBQ3RELFNBQVMsMENBQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzBFOztBQUUxRTtBQUNpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQXFDLEdBQUcsQ0FBeUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEtBQUs7QUFDekM7QUFDQSxvQ0FBb0MsK0NBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtDQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSztBQUNuQztBQUNBLGtEQUFrRCxrQkFBa0I7QUFDcEUsa0ZBQWtGLFdBQVcsOEJBQThCLFdBQVc7QUFDdEk7QUFDQSw0REFBNEQ7QUFDNUQsTUFBTSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0g7QUFDQTtBQUNBLElB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzhDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEMsNEJBQTRCLFVBQVU7QUFDdEMsMkJBQTJCLFNBQVMsR0FBRyxVQUFVO0FBQ2pELDJCQUEyQixTQUFTLEdBQUcsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTSxFQUFFLFdBQVcsV0FBVyxLQUFLO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixNQUFxQyxHQUFHLENBQTBCLE1BQU0sVUFBVTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMEJBQTBCLE1BQXFDLEdBQUcsQ0FBMEIsaUNBQWlDLGdCQUFnQjtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG9CQUFvQixNQUFxQyxHQUFHLENBQTBCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNERBQTRELHNEQUFnQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsNENBQTRDLGFBQW9CO0FBQ2hFLGdGQUFnRixhQUFhO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTyxpREFBaUQsTUFBTTtBQUN4RztBQW9ERTtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFRMZXZlbCAtIE9yZVxcZmxvd2Rlc2tcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAcmVkdXhqc1xcdG9vbGtpdFxcZGlzdFxccmVkdXgtdG9vbGtpdC5tb2Rlcm4ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInJlZHV4XCI7XG5pbXBvcnQgeyBwcm9kdWNlLCBjdXJyZW50IGFzIGN1cnJlbnQzLCBmcmVlemUsIG9yaWdpbmFsIGFzIG9yaWdpbmFsMiwgaXNEcmFmdCBhcyBpc0RyYWZ0NSB9IGZyb20gXCJpbW1lclwiO1xuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IsIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvciBhcyBjcmVhdGVTZWxlY3RvckNyZWF0b3IyLCBscnVNZW1vaXplLCB3ZWFrTWFwTWVtb2l6ZSBhcyB3ZWFrTWFwTWVtb2l6ZTIgfSBmcm9tIFwicmVzZWxlY3RcIjtcblxuLy8gc3JjL2NyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yLnRzXG5pbXBvcnQgeyBjdXJyZW50LCBpc0RyYWZ0IH0gZnJvbSBcImltbWVyXCI7XG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvckNyZWF0b3IsIHdlYWtNYXBNZW1vaXplIH0gZnJvbSBcInJlc2VsZWN0XCI7XG52YXIgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JDcmVhdG9yID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3QgY3JlYXRlU2VsZWN0b3IyID0gY3JlYXRlU2VsZWN0b3JDcmVhdG9yKC4uLmFyZ3MpO1xuICBjb25zdCBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcjIgPSBPYmplY3QuYXNzaWduKCguLi5hcmdzMikgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gY3JlYXRlU2VsZWN0b3IyKC4uLmFyZ3MyKTtcbiAgICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSAodmFsdWUsIC4uLnJlc3QpID0+IHNlbGVjdG9yKGlzRHJhZnQodmFsdWUpID8gY3VycmVudCh2YWx1ZSkgOiB2YWx1ZSwgLi4ucmVzdCk7XG4gICAgT2JqZWN0LmFzc2lnbih3cmFwcGVkU2VsZWN0b3IsIHNlbGVjdG9yKTtcbiAgICByZXR1cm4gd3JhcHBlZFNlbGVjdG9yO1xuICB9LCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcjJcbiAgfSk7XG4gIHJldHVybiBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcjI7XG59O1xudmFyIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvcih3ZWFrTWFwTWVtb2l6ZSk7XG5cbi8vIHNyYy9jb25maWd1cmVTdG9yZS50c1xuaW1wb3J0IHsgYXBwbHlNaWRkbGV3YXJlLCBjcmVhdGVTdG9yZSwgY29tcG9zZSBhcyBjb21wb3NlMiwgY29tYmluZVJlZHVjZXJzLCBpc1BsYWluT2JqZWN0IGFzIGlzUGxhaW5PYmplY3QyIH0gZnJvbSBcInJlZHV4XCI7XG5cbi8vIHNyYy9kZXZ0b29sc0V4dGVuc2lvbi50c1xuaW1wb3J0IHsgY29tcG9zZSB9IGZyb20gXCJyZWR1eFwiO1xudmFyIGNvbXBvc2VXaXRoRGV2VG9vbHMgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIDogZnVuY3Rpb24oKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdm9pZCAwO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIGNvbXBvc2U7XG4gIHJldHVybiBjb21wb3NlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xudmFyIGRldlRvb2xzRW5oYW5jZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fID8gd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18gOiBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG5vb3AzKSB7XG4gICAgcmV0dXJuIG5vb3AzO1xuICB9O1xufTtcblxuLy8gc3JjL2dldERlZmF1bHRNaWRkbGV3YXJlLnRzXG5pbXBvcnQgeyB0aHVuayBhcyB0aHVua01pZGRsZXdhcmUsIHdpdGhFeHRyYUFyZ3VtZW50IH0gZnJvbSBcInJlZHV4LXRodW5rXCI7XG5cbi8vIHNyYy9jcmVhdGVBY3Rpb24udHNcbmltcG9ydCB7IGlzQWN0aW9uIH0gZnJvbSBcInJlZHV4XCI7XG5cbi8vIHNyYy90c0hlbHBlcnMudHNcbnZhciBoYXNNYXRjaEZ1bmN0aW9uID0gKHYpID0+IHtcbiAgcmV0dXJuIHYgJiYgdHlwZW9mIHYubWF0Y2ggPT09IFwiZnVuY3Rpb25cIjtcbn07XG5cbi8vIHNyYy9jcmVhdGVBY3Rpb24udHNcbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbih0eXBlLCBwcmVwYXJlQWN0aW9uKSB7XG4gIGZ1bmN0aW9uIGFjdGlvbkNyZWF0b3IoLi4uYXJncykge1xuICAgIGlmIChwcmVwYXJlQWN0aW9uKSB7XG4gICAgICBsZXQgcHJlcGFyZWQgPSBwcmVwYXJlQWN0aW9uKC4uLmFyZ3MpO1xuICAgICAgaWYgKCFwcmVwYXJlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgwKSA6IFwicHJlcGFyZUFjdGlvbiBkaWQgbm90IHJldHVybiBhbiBvYmplY3RcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlLFxuICAgICAgICBwYXlsb2FkOiBwcmVwYXJlZC5wYXlsb2FkLFxuICAgICAgICAuLi5cIm1ldGFcIiBpbiBwcmVwYXJlZCAmJiB7XG4gICAgICAgICAgbWV0YTogcHJlcGFyZWQubWV0YVxuICAgICAgICB9LFxuICAgICAgICAuLi5cImVycm9yXCIgaW4gcHJlcGFyZWQgJiYge1xuICAgICAgICAgIGVycm9yOiBwcmVwYXJlZC5lcnJvclxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZSxcbiAgICAgIHBheWxvYWQ6IGFyZ3NbMF1cbiAgICB9O1xuICB9XG4gIGFjdGlvbkNyZWF0b3IudG9TdHJpbmcgPSAoKSA9PiBgJHt0eXBlfWA7XG4gIGFjdGlvbkNyZWF0b3IudHlwZSA9IHR5cGU7XG4gIGFjdGlvbkNyZWF0b3IubWF0Y2ggPSAoYWN0aW9uKSA9PiBpc0FjdGlvbihhY3Rpb24pICYmIGFjdGlvbi50eXBlID09PSB0eXBlO1xuICByZXR1cm4gYWN0aW9uQ3JlYXRvcjtcbn1cbmZ1bmN0aW9uIGlzQWN0aW9uQ3JlYXRvcihhY3Rpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiBhY3Rpb24gPT09IFwiZnVuY3Rpb25cIiAmJiBcInR5cGVcIiBpbiBhY3Rpb24gJiYgLy8gaGFzTWF0Y2hGdW5jdGlvbiBvbmx5IHdhbnRzIE1hdGNoZXJzIGJ1dCBJIGRvbid0IHNlZSB0aGUgcG9pbnQgaW4gcmV3cml0aW5nIGl0XG4gIGhhc01hdGNoRnVuY3Rpb24oYWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGlzRlNBKGFjdGlvbikge1xuICByZXR1cm4gaXNBY3Rpb24oYWN0aW9uKSAmJiBPYmplY3Qua2V5cyhhY3Rpb24pLmV2ZXJ5KGlzVmFsaWRLZXkpO1xufVxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXkpIHtcbiAgcmV0dXJuIFtcInR5cGVcIiwgXCJwYXlsb2FkXCIsIFwiZXJyb3JcIiwgXCJtZXRhXCJdLmluZGV4T2Yoa2V5KSA+IC0xO1xufVxuXG4vLyBzcmMvYWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGdldE1lc3NhZ2UodHlwZSkge1xuICBjb25zdCBzcGxpdFR5cGUgPSB0eXBlID8gYCR7dHlwZX1gLnNwbGl0KFwiL1wiKSA6IFtdO1xuICBjb25zdCBhY3Rpb25OYW1lID0gc3BsaXRUeXBlW3NwbGl0VHlwZS5sZW5ndGggLSAxXSB8fCBcImFjdGlvbkNyZWF0b3JcIjtcbiAgcmV0dXJuIGBEZXRlY3RlZCBhbiBhY3Rpb24gY3JlYXRvciB3aXRoIHR5cGUgXCIke3R5cGUgfHwgXCJ1bmtub3duXCJ9XCIgYmVpbmcgZGlzcGF0Y2hlZC4gXG5NYWtlIHN1cmUgeW91J3JlIGNhbGxpbmcgdGhlIGFjdGlvbiBjcmVhdG9yIGJlZm9yZSBkaXNwYXRjaGluZywgaS5lLiBcXGBkaXNwYXRjaCgke2FjdGlvbk5hbWV9KCkpXFxgIGluc3RlYWQgb2YgXFxgZGlzcGF0Y2goJHthY3Rpb25OYW1lfSlcXGAuIFRoaXMgaXMgbmVjZXNzYXJ5IGV2ZW4gaWYgdGhlIGFjdGlvbiBoYXMgbm8gcGF5bG9hZC5gO1xufVxuZnVuY3Rpb24gY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUob3B0aW9ucyA9IHt9KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICByZXR1cm4gKCkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IG5leHQoYWN0aW9uKTtcbiAgfVxuICBjb25zdCB7XG4gICAgaXNBY3Rpb25DcmVhdG9yOiBpc0FjdGlvbkNyZWF0b3IyID0gaXNBY3Rpb25DcmVhdG9yXG4gIH0gPSBvcHRpb25zO1xuICByZXR1cm4gKCkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICBpZiAoaXNBY3Rpb25DcmVhdG9yMihhY3Rpb24pKSB7XG4gICAgICBjb25zb2xlLndhcm4oZ2V0TWVzc2FnZShhY3Rpb24udHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICB9O1xufVxuXG4vLyBzcmMvdXRpbHMudHNcbmltcG9ydCB7IHByb2R1Y2UgYXMgY3JlYXRlTmV4dFN0YXRlLCBpc0RyYWZ0YWJsZSB9IGZyb20gXCJpbW1lclwiO1xuZnVuY3Rpb24gZ2V0VGltZU1lYXN1cmVVdGlscyhtYXhEZWxheSwgZm5OYW1lKSB7XG4gIGxldCBlbGFwc2VkID0gMDtcbiAgcmV0dXJuIHtcbiAgICBtZWFzdXJlVGltZShmbikge1xuICAgICAgY29uc3Qgc3RhcnRlZCA9IERhdGUubm93KCk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbnN0IGZpbmlzaGVkID0gRGF0ZS5ub3coKTtcbiAgICAgICAgZWxhcHNlZCArPSBmaW5pc2hlZCAtIHN0YXJ0ZWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXJuSWZFeGNlZWRlZCgpIHtcbiAgICAgIGlmIChlbGFwc2VkID4gbWF4RGVsYXkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGAke2ZuTmFtZX0gdG9vayAke2VsYXBzZWR9bXMsIHdoaWNoIGlzIG1vcmUgdGhhbiB0aGUgd2FybmluZyB0aHJlc2hvbGQgb2YgJHttYXhEZWxheX1tcy4gXG5JZiB5b3VyIHN0YXRlIG9yIGFjdGlvbnMgYXJlIHZlcnkgbGFyZ2UsIHlvdSBtYXkgd2FudCB0byBkaXNhYmxlIHRoZSBtaWRkbGV3YXJlIGFzIGl0IG1pZ2h0IGNhdXNlIHRvbyBtdWNoIG9mIGEgc2xvd2Rvd24gaW4gZGV2ZWxvcG1lbnQgbW9kZS4gU2VlIGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2dldERlZmF1bHRNaWRkbGV3YXJlIGZvciBpbnN0cnVjdGlvbnMuXG5JdCBpcyBkaXNhYmxlZCBpbiBwcm9kdWN0aW9uIGJ1aWxkcywgc28geW91IGRvbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgdGhhdC5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG52YXIgVHVwbGUgPSBjbGFzcyBfVHVwbGUgZXh0ZW5kcyBBcnJheSB7XG4gIGNvbnN0cnVjdG9yKC4uLml0ZW1zKSB7XG4gICAgc3VwZXIoLi4uaXRlbXMpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBfVHVwbGUucHJvdG90eXBlKTtcbiAgfVxuICBzdGF0aWMgZ2V0IFtTeW1ib2wuc3BlY2llc10oKSB7XG4gICAgcmV0dXJuIF9UdXBsZTtcbiAgfVxuICBjb25jYXQoLi4uYXJyKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvbmNhdC5hcHBseSh0aGlzLCBhcnIpO1xuICB9XG4gIHByZXBlbmQoLi4uYXJyKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcnJbMF0pKSB7XG4gICAgICByZXR1cm4gbmV3IF9UdXBsZSguLi5hcnJbMF0uY29uY2F0KHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfVHVwbGUoLi4uYXJyLmNvbmNhdCh0aGlzKSk7XG4gIH1cbn07XG5mdW5jdGlvbiBmcmVlemVEcmFmdGFibGUodmFsKSB7XG4gIHJldHVybiBpc0RyYWZ0YWJsZSh2YWwpID8gY3JlYXRlTmV4dFN0YXRlKHZhbCwgKCkgPT4ge1xuICB9KSA6IHZhbDtcbn1cbmZ1bmN0aW9uIGdldE9ySW5zZXJ0Q29tcHV0ZWQobWFwLCBrZXksIGNvbXB1dGUpIHtcbiAgaWYgKG1hcC5oYXMoa2V5KSkgcmV0dXJuIG1hcC5nZXQoa2V5KTtcbiAgcmV0dXJuIG1hcC5zZXQoa2V5LCBjb21wdXRlKGtleSkpLmdldChrZXkpO1xufVxuXG4vLyBzcmMvaW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBpc0ltbXV0YWJsZURlZmF1bHQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PSBudWxsIHx8IE9iamVjdC5pc0Zyb3plbih2YWx1ZSk7XG59XG5mdW5jdGlvbiB0cmFja0Zvck11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9iaikge1xuICBjb25zdCB0cmFja2VkUHJvcGVydGllcyA9IHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9iaik7XG4gIHJldHVybiB7XG4gICAgZGV0ZWN0TXV0YXRpb25zKCkge1xuICAgICAgcmV0dXJuIGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIHRyYWNrZWRQcm9wZXJ0aWVzLCBvYmopO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMgPSBbXSwgb2JqLCBwYXRoID0gXCJcIiwgY2hlY2tlZE9iamVjdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSB7XG4gIGNvbnN0IHRyYWNrZWQgPSB7XG4gICAgdmFsdWU6IG9ialxuICB9O1xuICBpZiAoIWlzSW1tdXRhYmxlKG9iaikgJiYgIWNoZWNrZWRPYmplY3RzLmhhcyhvYmopKSB7XG4gICAgY2hlY2tlZE9iamVjdHMuYWRkKG9iaik7XG4gICAgdHJhY2tlZC5jaGlsZHJlbiA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcbiAgICAgIGlmIChpZ25vcmVQYXRocy5sZW5ndGggJiYgaWdub3JlUGF0aHMuaW5kZXhPZihjaGlsZFBhdGgpICE9PSAtMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRyYWNrZWQuY2hpbGRyZW5ba2V5XSA9IHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9ialtrZXldLCBjaGlsZFBhdGgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJhY2tlZDtcbn1cbmZ1bmN0aW9uIGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzID0gW10sIHRyYWNrZWRQcm9wZXJ0eSwgb2JqLCBzYW1lUGFyZW50UmVmID0gZmFsc2UsIHBhdGggPSBcIlwiKSB7XG4gIGNvbnN0IHByZXZPYmogPSB0cmFja2VkUHJvcGVydHkgPyB0cmFja2VkUHJvcGVydHkudmFsdWUgOiB2b2lkIDA7XG4gIGNvbnN0IHNhbWVSZWYgPSBwcmV2T2JqID09PSBvYmo7XG4gIGlmIChzYW1lUGFyZW50UmVmICYmICFzYW1lUmVmICYmICFOdW1iZXIuaXNOYU4ob2JqKSkge1xuICAgIHJldHVybiB7XG4gICAgICB3YXNNdXRhdGVkOiB0cnVlLFxuICAgICAgcGF0aFxuICAgIH07XG4gIH1cbiAgaWYgKGlzSW1tdXRhYmxlKHByZXZPYmopIHx8IGlzSW1tdXRhYmxlKG9iaikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2FzTXV0YXRlZDogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNvbnN0IGtleXNUb0RldGVjdCA9IHt9O1xuICBmb3IgKGxldCBrZXkgaW4gdHJhY2tlZFByb3BlcnR5LmNoaWxkcmVuKSB7XG4gICAga2V5c1RvRGV0ZWN0W2tleV0gPSB0cnVlO1xuICB9XG4gIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICBrZXlzVG9EZXRlY3Rba2V5XSA9IHRydWU7XG4gIH1cbiAgY29uc3QgaGFzSWdub3JlZFBhdGhzID0gaWdub3JlZFBhdGhzLmxlbmd0aCA+IDA7XG4gIGZvciAobGV0IGtleSBpbiBrZXlzVG9EZXRlY3QpIHtcbiAgICBjb25zdCBuZXN0ZWRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcbiAgICBpZiAoaGFzSWdub3JlZFBhdGhzKSB7XG4gICAgICBjb25zdCBoYXNNYXRjaGVzID0gaWdub3JlZFBhdGhzLnNvbWUoKGlnbm9yZWQpID0+IHtcbiAgICAgICAgaWYgKGlnbm9yZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICByZXR1cm4gaWdub3JlZC50ZXN0KG5lc3RlZFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXN0ZWRQYXRoID09PSBpZ25vcmVkO1xuICAgICAgfSk7XG4gICAgICBpZiAoaGFzTWF0Y2hlcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMsIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbltrZXldLCBvYmpba2V5XSwgc2FtZVJlZiwgbmVzdGVkUGF0aCk7XG4gICAgaWYgKHJlc3VsdC53YXNNdXRhdGVkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdhc011dGF0ZWQ6IGZhbHNlXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUob3B0aW9ucyA9IHt9KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICByZXR1cm4gKCkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IG5leHQoYWN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgc3RyaW5naWZ5MiA9IGZ1bmN0aW9uKG9iaiwgc2VyaWFsaXplciwgaW5kZW50LCBkZWN5Y2xlcikge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgZ2V0U2VyaWFsaXplMihzZXJpYWxpemVyLCBkZWN5Y2xlciksIGluZGVudCk7XG4gICAgfSwgZ2V0U2VyaWFsaXplMiA9IGZ1bmN0aW9uKHNlcmlhbGl6ZXIsIGRlY3ljbGVyKSB7XG4gICAgICBsZXQgc3RhY2sgPSBbXSwga2V5cyA9IFtdO1xuICAgICAgaWYgKCFkZWN5Y2xlcikgZGVjeWNsZXIgPSBmdW5jdGlvbihfLCB2YWx1ZSkge1xuICAgICAgICBpZiAoc3RhY2tbMF0gPT09IHZhbHVlKSByZXR1cm4gXCJbQ2lyY3VsYXIgfl1cIjtcbiAgICAgICAgcmV0dXJuIFwiW0NpcmN1bGFyIH4uXCIgKyBrZXlzLnNsaWNlKDAsIHN0YWNrLmluZGV4T2YodmFsdWUpKS5qb2luKFwiLlwiKSArIFwiXVwiO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHRoaXNQb3MgPSBzdGFjay5pbmRleE9mKHRoaXMpO1xuICAgICAgICAgIH50aGlzUG9zID8gc3RhY2suc3BsaWNlKHRoaXNQb3MgKyAxKSA6IHN0YWNrLnB1c2godGhpcyk7XG4gICAgICAgICAgfnRoaXNQb3MgPyBrZXlzLnNwbGljZSh0aGlzUG9zLCBJbmZpbml0eSwga2V5KSA6IGtleXMucHVzaChrZXkpO1xuICAgICAgICAgIGlmICh+c3RhY2suaW5kZXhPZih2YWx1ZSkpIHZhbHVlID0gZGVjeWNsZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplciA9PSBudWxsID8gdmFsdWUgOiBzZXJpYWxpemVyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH07XG4gICAgdmFyIHN0cmluZ2lmeSA9IHN0cmluZ2lmeTIsIGdldFNlcmlhbGl6ZSA9IGdldFNlcmlhbGl6ZTI7XG4gICAgbGV0IHtcbiAgICAgIGlzSW1tdXRhYmxlID0gaXNJbW11dGFibGVEZWZhdWx0LFxuICAgICAgaWdub3JlZFBhdGhzLFxuICAgICAgd2FybkFmdGVyID0gMzJcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB0cmFjayA9IHRyYWNrRm9yTXV0YXRpb25zLmJpbmQobnVsbCwgaXNJbW11dGFibGUsIGlnbm9yZWRQYXRocyk7XG4gICAgcmV0dXJuICh7XG4gICAgICBnZXRTdGF0ZVxuICAgIH0pID0+IHtcbiAgICAgIGxldCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICBsZXQgdHJhY2tlciA9IHRyYWNrKHN0YXRlKTtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICByZXR1cm4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICAgICAgY29uc3QgbWVhc3VyZVV0aWxzID0gZ2V0VGltZU1lYXN1cmVVdGlscyh3YXJuQWZ0ZXIsIFwiSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlXCIpO1xuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xuICAgICAgICAgIHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgICAgICByZXN1bHQgPSB0cmFja2VyLmRldGVjdE11dGF0aW9ucygpO1xuICAgICAgICAgIHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC53YXNNdXRhdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxOSkgOiBgQSBzdGF0ZSBtdXRhdGlvbiB3YXMgZGV0ZWN0ZWQgYmV0d2VlbiBkaXNwYXRjaGVzLCBpbiB0aGUgcGF0aCAnJHtyZXN1bHQucGF0aCB8fCBcIlwifScuICBUaGlzIG1heSBjYXVzZSBpbmNvcnJlY3QgYmVoYXZpb3IuIChodHRwczovL3JlZHV4LmpzLm9yZy9zdHlsZS1ndWlkZS9zdHlsZS1ndWlkZSNkby1ub3QtbXV0YXRlLXN0YXRlKWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGRpc3BhdGNoZWRBY3Rpb24gPSBuZXh0KGFjdGlvbik7XG4gICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZSgoKSA9PiB7XG4gICAgICAgICAgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgICAgIHJlc3VsdCA9IHRyYWNrZXIuZGV0ZWN0TXV0YXRpb25zKCk7XG4gICAgICAgICAgdHJhY2tlciA9IHRyYWNrKHN0YXRlKTtcbiAgICAgICAgICBpZiAocmVzdWx0Lndhc011dGF0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIwKSA6IGBBIHN0YXRlIG11dGF0aW9uIHdhcyBkZXRlY3RlZCBpbnNpZGUgYSBkaXNwYXRjaCwgaW4gdGhlIHBhdGg6ICR7cmVzdWx0LnBhdGggfHwgXCJcIn0uIFRha2UgYSBsb29rIGF0IHRoZSByZWR1Y2VyKHMpIGhhbmRsaW5nIHRoZSBhY3Rpb24gJHtzdHJpbmdpZnkyKGFjdGlvbil9LiAoaHR0cHM6Ly9yZWR1eC5qcy5vcmcvc3R5bGUtZ3VpZGUvc3R5bGUtZ3VpZGUjZG8tbm90LW11dGF0ZS1zdGF0ZSlgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZWFzdXJlVXRpbHMud2FybklmRXhjZWVkZWQoKTtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoZWRBY3Rpb247XG4gICAgICB9O1xuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL3NlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZS50c1xuaW1wb3J0IHsgaXNBY3Rpb24gYXMgaXNBY3Rpb24yLCBpc1BsYWluT2JqZWN0IH0gZnJvbSBcInJlZHV4XCI7XG5mdW5jdGlvbiBpc1BsYWluKHZhbCkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbDtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgfHwgdHlwZSA9PT0gXCJudW1iZXJcIiB8fCBBcnJheS5pc0FycmF5KHZhbCkgfHwgaXNQbGFpbk9iamVjdCh2YWwpO1xufVxuZnVuY3Rpb24gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHZhbHVlLCBwYXRoID0gXCJcIiwgaXNTZXJpYWxpemFibGUgPSBpc1BsYWluLCBnZXRFbnRyaWVzLCBpZ25vcmVkUGF0aHMgPSBbXSwgY2FjaGUpIHtcbiAgbGV0IGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlO1xuICBpZiAoIWlzU2VyaWFsaXphYmxlKHZhbHVlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXlQYXRoOiBwYXRoIHx8IFwiPHJvb3Q+XCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoY2FjaGU/Lmhhcyh2YWx1ZSkpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgZW50cmllcyA9IGdldEVudHJpZXMgIT0gbnVsbCA/IGdldEVudHJpZXModmFsdWUpIDogT2JqZWN0LmVudHJpZXModmFsdWUpO1xuICBjb25zdCBoYXNJZ25vcmVkUGF0aHMgPSBpZ25vcmVkUGF0aHMubGVuZ3RoID4gMDtcbiAgZm9yIChjb25zdCBba2V5LCBuZXN0ZWRWYWx1ZV0gb2YgZW50cmllcykge1xuICAgIGNvbnN0IG5lc3RlZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xuICAgIGlmIChoYXNJZ25vcmVkUGF0aHMpIHtcbiAgICAgIGNvbnN0IGhhc01hdGNoZXMgPSBpZ25vcmVkUGF0aHMuc29tZSgoaWdub3JlZCkgPT4ge1xuICAgICAgICBpZiAoaWdub3JlZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgIHJldHVybiBpZ25vcmVkLnRlc3QobmVzdGVkUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5lc3RlZFBhdGggPT09IGlnbm9yZWQ7XG4gICAgICB9KTtcbiAgICAgIGlmIChoYXNNYXRjaGVzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzU2VyaWFsaXphYmxlKG5lc3RlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5UGF0aDogbmVzdGVkUGF0aCxcbiAgICAgICAgdmFsdWU6IG5lc3RlZFZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShuZXN0ZWRWYWx1ZSwgbmVzdGVkUGF0aCwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRQYXRocywgY2FjaGUpO1xuICAgICAgaWYgKGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlKSB7XG4gICAgICAgIHJldHVybiBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGNhY2hlICYmIGlzTmVzdGVkRnJvemVuKHZhbHVlKSkgY2FjaGUuYWRkKHZhbHVlKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNOZXN0ZWRGcm96ZW4odmFsdWUpIHtcbiAgaWYgKCFPYmplY3QuaXNGcm96ZW4odmFsdWUpKSByZXR1cm4gZmFsc2U7XG4gIGZvciAoY29uc3QgbmVzdGVkVmFsdWUgb2YgT2JqZWN0LnZhbHVlcyh2YWx1ZSkpIHtcbiAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlICE9PSBcIm9iamVjdFwiIHx8IG5lc3RlZFZhbHVlID09PSBudWxsKSBjb250aW51ZTtcbiAgICBpZiAoIWlzTmVzdGVkRnJvemVuKG5lc3RlZFZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiBuZXh0KGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNTZXJpYWxpemFibGUgPSBpc1BsYWluLFxuICAgICAgZ2V0RW50cmllcyxcbiAgICAgIGlnbm9yZWRBY3Rpb25zID0gW10sXG4gICAgICBpZ25vcmVkQWN0aW9uUGF0aHMgPSBbXCJtZXRhLmFyZ1wiLCBcIm1ldGEuYmFzZVF1ZXJ5TWV0YVwiXSxcbiAgICAgIGlnbm9yZWRQYXRocyA9IFtdLFxuICAgICAgd2FybkFmdGVyID0gMzIsXG4gICAgICBpZ25vcmVTdGF0ZSA9IGZhbHNlLFxuICAgICAgaWdub3JlQWN0aW9ucyA9IGZhbHNlLFxuICAgICAgZGlzYWJsZUNhY2hlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBjYWNoZSA9ICFkaXNhYmxlQ2FjaGUgJiYgV2Vha1NldCA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpIDogdm9pZCAwO1xuICAgIHJldHVybiAoc3RvcmVBUEkpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoIWlzQWN0aW9uMihhY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBuZXh0KGFjdGlvbik7XG4gICAgICBjb25zdCBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XG4gICAgICBpZiAoIWlnbm9yZUFjdGlvbnMgJiYgIShpZ25vcmVkQWN0aW9ucy5sZW5ndGggJiYgaWdub3JlZEFjdGlvbnMuaW5kZXhPZihhY3Rpb24udHlwZSkgIT09IC0xKSkge1xuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoYWN0aW9uLCBcIlwiLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZEFjdGlvblBhdGhzLCBjYWNoZSk7XG4gICAgICAgICAgaWYgKGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0gPSBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQSBub24tc2VyaWFsaXphYmxlIHZhbHVlIHdhcyBkZXRlY3RlZCBpbiBhbiBhY3Rpb24sIGluIHRoZSBwYXRoOiBcXGAke2tleVBhdGh9XFxgLiBWYWx1ZTpgLCB2YWx1ZSwgXCJcXG5UYWtlIGEgbG9vayBhdCB0aGUgbG9naWMgdGhhdCBkaXNwYXRjaGVkIHRoaXMgYWN0aW9uOiBcIiwgYWN0aW9uLCBcIlxcbihTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvZmFxL2FjdGlvbnMjd2h5LXNob3VsZC10eXBlLWJlLWEtc3RyaW5nLW9yLWF0LWxlYXN0LXNlcmlhbGl6YWJsZS13aHktc2hvdWxkLW15LWFjdGlvbi10eXBlcy1iZS1jb25zdGFudHMpXCIsIFwiXFxuKFRvIGFsbG93IG5vbi1zZXJpYWxpemFibGUgdmFsdWVzIHNlZTogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy91c2FnZS91c2FnZS1ndWlkZSN3b3JraW5nLXdpdGgtbm9uLXNlcmlhbGl6YWJsZS1kYXRhKVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFpZ25vcmVTdGF0ZSkge1xuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RvcmVBUEkuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBjb25zdCBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoc3RhdGUsIFwiXCIsIGlzU2VyaWFsaXphYmxlLCBnZXRFbnRyaWVzLCBpZ25vcmVkUGF0aHMsIGNhY2hlKTtcbiAgICAgICAgICBpZiAoZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9ID0gZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQSBub24tc2VyaWFsaXphYmxlIHZhbHVlIHdhcyBkZXRlY3RlZCBpbiB0aGUgc3RhdGUsIGluIHRoZSBwYXRoOiBcXGAke2tleVBhdGh9XFxgLiBWYWx1ZTpgLCB2YWx1ZSwgYFxuVGFrZSBhIGxvb2sgYXQgdGhlIHJlZHVjZXIocykgaGFuZGxpbmcgdGhpcyBhY3Rpb24gdHlwZTogJHthY3Rpb24udHlwZX0uXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9vcmdhbml6aW5nLXN0YXRlI2Nhbi1pLXB1dC1mdW5jdGlvbnMtcHJvbWlzZXMtb3Itb3RoZXItbm9uLXNlcmlhbGl6YWJsZS1pdGVtcy1pbi1teS1zdG9yZS1zdGF0ZSlgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZWFzdXJlVXRpbHMud2FybklmRXhjZWVkZWQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvZ2V0RGVmYXVsdE1pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGlzQm9vbGVhbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJib29sZWFuXCI7XG59XG52YXIgYnVpbGRHZXREZWZhdWx0TWlkZGxld2FyZSA9ICgpID0+IGZ1bmN0aW9uIGdldERlZmF1bHRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHRodW5rID0gdHJ1ZSxcbiAgICBpbW11dGFibGVDaGVjayA9IHRydWUsXG4gICAgc2VyaWFsaXphYmxlQ2hlY2sgPSB0cnVlLFxuICAgIGFjdGlvbkNyZWF0b3JDaGVjayA9IHRydWVcbiAgfSA9IG9wdGlvbnMgPz8ge307XG4gIGxldCBtaWRkbGV3YXJlQXJyYXkgPSBuZXcgVHVwbGUoKTtcbiAgaWYgKHRodW5rKSB7XG4gICAgaWYgKGlzQm9vbGVhbih0aHVuaykpIHtcbiAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKHRodW5rTWlkZGxld2FyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKHdpdGhFeHRyYUFyZ3VtZW50KHRodW5rLmV4dHJhQXJndW1lbnQpKTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChpbW11dGFibGVDaGVjaykge1xuICAgICAgbGV0IGltbXV0YWJsZU9wdGlvbnMgPSB7fTtcbiAgICAgIGlmICghaXNCb29sZWFuKGltbXV0YWJsZUNoZWNrKSkge1xuICAgICAgICBpbW11dGFibGVPcHRpb25zID0gaW1tdXRhYmxlQ2hlY2s7XG4gICAgICB9XG4gICAgICBtaWRkbGV3YXJlQXJyYXkudW5zaGlmdChjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUoaW1tdXRhYmxlT3B0aW9ucykpO1xuICAgIH1cbiAgICBpZiAoc2VyaWFsaXphYmxlQ2hlY2spIHtcbiAgICAgIGxldCBzZXJpYWxpemFibGVPcHRpb25zID0ge307XG4gICAgICBpZiAoIWlzQm9vbGVhbihzZXJpYWxpemFibGVDaGVjaykpIHtcbiAgICAgICAgc2VyaWFsaXphYmxlT3B0aW9ucyA9IHNlcmlhbGl6YWJsZUNoZWNrO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2goY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKHNlcmlhbGl6YWJsZU9wdGlvbnMpKTtcbiAgICB9XG4gICAgaWYgKGFjdGlvbkNyZWF0b3JDaGVjaykge1xuICAgICAgbGV0IGFjdGlvbkNyZWF0b3JPcHRpb25zID0ge307XG4gICAgICBpZiAoIWlzQm9vbGVhbihhY3Rpb25DcmVhdG9yQ2hlY2spKSB7XG4gICAgICAgIGFjdGlvbkNyZWF0b3JPcHRpb25zID0gYWN0aW9uQ3JlYXRvckNoZWNrO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZUFycmF5LnVuc2hpZnQoY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUoYWN0aW9uQ3JlYXRvck9wdGlvbnMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pZGRsZXdhcmVBcnJheTtcbn07XG5cbi8vIHNyYy9hdXRvQmF0Y2hFbmhhbmNlci50c1xudmFyIFNIT1VMRF9BVVRPQkFUQ0ggPSBcIlJUS19hdXRvQmF0Y2hcIjtcbnZhciBwcmVwYXJlQXV0b0JhdGNoZWQgPSAoKSA9PiAocGF5bG9hZCkgPT4gKHtcbiAgcGF5bG9hZCxcbiAgbWV0YToge1xuICAgIFtTSE9VTERfQVVUT0JBVENIXTogdHJ1ZVxuICB9XG59KTtcbnZhciBjcmVhdGVRdWV1ZVdpdGhUaW1lciA9ICh0aW1lb3V0KSA9PiB7XG4gIHJldHVybiAobm90aWZ5KSA9PiB7XG4gICAgc2V0VGltZW91dChub3RpZnksIHRpbWVvdXQpO1xuICB9O1xufTtcbnZhciBhdXRvQmF0Y2hFbmhhbmNlciA9IChvcHRpb25zID0ge1xuICB0eXBlOiBcInJhZlwiXG59KSA9PiAobmV4dCkgPT4gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3Qgc3RvcmUgPSBuZXh0KC4uLmFyZ3MpO1xuICBsZXQgbm90aWZ5aW5nID0gdHJ1ZTtcbiAgbGV0IHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gZmFsc2U7XG4gIGxldCBub3RpZmljYXRpb25RdWV1ZWQgPSBmYWxzZTtcbiAgY29uc3QgbGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgcXVldWVDYWxsYmFjayA9IG9wdGlvbnMudHlwZSA9PT0gXCJ0aWNrXCIgPyBxdWV1ZU1pY3JvdGFzayA6IG9wdGlvbnMudHlwZSA9PT0gXCJyYWZcIiA/IChcbiAgICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgd29uJ3QgZXhpc3QgaW4gU1NSIGVudmlyb25tZW50cy4gRmFsbCBiYWNrIHRvIGEgdmFndWUgYXBwcm94aW1hdGlvbiBqdXN0IHRvIGtlZXAgZnJvbSBlcnJvcmluZy5cbiAgICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogY3JlYXRlUXVldWVXaXRoVGltZXIoMTApXG4gICkgOiBvcHRpb25zLnR5cGUgPT09IFwiY2FsbGJhY2tcIiA/IG9wdGlvbnMucXVldWVOb3RpZmljYXRpb24gOiBjcmVhdGVRdWV1ZVdpdGhUaW1lcihvcHRpb25zLnRpbWVvdXQpO1xuICBjb25zdCBub3RpZnlMaXN0ZW5lcnMgPSAoKSA9PiB7XG4gICAgbm90aWZpY2F0aW9uUXVldWVkID0gZmFsc2U7XG4gICAgaWYgKHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrKSB7XG4gICAgICBzaG91bGROb3RpZnlBdEVuZE9mVGljayA9IGZhbHNlO1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGwpID0+IGwoKSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RvcmUsIHtcbiAgICAvLyBPdmVycmlkZSB0aGUgYmFzZSBgc3RvcmUuc3Vic2NyaWJlYCBtZXRob2QgdG8ga2VlcCBvcmlnaW5hbCBsaXN0ZW5lcnNcbiAgICAvLyBmcm9tIHJ1bm5pbmcgaWYgd2UncmUgZGVsYXlpbmcgbm90aWZpY2F0aW9uc1xuICAgIHN1YnNjcmliZShsaXN0ZW5lcjIpIHtcbiAgICAgIGNvbnN0IHdyYXBwZWRMaXN0ZW5lciA9ICgpID0+IG5vdGlmeWluZyAmJiBsaXN0ZW5lcjIoKTtcbiAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gc3RvcmUuc3Vic2NyaWJlKHdyYXBwZWRMaXN0ZW5lcik7XG4gICAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyMik7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyMik7XG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gT3ZlcnJpZGUgdGhlIGJhc2UgYHN0b3JlLmRpc3BhdGNoYCBtZXRob2Qgc28gdGhhdCB3ZSBjYW4gY2hlY2sgYWN0aW9uc1xuICAgIC8vIGZvciB0aGUgYHNob3VsZEF1dG9CYXRjaGAgZmxhZyBhbmQgZGV0ZXJtaW5lIGlmIGJhdGNoaW5nIGlzIGFjdGl2ZVxuICAgIGRpc3BhdGNoKGFjdGlvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbm90aWZ5aW5nID0gIWFjdGlvbj8ubWV0YT8uW1NIT1VMRF9BVVRPQkFUQ0hdO1xuICAgICAgICBzaG91bGROb3RpZnlBdEVuZE9mVGljayA9ICFub3RpZnlpbmc7XG4gICAgICAgIGlmIChzaG91bGROb3RpZnlBdEVuZE9mVGljaykge1xuICAgICAgICAgIGlmICghbm90aWZpY2F0aW9uUXVldWVkKSB7XG4gICAgICAgICAgICBub3RpZmljYXRpb25RdWV1ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcXVldWVDYWxsYmFjayhub3RpZnlMaXN0ZW5lcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2goYWN0aW9uKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIG5vdGlmeWluZyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIHNyYy9nZXREZWZhdWx0RW5oYW5jZXJzLnRzXG52YXIgYnVpbGRHZXREZWZhdWx0RW5oYW5jZXJzID0gKG1pZGRsZXdhcmVFbmhhbmNlcikgPT4gZnVuY3Rpb24gZ2V0RGVmYXVsdEVuaGFuY2VycyhvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBhdXRvQmF0Y2ggPSB0cnVlXG4gIH0gPSBvcHRpb25zID8/IHt9O1xuICBsZXQgZW5oYW5jZXJBcnJheSA9IG5ldyBUdXBsZShtaWRkbGV3YXJlRW5oYW5jZXIpO1xuICBpZiAoYXV0b0JhdGNoKSB7XG4gICAgZW5oYW5jZXJBcnJheS5wdXNoKGF1dG9CYXRjaEVuaGFuY2VyKHR5cGVvZiBhdXRvQmF0Y2ggPT09IFwib2JqZWN0XCIgPyBhdXRvQmF0Y2ggOiB2b2lkIDApKTtcbiAgfVxuICByZXR1cm4gZW5oYW5jZXJBcnJheTtcbn07XG5cbi8vIHNyYy9jb25maWd1cmVTdG9yZS50c1xuZnVuY3Rpb24gY29uZmlndXJlU3RvcmUob3B0aW9ucykge1xuICBjb25zdCBnZXREZWZhdWx0TWlkZGxld2FyZSA9IGJ1aWxkR2V0RGVmYXVsdE1pZGRsZXdhcmUoKTtcbiAgY29uc3Qge1xuICAgIHJlZHVjZXIgPSB2b2lkIDAsXG4gICAgbWlkZGxld2FyZSxcbiAgICBkZXZUb29scyA9IHRydWUsXG4gICAgcHJlbG9hZGVkU3RhdGUgPSB2b2lkIDAsXG4gICAgZW5oYW5jZXJzID0gdm9pZCAwXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgcm9vdFJlZHVjZXI7XG4gIGlmICh0eXBlb2YgcmVkdWNlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcm9vdFJlZHVjZXIgPSByZWR1Y2VyO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QyKHJlZHVjZXIpKSB7XG4gICAgcm9vdFJlZHVjZXIgPSBjb21iaW5lUmVkdWNlcnMocmVkdWNlcik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMSkgOiBcImByZWR1Y2VyYCBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LCBhbmQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCBvZiBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGNvbWJpbmVSZWR1Y2Vyc1wiKTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG1pZGRsZXdhcmUgJiYgdHlwZW9mIG1pZGRsZXdhcmUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIpIDogXCJgbWlkZGxld2FyZWAgZmllbGQgbXVzdCBiZSBhIGNhbGxiYWNrXCIpO1xuICB9XG4gIGxldCBmaW5hbE1pZGRsZXdhcmU7XG4gIGlmICh0eXBlb2YgbWlkZGxld2FyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZmluYWxNaWRkbGV3YXJlID0gbWlkZGxld2FyZShnZXREZWZhdWx0TWlkZGxld2FyZSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhQXJyYXkuaXNBcnJheShmaW5hbE1pZGRsZXdhcmUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzKSA6IFwid2hlbiB1c2luZyBhIG1pZGRsZXdhcmUgYnVpbGRlciBmdW5jdGlvbiwgYW4gYXJyYXkgb2YgbWlkZGxld2FyZSBtdXN0IGJlIHJldHVybmVkXCIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmaW5hbE1pZGRsZXdhcmUgPSBnZXREZWZhdWx0TWlkZGxld2FyZSgpO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZmluYWxNaWRkbGV3YXJlLnNvbWUoKGl0ZW0pID0+IHR5cGVvZiBpdGVtICE9PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNCkgOiBcImVhY2ggbWlkZGxld2FyZSBwcm92aWRlZCB0byBjb25maWd1cmVTdG9yZSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgbGV0IGZpbmFsQ29tcG9zZSA9IGNvbXBvc2UyO1xuICBpZiAoZGV2VG9vbHMpIHtcbiAgICBmaW5hbENvbXBvc2UgPSBjb21wb3NlV2l0aERldlRvb2xzKHtcbiAgICAgIC8vIEVuYWJsZSBjYXB0dXJlIG9mIHN0YWNrIHRyYWNlcyBmb3IgZGlzcGF0Y2hlZCBSZWR1eCBhY3Rpb25zXG4gICAgICB0cmFjZTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiLFxuICAgICAgLi4udHlwZW9mIGRldlRvb2xzID09PSBcIm9iamVjdFwiICYmIGRldlRvb2xzXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbWlkZGxld2FyZUVuaGFuY2VyID0gYXBwbHlNaWRkbGV3YXJlKC4uLmZpbmFsTWlkZGxld2FyZSk7XG4gIGNvbnN0IGdldERlZmF1bHRFbmhhbmNlcnMgPSBidWlsZEdldERlZmF1bHRFbmhhbmNlcnMobWlkZGxld2FyZUVuaGFuY2VyKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBlbmhhbmNlcnMgJiYgdHlwZW9mIGVuaGFuY2VycyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNSkgOiBcImBlbmhhbmNlcnNgIGZpZWxkIG11c3QgYmUgYSBjYWxsYmFja1wiKTtcbiAgfVxuICBsZXQgc3RvcmVFbmhhbmNlcnMgPSB0eXBlb2YgZW5oYW5jZXJzID09PSBcImZ1bmN0aW9uXCIgPyBlbmhhbmNlcnMoZ2V0RGVmYXVsdEVuaGFuY2VycykgOiBnZXREZWZhdWx0RW5oYW5jZXJzKCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIUFycmF5LmlzQXJyYXkoc3RvcmVFbmhhbmNlcnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNikgOiBcImBlbmhhbmNlcnNgIGNhbGxiYWNrIG11c3QgcmV0dXJuIGFuIGFycmF5XCIpO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgc3RvcmVFbmhhbmNlcnMuc29tZSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gIT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg3KSA6IFwiZWFjaCBlbmhhbmNlciBwcm92aWRlZCB0byBjb25maWd1cmVTdG9yZSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBmaW5hbE1pZGRsZXdhcmUubGVuZ3RoICYmICFzdG9yZUVuaGFuY2Vycy5pbmNsdWRlcyhtaWRkbGV3YXJlRW5oYW5jZXIpKSB7XG4gICAgY29uc29sZS5lcnJvcihcIm1pZGRsZXdhcmVzIHdlcmUgcHJvdmlkZWQsIGJ1dCBtaWRkbGV3YXJlIGVuaGFuY2VyIHdhcyBub3QgaW5jbHVkZWQgaW4gZmluYWwgZW5oYW5jZXJzIC0gbWFrZSBzdXJlIHRvIGNhbGwgYGdldERlZmF1bHRFbmhhbmNlcnNgXCIpO1xuICB9XG4gIGNvbnN0IGNvbXBvc2VkRW5oYW5jZXIgPSBmaW5hbENvbXBvc2UoLi4uc3RvcmVFbmhhbmNlcnMpO1xuICByZXR1cm4gY3JlYXRlU3RvcmUocm9vdFJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBjb21wb3NlZEVuaGFuY2VyKTtcbn1cblxuLy8gc3JjL2NyZWF0ZVJlZHVjZXIudHNcbmltcG9ydCB7IHByb2R1Y2UgYXMgY3JlYXRlTmV4dFN0YXRlMiwgaXNEcmFmdCBhcyBpc0RyYWZ0MiwgaXNEcmFmdGFibGUgYXMgaXNEcmFmdGFibGUyIH0gZnJvbSBcImltbWVyXCI7XG5cbi8vIHNyYy9tYXBCdWlsZGVycy50c1xuZnVuY3Rpb24gZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2soYnVpbGRlckNhbGxiYWNrKSB7XG4gIGNvbnN0IGFjdGlvbnNNYXAgPSB7fTtcbiAgY29uc3QgYWN0aW9uTWF0Y2hlcnMgPSBbXTtcbiAgbGV0IGRlZmF1bHRDYXNlUmVkdWNlcjtcbiAgY29uc3QgYnVpbGRlciA9IHtcbiAgICBhZGRDYXNlKHR5cGVPckFjdGlvbkNyZWF0b3IsIHJlZHVjZXIpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGFjdGlvbk1hdGNoZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNikgOiBcImBidWlsZGVyLmFkZENhc2VgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGRNYXRjaGVyYFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjcpIDogXCJgYnVpbGRlci5hZGRDYXNlYCBzaG91bGQgb25seSBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHR5cGVPckFjdGlvbkNyZWF0b3IgPT09IFwic3RyaW5nXCIgPyB0eXBlT3JBY3Rpb25DcmVhdG9yIDogdHlwZU9yQWN0aW9uQ3JlYXRvci50eXBlO1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI4KSA6IFwiYGJ1aWxkZXIuYWRkQ2FzZWAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5IGFjdGlvbiB0eXBlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgaW4gYWN0aW9uc01hcCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyOSkgOiBgXFxgYnVpbGRlci5hZGRDYXNlXFxgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCB0d28gcmVkdWNlcnMgZm9yIHRoZSBzYW1lIGFjdGlvbiB0eXBlICcke3R5cGV9J2ApO1xuICAgICAgfVxuICAgICAgYWN0aW9uc01hcFt0eXBlXSA9IHJlZHVjZXI7XG4gICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9LFxuICAgIGFkZE1hdGNoZXIobWF0Y2hlciwgcmVkdWNlcikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzApIDogXCJgYnVpbGRlci5hZGRNYXRjaGVyYCBzaG91bGQgb25seSBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhY3Rpb25NYXRjaGVycy5wdXNoKHtcbiAgICAgICAgbWF0Y2hlcixcbiAgICAgICAgcmVkdWNlclxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9LFxuICAgIGFkZERlZmF1bHRDYXNlKHJlZHVjZXIpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMxKSA6IFwiYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWZhdWx0Q2FzZVJlZHVjZXIgPSByZWR1Y2VyO1xuICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfVxuICB9O1xuICBidWlsZGVyQ2FsbGJhY2soYnVpbGRlcik7XG4gIHJldHVybiBbYWN0aW9uc01hcCwgYWN0aW9uTWF0Y2hlcnMsIGRlZmF1bHRDYXNlUmVkdWNlcl07XG59XG5cbi8vIHNyYy9jcmVhdGVSZWR1Y2VyLnRzXG5mdW5jdGlvbiBpc1N0YXRlRnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlZHVjZXIoaW5pdGlhbFN0YXRlLCBtYXBPckJ1aWxkZXJDYWxsYmFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBtYXBPckJ1aWxkZXJDYWxsYmFjayA9PT0gXCJvYmplY3RcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoOCkgOiBcIlRoZSBvYmplY3Qgbm90YXRpb24gZm9yIGBjcmVhdGVSZWR1Y2VyYCBoYXMgYmVlbiByZW1vdmVkLiBQbGVhc2UgdXNlIHRoZSAnYnVpbGRlciBjYWxsYmFjaycgbm90YXRpb24gaW5zdGVhZDogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9hcGkvY3JlYXRlUmVkdWNlclwiKTtcbiAgICB9XG4gIH1cbiAgbGV0IFthY3Rpb25zTWFwLCBmaW5hbEFjdGlvbk1hdGNoZXJzLCBmaW5hbERlZmF1bHRDYXNlUmVkdWNlcl0gPSBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhtYXBPckJ1aWxkZXJDYWxsYmFjayk7XG4gIGxldCBnZXRJbml0aWFsU3RhdGU7XG4gIGlmIChpc1N0YXRlRnVuY3Rpb24oaW5pdGlhbFN0YXRlKSkge1xuICAgIGdldEluaXRpYWxTdGF0ZSA9ICgpID0+IGZyZWV6ZURyYWZ0YWJsZShpbml0aWFsU3RhdGUoKSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZnJvemVuSW5pdGlhbFN0YXRlID0gZnJlZXplRHJhZnRhYmxlKGluaXRpYWxTdGF0ZSk7XG4gICAgZ2V0SW5pdGlhbFN0YXRlID0gKCkgPT4gZnJvemVuSW5pdGlhbFN0YXRlO1xuICB9XG4gIGZ1bmN0aW9uIHJlZHVjZXIoc3RhdGUgPSBnZXRJbml0aWFsU3RhdGUoKSwgYWN0aW9uKSB7XG4gICAgbGV0IGNhc2VSZWR1Y2VycyA9IFthY3Rpb25zTWFwW2FjdGlvbi50eXBlXSwgLi4uZmluYWxBY3Rpb25NYXRjaGVycy5maWx0ZXIoKHtcbiAgICAgIG1hdGNoZXJcbiAgICB9KSA9PiBtYXRjaGVyKGFjdGlvbikpLm1hcCgoe1xuICAgICAgcmVkdWNlcjogcmVkdWNlcjJcbiAgICB9KSA9PiByZWR1Y2VyMildO1xuICAgIGlmIChjYXNlUmVkdWNlcnMuZmlsdGVyKChjcikgPT4gISFjcikubGVuZ3RoID09PSAwKSB7XG4gICAgICBjYXNlUmVkdWNlcnMgPSBbZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXJdO1xuICAgIH1cbiAgICByZXR1cm4gY2FzZVJlZHVjZXJzLnJlZHVjZSgocHJldmlvdXNTdGF0ZSwgY2FzZVJlZHVjZXIpID0+IHtcbiAgICAgIGlmIChjYXNlUmVkdWNlcikge1xuICAgICAgICBpZiAoaXNEcmFmdDIocHJldmlvdXNTdGF0ZSkpIHtcbiAgICAgICAgICBjb25zdCBkcmFmdCA9IHByZXZpb3VzU3RhdGU7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2FzZVJlZHVjZXIoZHJhZnQsIGFjdGlvbik7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIGlmICghaXNEcmFmdGFibGUyKHByZXZpb3VzU3RhdGUpKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2FzZVJlZHVjZXIocHJldmlvdXNTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c1N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1N0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJBIGNhc2UgcmVkdWNlciBvbiBhIG5vbi1kcmFmdGFibGUgdmFsdWUgbXVzdCBub3QgcmV0dXJuIHVuZGVmaW5lZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlTmV4dFN0YXRlMihwcmV2aW91c1N0YXRlLCAoZHJhZnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XG4gICAgfSwgc3RhdGUpO1xuICB9XG4gIHJlZHVjZXIuZ2V0SW5pdGlhbFN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlO1xuICByZXR1cm4gcmVkdWNlcjtcbn1cblxuLy8gc3JjL21hdGNoZXJzLnRzXG52YXIgbWF0Y2hlcyA9IChtYXRjaGVyLCBhY3Rpb24pID0+IHtcbiAgaWYgKGhhc01hdGNoRnVuY3Rpb24obWF0Y2hlcikpIHtcbiAgICByZXR1cm4gbWF0Y2hlci5tYXRjaChhY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYXRjaGVyKGFjdGlvbik7XG4gIH1cbn07XG5mdW5jdGlvbiBpc0FueU9mKC4uLm1hdGNoZXJzKSB7XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgcmV0dXJuIG1hdGNoZXJzLnNvbWUoKG1hdGNoZXIpID0+IG1hdGNoZXMobWF0Y2hlciwgYWN0aW9uKSk7XG4gIH07XG59XG5mdW5jdGlvbiBpc0FsbE9mKC4uLm1hdGNoZXJzKSB7XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgcmV0dXJuIG1hdGNoZXJzLmV2ZXJ5KChtYXRjaGVyKSA9PiBtYXRjaGVzKG1hdGNoZXIsIGFjdGlvbikpO1xuICB9O1xufVxuZnVuY3Rpb24gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCB2YWxpZFN0YXR1cykge1xuICBpZiAoIWFjdGlvbiB8fCAhYWN0aW9uLm1ldGEpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgaGFzVmFsaWRSZXF1ZXN0SWQgPSB0eXBlb2YgYWN0aW9uLm1ldGEucmVxdWVzdElkID09PSBcInN0cmluZ1wiO1xuICBjb25zdCBoYXNWYWxpZFJlcXVlc3RTdGF0dXMgPSB2YWxpZFN0YXR1cy5pbmRleE9mKGFjdGlvbi5tZXRhLnJlcXVlc3RTdGF0dXMpID4gLTE7XG4gIHJldHVybiBoYXNWYWxpZFJlcXVlc3RJZCAmJiBoYXNWYWxpZFJlcXVlc3RTdGF0dXM7XG59XG5mdW5jdGlvbiBpc0FzeW5jVGh1bmtBcnJheShhKSB7XG4gIHJldHVybiB0eXBlb2YgYVswXSA9PT0gXCJmdW5jdGlvblwiICYmIFwicGVuZGluZ1wiIGluIGFbMF0gJiYgXCJmdWxmaWxsZWRcIiBpbiBhWzBdICYmIFwicmVqZWN0ZWRcIiBpbiBhWzBdO1xufVxuZnVuY3Rpb24gaXNQZW5kaW5nKC4uLmFzeW5jVGh1bmtzKSB7XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFjdGlvbikgPT4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJwZW5kaW5nXCJdKTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc1BlbmRpbmcoKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIGlzQW55T2YoLi4uYXN5bmNUaHVua3MubWFwKChhc3luY1RodW5rKSA9PiBhc3luY1RodW5rLnBlbmRpbmcpKTtcbn1cbmZ1bmN0aW9uIGlzUmVqZWN0ZWQoLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInJlamVjdGVkXCJdKTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc1JlamVjdGVkKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiBpc0FueU9mKC4uLmFzeW5jVGh1bmtzLm1hcCgoYXN5bmNUaHVuaykgPT4gYXN5bmNUaHVuay5yZWplY3RlZCkpO1xufVxuZnVuY3Rpb24gaXNSZWplY3RlZFdpdGhWYWx1ZSguLi5hc3luY1RodW5rcykge1xuICBjb25zdCBoYXNGbGFnID0gKGFjdGlvbikgPT4ge1xuICAgIHJldHVybiBhY3Rpb24gJiYgYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWU7XG4gIH07XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gaXNBbGxPZihpc1JlamVjdGVkKC4uLmFzeW5jVGh1bmtzKSwgaGFzRmxhZyk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNSZWplY3RlZFdpdGhWYWx1ZSgpKGFzeW5jVGh1bmtzWzBdKTtcbiAgfVxuICByZXR1cm4gaXNBbGxPZihpc1JlamVjdGVkKC4uLmFzeW5jVGh1bmtzKSwgaGFzRmxhZyk7XG59XG5mdW5jdGlvbiBpc0Z1bGZpbGxlZCguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wiZnVsZmlsbGVkXCJdKTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc0Z1bGZpbGxlZCgpKGFzeW5jVGh1bmtzWzBdKTtcbiAgfVxuICByZXR1cm4gaXNBbnlPZiguLi5hc3luY1RodW5rcy5tYXAoKGFzeW5jVGh1bmspID0+IGFzeW5jVGh1bmsuZnVsZmlsbGVkKSk7XG59XG5mdW5jdGlvbiBpc0FzeW5jVGh1bmtBY3Rpb24oLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInBlbmRpbmdcIiwgXCJmdWxmaWxsZWRcIiwgXCJyZWplY3RlZFwiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNBc3luY1RodW5rQWN0aW9uKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiBpc0FueU9mKC4uLmFzeW5jVGh1bmtzLmZsYXRNYXAoKGFzeW5jVGh1bmspID0+IFthc3luY1RodW5rLnBlbmRpbmcsIGFzeW5jVGh1bmsucmVqZWN0ZWQsIGFzeW5jVGh1bmsuZnVsZmlsbGVkXSkpO1xufVxuXG4vLyBzcmMvbmFub2lkLnRzXG52YXIgdXJsQWxwaGFiZXQgPSBcIk1vZHVsZVN5bWJoYXNPd25Qci0wMTIzNDU2Nzg5QUJDREVGR0hOUlZmZ2N0aVV2el9LcVlUSmtMeHBaWElqUVdcIjtcbnZhciBuYW5vaWQgPSAoc2l6ZSA9IDIxKSA9PiB7XG4gIGxldCBpZCA9IFwiXCI7XG4gIGxldCBpID0gc2l6ZTtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlkICs9IHVybEFscGhhYmV0W01hdGgucmFuZG9tKCkgKiA2NCB8IDBdO1xuICB9XG4gIHJldHVybiBpZDtcbn07XG5cbi8vIHNyYy9jcmVhdGVBc3luY1RodW5rLnRzXG52YXIgY29tbW9uUHJvcGVydGllcyA9IFtcIm5hbWVcIiwgXCJtZXNzYWdlXCIsIFwic3RhY2tcIiwgXCJjb2RlXCJdO1xudmFyIFJlamVjdFdpdGhWYWx1ZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocGF5bG9hZCwgbWV0YSkge1xuICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgfVxuICAvKlxuICB0eXBlLW9ubHkgcHJvcGVydHkgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBSZWplY3RXaXRoVmFsdWUgYW5kIEZ1bGZpbGxXaXRoTWV0YVxuICBkb2VzIG5vdCBleGlzdCBhdCBydW50aW1lXG4gICovXG4gIF90eXBlO1xufTtcbnZhciBGdWxmaWxsV2l0aE1ldGEgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHBheWxvYWQsIG1ldGEpIHtcbiAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gIH1cbiAgLypcbiAgdHlwZS1vbmx5IHByb3BlcnR5IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gUmVqZWN0V2l0aFZhbHVlIGFuZCBGdWxmaWxsV2l0aE1ldGFcbiAgZG9lcyBub3QgZXhpc3QgYXQgcnVudGltZVxuICAqL1xuICBfdHlwZTtcbn07XG52YXIgbWluaVNlcmlhbGl6ZUVycm9yID0gKHZhbHVlKSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICBjb25zdCBzaW1wbGVFcnJvciA9IHt9O1xuICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2YgY29tbW9uUHJvcGVydGllcykge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZVtwcm9wZXJ0eV0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc2ltcGxlRXJyb3JbcHJvcGVydHldID0gdmFsdWVbcHJvcGVydHldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2ltcGxlRXJyb3I7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlOiBTdHJpbmcodmFsdWUpXG4gIH07XG59O1xudmFyIGV4dGVybmFsQWJvcnRNZXNzYWdlID0gXCJFeHRlcm5hbCBzaWduYWwgd2FzIGFib3J0ZWRcIjtcbnZhciBjcmVhdGVBc3luY1RodW5rID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUFzeW5jVGh1bmsyKHR5cGVQcmVmaXgsIHBheWxvYWRDcmVhdG9yLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZnVsZmlsbGVkID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9mdWxmaWxsZWRcIiwgKHBheWxvYWQsIHJlcXVlc3RJZCwgYXJnLCBtZXRhKSA9PiAoe1xuICAgICAgcGF5bG9hZCxcbiAgICAgIG1ldGE6IHtcbiAgICAgICAgLi4ubWV0YSB8fCB7fSxcbiAgICAgICAgYXJnLFxuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHJlcXVlc3RTdGF0dXM6IFwiZnVsZmlsbGVkXCJcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgY29uc3QgcGVuZGluZyA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvcGVuZGluZ1wiLCAocmVxdWVzdElkLCBhcmcsIG1ldGEpID0+ICh7XG4gICAgICBwYXlsb2FkOiB2b2lkIDAsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLm1ldGEgfHwge30sXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiBcInBlbmRpbmdcIlxuICAgICAgfVxuICAgIH0pKTtcbiAgICBjb25zdCByZWplY3RlZCA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvcmVqZWN0ZWRcIiwgKGVycm9yLCByZXF1ZXN0SWQsIGFyZywgcGF5bG9hZCwgbWV0YSkgPT4gKHtcbiAgICAgIHBheWxvYWQsXG4gICAgICBlcnJvcjogKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXJpYWxpemVFcnJvciB8fCBtaW5pU2VyaWFsaXplRXJyb3IpKGVycm9yIHx8IFwiUmVqZWN0ZWRcIiksXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLm1ldGEgfHwge30sXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZWplY3RlZFdpdGhWYWx1ZTogISFwYXlsb2FkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiBcInJlamVjdGVkXCIsXG4gICAgICAgIGFib3J0ZWQ6IGVycm9yPy5uYW1lID09PSBcIkFib3J0RXJyb3JcIixcbiAgICAgICAgY29uZGl0aW9uOiBlcnJvcj8ubmFtZSA9PT0gXCJDb25kaXRpb25FcnJvclwiXG4gICAgICB9XG4gICAgfSkpO1xuICAgIGZ1bmN0aW9uIGFjdGlvbkNyZWF0b3IoYXJnLCB7XG4gICAgICBzaWduYWxcbiAgICB9ID0ge30pIHtcbiAgICAgIHJldHVybiAoZGlzcGF0Y2gsIGdldFN0YXRlLCBleHRyYSkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSBvcHRpb25zPy5pZEdlbmVyYXRvciA/IG9wdGlvbnMuaWRHZW5lcmF0b3IoYXJnKSA6IG5hbm9pZCgpO1xuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGxldCBhYm9ydEhhbmRsZXI7XG4gICAgICAgIGxldCBhYm9ydFJlYXNvbjtcbiAgICAgICAgZnVuY3Rpb24gYWJvcnQocmVhc29uKSB7XG4gICAgICAgICAgYWJvcnRSZWFzb24gPSByZWFzb247XG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgYWJvcnQoZXh0ZXJuYWxBYm9ydE1lc3NhZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IGFib3J0KGV4dGVybmFsQWJvcnRNZXNzYWdlKSwge1xuICAgICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxldCBmaW5hbEFjdGlvbjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGNvbmRpdGlvblJlc3VsdCA9IG9wdGlvbnM/LmNvbmRpdGlvbj8uKGFyZywge1xuICAgICAgICAgICAgICBnZXRTdGF0ZSxcbiAgICAgICAgICAgICAgZXh0cmFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGlzVGhlbmFibGUoY29uZGl0aW9uUmVzdWx0KSkge1xuICAgICAgICAgICAgICBjb25kaXRpb25SZXN1bHQgPSBhd2FpdCBjb25kaXRpb25SZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZGl0aW9uUmVzdWx0ID09PSBmYWxzZSB8fCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiQ29uZGl0aW9uRXJyb3JcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkFib3J0ZWQgZHVlIHRvIGNvbmRpdGlvbiBjYWxsYmFjayByZXR1cm5pbmcgZmFsc2UuXCJcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFib3J0ZWRQcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICBhYm9ydEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiQWJvcnRFcnJvclwiLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYWJvcnRSZWFzb24gfHwgXCJBYm9ydGVkXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGlzcGF0Y2gocGVuZGluZyhyZXF1ZXN0SWQsIGFyZywgb3B0aW9ucz8uZ2V0UGVuZGluZ01ldGE/Lih7XG4gICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgYXJnXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGdldFN0YXRlLFxuICAgICAgICAgICAgICBleHRyYVxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIGZpbmFsQWN0aW9uID0gYXdhaXQgUHJvbWlzZS5yYWNlKFthYm9ydGVkUHJvbWlzZSwgUHJvbWlzZS5yZXNvbHZlKHBheWxvYWRDcmVhdG9yKGFyZywge1xuICAgICAgICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgICAgICAgZ2V0U3RhdGUsXG4gICAgICAgICAgICAgIGV4dHJhLFxuICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgICAgIHJlamVjdFdpdGhWYWx1ZTogKHZhbHVlLCBtZXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWplY3RXaXRoVmFsdWUodmFsdWUsIG1ldGEpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBmdWxmaWxsV2l0aFZhbHVlOiAodmFsdWUsIG1ldGEpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZ1bGZpbGxXaXRoTWV0YSh2YWx1ZSwgbWV0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFJlamVjdFdpdGhWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRnVsZmlsbFdpdGhNZXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZChyZXN1bHQucGF5bG9hZCwgcmVxdWVzdElkLCBhcmcsIHJlc3VsdC5tZXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkKHJlc3VsdCwgcmVxdWVzdElkLCBhcmcpO1xuICAgICAgICAgICAgfSldKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGZpbmFsQWN0aW9uID0gZXJyIGluc3RhbmNlb2YgUmVqZWN0V2l0aFZhbHVlID8gcmVqZWN0ZWQobnVsbCwgcmVxdWVzdElkLCBhcmcsIGVyci5wYXlsb2FkLCBlcnIubWV0YSkgOiByZWplY3RlZChlcnIsIHJlcXVlc3RJZCwgYXJnKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGFib3J0SGFuZGxlcikge1xuICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBza2lwRGlzcGF0Y2ggPSBvcHRpb25zICYmICFvcHRpb25zLmRpc3BhdGNoQ29uZGl0aW9uUmVqZWN0aW9uICYmIHJlamVjdGVkLm1hdGNoKGZpbmFsQWN0aW9uKSAmJiBmaW5hbEFjdGlvbi5tZXRhLmNvbmRpdGlvbjtcbiAgICAgICAgICBpZiAoIXNraXBEaXNwYXRjaCkge1xuICAgICAgICAgICAgZGlzcGF0Y2goZmluYWxBY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmluYWxBY3Rpb247XG4gICAgICAgIH0oKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvbWlzZSwge1xuICAgICAgICAgIGFib3J0LFxuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICBhcmcsXG4gICAgICAgICAgdW53cmFwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbih1bndyYXBSZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY3Rpb25DcmVhdG9yLCB7XG4gICAgICBwZW5kaW5nLFxuICAgICAgcmVqZWN0ZWQsXG4gICAgICBmdWxmaWxsZWQsXG4gICAgICBzZXR0bGVkOiBpc0FueU9mKHJlamVjdGVkLCBmdWxmaWxsZWQpLFxuICAgICAgdHlwZVByZWZpeFxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZUFzeW5jVGh1bmsyLndpdGhUeXBlcyA9ICgpID0+IGNyZWF0ZUFzeW5jVGh1bmsyO1xuICByZXR1cm4gY3JlYXRlQXN5bmNUaHVuazI7XG59KSgpO1xuZnVuY3Rpb24gdW53cmFwUmVzdWx0KGFjdGlvbikge1xuICBpZiAoYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWUpIHtcbiAgICB0aHJvdyBhY3Rpb24ucGF5bG9hZDtcbiAgfVxuICBpZiAoYWN0aW9uLmVycm9yKSB7XG4gICAgdGhyb3cgYWN0aW9uLmVycm9yO1xuICB9XG4gIHJldHVybiBhY3Rpb24ucGF5bG9hZDtcbn1cbmZ1bmN0aW9uIGlzVGhlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vLyBzcmMvY3JlYXRlU2xpY2UudHNcbnZhciBhc3luY1RodW5rU3ltYm9sID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJydGstc2xpY2UtY3JlYXRlYXN5bmN0aHVua1wiKTtcbnZhciBhc3luY1RodW5rQ3JlYXRvciA9IHtcbiAgW2FzeW5jVGh1bmtTeW1ib2xdOiBjcmVhdGVBc3luY1RodW5rXG59O1xudmFyIFJlZHVjZXJUeXBlID0gLyogQF9fUFVSRV9fICovICgoUmVkdWNlclR5cGUyKSA9PiB7XG4gIFJlZHVjZXJUeXBlMltcInJlZHVjZXJcIl0gPSBcInJlZHVjZXJcIjtcbiAgUmVkdWNlclR5cGUyW1wicmVkdWNlcldpdGhQcmVwYXJlXCJdID0gXCJyZWR1Y2VyV2l0aFByZXBhcmVcIjtcbiAgUmVkdWNlclR5cGUyW1wiYXN5bmNUaHVua1wiXSA9IFwiYXN5bmNUaHVua1wiO1xuICByZXR1cm4gUmVkdWNlclR5cGUyO1xufSkoUmVkdWNlclR5cGUgfHwge30pO1xuZnVuY3Rpb24gZ2V0VHlwZShzbGljZSwgYWN0aW9uS2V5KSB7XG4gIHJldHVybiBgJHtzbGljZX0vJHthY3Rpb25LZXl9YDtcbn1cbmZ1bmN0aW9uIGJ1aWxkQ3JlYXRlU2xpY2Uoe1xuICBjcmVhdG9yc1xufSA9IHt9KSB7XG4gIGNvbnN0IGNBVCA9IGNyZWF0b3JzPy5hc3luY1RodW5rPy5bYXN5bmNUaHVua1N5bWJvbF07XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVTbGljZTIob3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICByZWR1Y2VyUGF0aCA9IG5hbWVcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDExKSA6IFwiYG5hbWVgIGlzIGEgcmVxdWlyZWQgb3B0aW9uIGZvciBjcmVhdGVTbGljZVwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgIGlmIChvcHRpb25zLmluaXRpYWxTdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJZb3UgbXVzdCBwcm92aWRlIGFuIGBpbml0aWFsU3RhdGVgIHZhbHVlIHRoYXQgaXMgbm90IGB1bmRlZmluZWRgLiBZb3UgbWF5IGhhdmUgbWlzc3BlbGxlZCBgaW5pdGlhbFN0YXRlYFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVkdWNlcnMgPSAodHlwZW9mIG9wdGlvbnMucmVkdWNlcnMgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMucmVkdWNlcnMoYnVpbGRSZWR1Y2VyQ3JlYXRvcnMoKSkgOiBvcHRpb25zLnJlZHVjZXJzKSB8fCB7fTtcbiAgICBjb25zdCByZWR1Y2VyTmFtZXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIHNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lOiB7fSxcbiAgICAgIHNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlOiB7fSxcbiAgICAgIGFjdGlvbkNyZWF0b3JzOiB7fSxcbiAgICAgIHNsaWNlTWF0Y2hlcnM6IFtdXG4gICAgfTtcbiAgICBjb25zdCBjb250ZXh0TWV0aG9kcyA9IHtcbiAgICAgIGFkZENhc2UodHlwZU9yQWN0aW9uQ3JlYXRvciwgcmVkdWNlcjIpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB0eXBlT3JBY3Rpb25DcmVhdG9yID09PSBcInN0cmluZ1wiID8gdHlwZU9yQWN0aW9uQ3JlYXRvciA6IHR5cGVPckFjdGlvbkNyZWF0b3IudHlwZTtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTIpIDogXCJgY29udGV4dC5hZGRDYXNlYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggYW4gZW1wdHkgYWN0aW9uIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgaW4gY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEzKSA6IFwiYGNvbnRleHQuYWRkQ2FzZWAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIHR3byByZWR1Y2VycyBmb3IgdGhlIHNhbWUgYWN0aW9uIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZVt0eXBlXSA9IHJlZHVjZXIyO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9LFxuICAgICAgYWRkTWF0Y2hlcihtYXRjaGVyLCByZWR1Y2VyMikge1xuICAgICAgICBjb250ZXh0LnNsaWNlTWF0Y2hlcnMucHVzaCh7XG4gICAgICAgICAgbWF0Y2hlcixcbiAgICAgICAgICByZWR1Y2VyOiByZWR1Y2VyMlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZXRob2RzO1xuICAgICAgfSxcbiAgICAgIGV4cG9zZUFjdGlvbihuYW1lMiwgYWN0aW9uQ3JlYXRvcikge1xuICAgICAgICBjb250ZXh0LmFjdGlvbkNyZWF0b3JzW25hbWUyXSA9IGFjdGlvbkNyZWF0b3I7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcbiAgICAgIH0sXG4gICAgICBleHBvc2VDYXNlUmVkdWNlcihuYW1lMiwgcmVkdWNlcjIpIHtcbiAgICAgICAgY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZVtuYW1lMl0gPSByZWR1Y2VyMjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZXRob2RzO1xuICAgICAgfVxuICAgIH07XG4gICAgcmVkdWNlck5hbWVzLmZvckVhY2goKHJlZHVjZXJOYW1lKSA9PiB7XG4gICAgICBjb25zdCByZWR1Y2VyRGVmaW5pdGlvbiA9IHJlZHVjZXJzW3JlZHVjZXJOYW1lXTtcbiAgICAgIGNvbnN0IHJlZHVjZXJEZXRhaWxzID0ge1xuICAgICAgICByZWR1Y2VyTmFtZSxcbiAgICAgICAgdHlwZTogZ2V0VHlwZShuYW1lLCByZWR1Y2VyTmFtZSksXG4gICAgICAgIGNyZWF0ZU5vdGF0aW9uOiB0eXBlb2Ygb3B0aW9ucy5yZWR1Y2VycyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICB9O1xuICAgICAgaWYgKGlzQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRlZmluaXRpb24pKSB7XG4gICAgICAgIGhhbmRsZVRodW5rQ2FzZVJlZHVjZXJEZWZpbml0aW9uKHJlZHVjZXJEZXRhaWxzLCByZWR1Y2VyRGVmaW5pdGlvbiwgY29udGV4dE1ldGhvZHMsIGNBVCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVOb3JtYWxSZWR1Y2VyRGVmaW5pdGlvbihyZWR1Y2VyRGV0YWlscywgcmVkdWNlckRlZmluaXRpb24sIGNvbnRleHRNZXRob2RzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBidWlsZFJlZHVjZXIoKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5leHRyYVJlZHVjZXJzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTQpIDogXCJUaGUgb2JqZWN0IG5vdGF0aW9uIGZvciBgY3JlYXRlU2xpY2UuZXh0cmFSZWR1Y2Vyc2AgaGFzIGJlZW4gcmVtb3ZlZC4gUGxlYXNlIHVzZSB0aGUgJ2J1aWxkZXIgY2FsbGJhY2snIG5vdGF0aW9uIGluc3RlYWQ6IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2NyZWF0ZVNsaWNlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBbZXh0cmFSZWR1Y2VycyA9IHt9LCBhY3Rpb25NYXRjaGVycyA9IFtdLCBkZWZhdWx0Q2FzZVJlZHVjZXIgPSB2b2lkIDBdID0gdHlwZW9mIG9wdGlvbnMuZXh0cmFSZWR1Y2VycyA9PT0gXCJmdW5jdGlvblwiID8gZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2sob3B0aW9ucy5leHRyYVJlZHVjZXJzKSA6IFtvcHRpb25zLmV4dHJhUmVkdWNlcnNdO1xuICAgICAgY29uc3QgZmluYWxDYXNlUmVkdWNlcnMgPSB7XG4gICAgICAgIC4uLmV4dHJhUmVkdWNlcnMsXG4gICAgICAgIC4uLmNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGVcbiAgICAgIH07XG4gICAgICByZXR1cm4gY3JlYXRlUmVkdWNlcihvcHRpb25zLmluaXRpYWxTdGF0ZSwgKGJ1aWxkZXIpID0+IHtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGZpbmFsQ2FzZVJlZHVjZXJzKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGRDYXNlKGtleSwgZmluYWxDYXNlUmVkdWNlcnNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgc00gb2YgY29udGV4dC5zbGljZU1hdGNoZXJzKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGRNYXRjaGVyKHNNLm1hdGNoZXIsIHNNLnJlZHVjZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG0gb2YgYWN0aW9uTWF0Y2hlcnMpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZE1hdGNoZXIobS5tYXRjaGVyLCBtLnJlZHVjZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZERlZmF1bHRDYXNlKGRlZmF1bHRDYXNlUmVkdWNlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RTZWxmID0gKHN0YXRlKSA9PiBzdGF0ZTtcbiAgICBjb25zdCBpbmplY3RlZFNlbGVjdG9yQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCBfcmVkdWNlcjtcbiAgICBmdW5jdGlvbiByZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgIGlmICghX3JlZHVjZXIpIF9yZWR1Y2VyID0gYnVpbGRSZWR1Y2VyKCk7XG4gICAgICByZXR1cm4gX3JlZHVjZXIoc3RhdGUsIGFjdGlvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICAgIGlmICghX3JlZHVjZXIpIF9yZWR1Y2VyID0gYnVpbGRSZWR1Y2VyKCk7XG4gICAgICByZXR1cm4gX3JlZHVjZXIuZ2V0SW5pdGlhbFN0YXRlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VTZWxlY3RvclByb3BzKHJlZHVjZXJQYXRoMiwgaW5qZWN0ZWQgPSBmYWxzZSkge1xuICAgICAgZnVuY3Rpb24gc2VsZWN0U2xpY2Uoc3RhdGUpIHtcbiAgICAgICAgbGV0IHNsaWNlU3RhdGUgPSBzdGF0ZVtyZWR1Y2VyUGF0aDJdO1xuICAgICAgICBpZiAodHlwZW9mIHNsaWNlU3RhdGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBpZiAoaW5qZWN0ZWQpIHtcbiAgICAgICAgICAgIHNsaWNlU3RhdGUgPSBnZXRJbml0aWFsU3RhdGUoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTUpIDogXCJzZWxlY3RTbGljZSByZXR1cm5lZCB1bmRlZmluZWQgZm9yIGFuIHVuaW5qZWN0ZWQgc2xpY2UgcmVkdWNlclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNsaWNlU3RhdGU7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnZXRTZWxlY3RvcnMoc2VsZWN0U3RhdGUgPSBzZWxlY3RTZWxmKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yQ2FjaGUgPSBnZXRPckluc2VydENvbXB1dGVkKGluamVjdGVkU2VsZWN0b3JDYWNoZSwgaW5qZWN0ZWQsICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbiAgICAgICAgcmV0dXJuIGdldE9ySW5zZXJ0Q29tcHV0ZWQoc2VsZWN0b3JDYWNoZSwgc2VsZWN0U3RhdGUsICgpID0+IHtcbiAgICAgICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lMiwgc2VsZWN0b3JdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMuc2VsZWN0b3JzID8/IHt9KSkge1xuICAgICAgICAgICAgbWFwW25hbWUyXSA9IHdyYXBTZWxlY3RvcihzZWxlY3Rvciwgc2VsZWN0U3RhdGUsIGdldEluaXRpYWxTdGF0ZSwgaW5qZWN0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZHVjZXJQYXRoOiByZWR1Y2VyUGF0aDIsXG4gICAgICAgIGdldFNlbGVjdG9ycyxcbiAgICAgICAgZ2V0IHNlbGVjdG9ycygpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0U2VsZWN0b3JzKHNlbGVjdFNsaWNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZWN0U2xpY2VcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHNsaWNlID0ge1xuICAgICAgbmFtZSxcbiAgICAgIHJlZHVjZXIsXG4gICAgICBhY3Rpb25zOiBjb250ZXh0LmFjdGlvbkNyZWF0b3JzLFxuICAgICAgY2FzZVJlZHVjZXJzOiBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lLFxuICAgICAgZ2V0SW5pdGlhbFN0YXRlLFxuICAgICAgLi4ubWFrZVNlbGVjdG9yUHJvcHMocmVkdWNlclBhdGgpLFxuICAgICAgaW5qZWN0SW50byhpbmplY3RhYmxlLCB7XG4gICAgICAgIHJlZHVjZXJQYXRoOiBwYXRoT3B0LFxuICAgICAgICAuLi5jb25maWdcbiAgICAgIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBuZXdSZWR1Y2VyUGF0aCA9IHBhdGhPcHQgPz8gcmVkdWNlclBhdGg7XG4gICAgICAgIGluamVjdGFibGUuaW5qZWN0KHtcbiAgICAgICAgICByZWR1Y2VyUGF0aDogbmV3UmVkdWNlclBhdGgsXG4gICAgICAgICAgcmVkdWNlclxuICAgICAgICB9LCBjb25maWcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnNsaWNlLFxuICAgICAgICAgIC4uLm1ha2VTZWxlY3RvclByb3BzKG5ld1JlZHVjZXJQYXRoLCB0cnVlKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHNsaWNlO1xuICB9O1xufVxuZnVuY3Rpb24gd3JhcFNlbGVjdG9yKHNlbGVjdG9yLCBzZWxlY3RTdGF0ZSwgZ2V0SW5pdGlhbFN0YXRlLCBpbmplY3RlZCkge1xuICBmdW5jdGlvbiB3cmFwcGVyKHJvb3RTdGF0ZSwgLi4uYXJncykge1xuICAgIGxldCBzbGljZVN0YXRlID0gc2VsZWN0U3RhdGUocm9vdFN0YXRlKTtcbiAgICBpZiAodHlwZW9mIHNsaWNlU3RhdGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChpbmplY3RlZCkge1xuICAgICAgICBzbGljZVN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNikgOiBcInNlbGVjdFN0YXRlIHJldHVybmVkIHVuZGVmaW5lZCBmb3IgYW4gdW5pbmplY3RlZCBzbGljZSByZWR1Y2VyXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0b3Ioc2xpY2VTdGF0ZSwgLi4uYXJncyk7XG4gIH1cbiAgd3JhcHBlci51bndyYXBwZWQgPSBzZWxlY3RvcjtcbiAgcmV0dXJuIHdyYXBwZXI7XG59XG52YXIgY3JlYXRlU2xpY2UgPSAvKiBAX19QVVJFX18gKi8gYnVpbGRDcmVhdGVTbGljZSgpO1xuZnVuY3Rpb24gYnVpbGRSZWR1Y2VyQ3JlYXRvcnMoKSB7XG4gIGZ1bmN0aW9uIGFzeW5jVGh1bmsocGF5bG9hZENyZWF0b3IsIGNvbmZpZykge1xuICAgIHJldHVybiB7XG4gICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcImFzeW5jVGh1bmtcIiAvKiBhc3luY1RodW5rICovLFxuICAgICAgcGF5bG9hZENyZWF0b3IsXG4gICAgICAuLi5jb25maWdcbiAgICB9O1xuICB9XG4gIGFzeW5jVGh1bmsud2l0aFR5cGVzID0gKCkgPT4gYXN5bmNUaHVuaztcbiAgcmV0dXJuIHtcbiAgICByZWR1Y2VyKGNhc2VSZWR1Y2VyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIC8vIGhhY2sgc28gdGhlIHdyYXBwaW5nIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBuYW1lIGFzIHRoZSBvcmlnaW5hbFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHdyYXBwZXIgc28gdGhlIGByZWR1Y2VyRGVmaW5pdGlvblR5cGVgIGlzIG5vdCBhc3NpZ25lZCB0byB0aGUgb3JpZ2luYWxcbiAgICAgICAgW2Nhc2VSZWR1Y2VyLm5hbWVdKC4uLmFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXIoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1bY2FzZVJlZHVjZXIubmFtZV0sIHtcbiAgICAgICAgX3JlZHVjZXJEZWZpbml0aW9uVHlwZTogXCJyZWR1Y2VyXCIgLyogcmVkdWNlciAqL1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBwcmVwYXJlZFJlZHVjZXIocHJlcGFyZSwgcmVkdWNlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX3JlZHVjZXJEZWZpbml0aW9uVHlwZTogXCJyZWR1Y2VyV2l0aFByZXBhcmVcIiAvKiByZWR1Y2VyV2l0aFByZXBhcmUgKi8sXG4gICAgICAgIHByZXBhcmUsXG4gICAgICAgIHJlZHVjZXJcbiAgICAgIH07XG4gICAgfSxcbiAgICBhc3luY1RodW5rXG4gIH07XG59XG5mdW5jdGlvbiBoYW5kbGVOb3JtYWxSZWR1Y2VyRGVmaW5pdGlvbih7XG4gIHR5cGUsXG4gIHJlZHVjZXJOYW1lLFxuICBjcmVhdGVOb3RhdGlvblxufSwgbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUsIGNvbnRleHQpIHtcbiAgbGV0IGNhc2VSZWR1Y2VyO1xuICBsZXQgcHJlcGFyZUNhbGxiYWNrO1xuICBpZiAoXCJyZWR1Y2VyXCIgaW4gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUpIHtcbiAgICBpZiAoY3JlYXRlTm90YXRpb24gJiYgIWlzQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZURlZmluaXRpb24obWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNykgOiBcIlBsZWFzZSB1c2UgdGhlIGBjcmVhdGUucHJlcGFyZWRSZWR1Y2VyYCBub3RhdGlvbiBmb3IgcHJlcGFyZWQgYWN0aW9uIGNyZWF0b3JzIHdpdGggdGhlIGBjcmVhdGVgIG5vdGF0aW9uLlwiKTtcbiAgICB9XG4gICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZS5yZWR1Y2VyO1xuICAgIHByZXBhcmVDYWxsYmFjayA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlLnByZXBhcmU7XG4gIH0gZWxzZSB7XG4gICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZTtcbiAgfVxuICBjb250ZXh0LmFkZENhc2UodHlwZSwgY2FzZVJlZHVjZXIpLmV4cG9zZUNhc2VSZWR1Y2VyKHJlZHVjZXJOYW1lLCBjYXNlUmVkdWNlcikuZXhwb3NlQWN0aW9uKHJlZHVjZXJOYW1lLCBwcmVwYXJlQ2FsbGJhY2sgPyBjcmVhdGVBY3Rpb24odHlwZSwgcHJlcGFyZUNhbGxiYWNrKSA6IGNyZWF0ZUFjdGlvbih0eXBlKSk7XG59XG5mdW5jdGlvbiBpc0FzeW5jVGh1bmtTbGljZVJlZHVjZXJEZWZpbml0aW9uKHJlZHVjZXJEZWZpbml0aW9uKSB7XG4gIHJldHVybiByZWR1Y2VyRGVmaW5pdGlvbi5fcmVkdWNlckRlZmluaXRpb25UeXBlID09PSBcImFzeW5jVGh1bmtcIiAvKiBhc3luY1RodW5rICovO1xufVxuZnVuY3Rpb24gaXNDYXNlUmVkdWNlcldpdGhQcmVwYXJlRGVmaW5pdGlvbihyZWR1Y2VyRGVmaW5pdGlvbikge1xuICByZXR1cm4gcmVkdWNlckRlZmluaXRpb24uX3JlZHVjZXJEZWZpbml0aW9uVHlwZSA9PT0gXCJyZWR1Y2VyV2l0aFByZXBhcmVcIiAvKiByZWR1Y2VyV2l0aFByZXBhcmUgKi87XG59XG5mdW5jdGlvbiBoYW5kbGVUaHVua0Nhc2VSZWR1Y2VyRGVmaW5pdGlvbih7XG4gIHR5cGUsXG4gIHJlZHVjZXJOYW1lXG59LCByZWR1Y2VyRGVmaW5pdGlvbiwgY29udGV4dCwgY0FUKSB7XG4gIGlmICghY0FUKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTgpIDogXCJDYW5ub3QgdXNlIGBjcmVhdGUuYXN5bmNUaHVua2AgaW4gdGhlIGJ1aWx0LWluIGBjcmVhdGVTbGljZWAuIFVzZSBgYnVpbGRDcmVhdGVTbGljZSh7IGNyZWF0b3JzOiB7IGFzeW5jVGh1bms6IGFzeW5jVGh1bmtDcmVhdG9yIH0gfSlgIHRvIGNyZWF0ZSBhIGN1c3RvbWlzZWQgdmVyc2lvbiBvZiBgY3JlYXRlU2xpY2VgLlwiKTtcbiAgfVxuICBjb25zdCB7XG4gICAgcGF5bG9hZENyZWF0b3IsXG4gICAgZnVsZmlsbGVkLFxuICAgIHBlbmRpbmcsXG4gICAgcmVqZWN0ZWQsXG4gICAgc2V0dGxlZCxcbiAgICBvcHRpb25zXG4gIH0gPSByZWR1Y2VyRGVmaW5pdGlvbjtcbiAgY29uc3QgdGh1bmsgPSBjQVQodHlwZSwgcGF5bG9hZENyZWF0b3IsIG9wdGlvbnMpO1xuICBjb250ZXh0LmV4cG9zZUFjdGlvbihyZWR1Y2VyTmFtZSwgdGh1bmspO1xuICBpZiAoZnVsZmlsbGVkKSB7XG4gICAgY29udGV4dC5hZGRDYXNlKHRodW5rLmZ1bGZpbGxlZCwgZnVsZmlsbGVkKTtcbiAgfVxuICBpZiAocGVuZGluZykge1xuICAgIGNvbnRleHQuYWRkQ2FzZSh0aHVuay5wZW5kaW5nLCBwZW5kaW5nKTtcbiAgfVxuICBpZiAocmVqZWN0ZWQpIHtcbiAgICBjb250ZXh0LmFkZENhc2UodGh1bmsucmVqZWN0ZWQsIHJlamVjdGVkKTtcbiAgfVxuICBpZiAoc2V0dGxlZCkge1xuICAgIGNvbnRleHQuYWRkTWF0Y2hlcih0aHVuay5zZXR0bGVkLCBzZXR0bGVkKTtcbiAgfVxuICBjb250ZXh0LmV4cG9zZUNhc2VSZWR1Y2VyKHJlZHVjZXJOYW1lLCB7XG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQgfHwgbm9vcCxcbiAgICBwZW5kaW5nOiBwZW5kaW5nIHx8IG5vb3AsXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkIHx8IG5vb3AsXG4gICAgc2V0dGxlZDogc2V0dGxlZCB8fCBub29wXG4gIH0pO1xufVxuZnVuY3Rpb24gbm9vcCgpIHtcbn1cblxuLy8gc3JjL2VudGl0aWVzL2VudGl0eV9zdGF0ZS50c1xuZnVuY3Rpb24gZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCkge1xuICByZXR1cm4ge1xuICAgIGlkczogW10sXG4gICAgZW50aXRpZXM6IHt9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5KHN0YXRlQWRhcHRlcikge1xuICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoYWRkaXRpb25hbFN0YXRlID0ge30sIGVudGl0aWVzKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBPYmplY3QuYXNzaWduKGdldEluaXRpYWxFbnRpdHlTdGF0ZSgpLCBhZGRpdGlvbmFsU3RhdGUpO1xuICAgIHJldHVybiBlbnRpdGllcyA/IHN0YXRlQWRhcHRlci5zZXRBbGwoc3RhdGUsIGVudGl0aWVzKSA6IHN0YXRlO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0SW5pdGlhbFN0YXRlXG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy9zdGF0ZV9zZWxlY3RvcnMudHNcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkoKSB7XG4gIGZ1bmN0aW9uIGdldFNlbGVjdG9ycyhzZWxlY3RTdGF0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgY3JlYXRlU2VsZWN0b3I6IGNyZWF0ZVNlbGVjdG9yMiA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc2VsZWN0SWRzID0gKHN0YXRlKSA9PiBzdGF0ZS5pZHM7XG4gICAgY29uc3Qgc2VsZWN0RW50aXRpZXMgPSAoc3RhdGUpID0+IHN0YXRlLmVudGl0aWVzO1xuICAgIGNvbnN0IHNlbGVjdEFsbCA9IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RJZHMsIHNlbGVjdEVudGl0aWVzLCAoaWRzLCBlbnRpdGllcykgPT4gaWRzLm1hcCgoaWQpID0+IGVudGl0aWVzW2lkXSkpO1xuICAgIGNvbnN0IHNlbGVjdElkID0gKF8sIGlkKSA9PiBpZDtcbiAgICBjb25zdCBzZWxlY3RCeUlkID0gKGVudGl0aWVzLCBpZCkgPT4gZW50aXRpZXNbaWRdO1xuICAgIGNvbnN0IHNlbGVjdFRvdGFsID0gY3JlYXRlU2VsZWN0b3IyKHNlbGVjdElkcywgKGlkcykgPT4gaWRzLmxlbmd0aCk7XG4gICAgaWYgKCFzZWxlY3RTdGF0ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0SWRzLFxuICAgICAgICBzZWxlY3RFbnRpdGllcyxcbiAgICAgICAgc2VsZWN0QWxsLFxuICAgICAgICBzZWxlY3RUb3RhbCxcbiAgICAgICAgc2VsZWN0QnlJZDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdEVudGl0aWVzLCBzZWxlY3RJZCwgc2VsZWN0QnlJZClcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyA9IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0RW50aXRpZXMpO1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RJZHM6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0SWRzKSxcbiAgICAgIHNlbGVjdEVudGl0aWVzOiBzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMsXG4gICAgICBzZWxlY3RBbGw6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0QWxsKSxcbiAgICAgIHNlbGVjdFRvdGFsOiBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0U3RhdGUsIHNlbGVjdFRvdGFsKSxcbiAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMsIHNlbGVjdElkLCBzZWxlY3RCeUlkKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRTZWxlY3RvcnNcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3N0YXRlX2FkYXB0ZXIudHNcbmltcG9ydCB7IHByb2R1Y2UgYXMgY3JlYXRlTmV4dFN0YXRlMywgaXNEcmFmdCBhcyBpc0RyYWZ0MyB9IGZyb20gXCJpbW1lclwiO1xudmFyIGlzRHJhZnRUeXBlZCA9IGlzRHJhZnQzO1xuZnVuY3Rpb24gY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yKG11dGF0b3IpIHtcbiAgY29uc3Qgb3BlcmF0b3IgPSBjcmVhdGVTdGF0ZU9wZXJhdG9yKChfLCBzdGF0ZSkgPT4gbXV0YXRvcihzdGF0ZSkpO1xuICByZXR1cm4gZnVuY3Rpb24gb3BlcmF0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIG9wZXJhdG9yKHN0YXRlLCB2b2lkIDApO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGVPcGVyYXRvcihtdXRhdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb24oc3RhdGUsIGFyZykge1xuICAgIGZ1bmN0aW9uIGlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50KGFyZzIpIHtcbiAgICAgIHJldHVybiBpc0ZTQShhcmcyKTtcbiAgICB9XG4gICAgY29uc3QgcnVuTXV0YXRvciA9IChkcmFmdCkgPT4ge1xuICAgICAgaWYgKGlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50KGFyZykpIHtcbiAgICAgICAgbXV0YXRvcihhcmcucGF5bG9hZCwgZHJhZnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXV0YXRvcihhcmcsIGRyYWZ0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0RyYWZ0VHlwZWQoc3RhdGUpKSB7XG4gICAgICBydW5NdXRhdG9yKHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZU5leHRTdGF0ZTMoc3RhdGUsIHJ1bk11dGF0b3IpO1xuICB9O1xufVxuXG4vLyBzcmMvZW50aXRpZXMvdXRpbHMudHNcbmltcG9ydCB7IGN1cnJlbnQgYXMgY3VycmVudDIsIGlzRHJhZnQgYXMgaXNEcmFmdDQgfSBmcm9tIFwiaW1tZXJcIjtcbmZ1bmN0aW9uIHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCkge1xuICBjb25zdCBrZXkgPSBzZWxlY3RJZChlbnRpdHkpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGtleSA9PT0gdm9pZCAwKSB7XG4gICAgY29uc29sZS53YXJuKFwiVGhlIGVudGl0eSBwYXNzZWQgdG8gdGhlIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgdW5kZWZpbmVkLlwiLCBcIllvdSBzaG91bGQgcHJvYmFibHkgcHJvdmlkZSB5b3VyIG93biBgc2VsZWN0SWRgIGltcGxlbWVudGF0aW9uLlwiLCBcIlRoZSBlbnRpdHkgdGhhdCB3YXMgcGFzc2VkOlwiLCBlbnRpdHksIFwiVGhlIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb246XCIsIHNlbGVjdElkLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5mdW5jdGlvbiBlbnN1cmVFbnRpdGllc0FycmF5KGVudGl0aWVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShlbnRpdGllcykpIHtcbiAgICBlbnRpdGllcyA9IE9iamVjdC52YWx1ZXMoZW50aXRpZXMpO1xuICB9XG4gIHJldHVybiBlbnRpdGllcztcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnQodmFsdWUpIHtcbiAgcmV0dXJuIGlzRHJhZnQ0KHZhbHVlKSA/IGN1cnJlbnQyKHZhbHVlKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKSB7XG4gIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gIGNvbnN0IGV4aXN0aW5nSWRzQXJyYXkgPSBnZXRDdXJyZW50KHN0YXRlLmlkcyk7XG4gIGNvbnN0IGV4aXN0aW5nSWRzID0gbmV3IFNldChleGlzdGluZ0lkc0FycmF5KTtcbiAgY29uc3QgYWRkZWQgPSBbXTtcbiAgY29uc3QgdXBkYXRlZCA9IFtdO1xuICBmb3IgKGNvbnN0IGVudGl0eSBvZiBuZXdFbnRpdGllcykge1xuICAgIGNvbnN0IGlkID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcbiAgICBpZiAoZXhpc3RpbmdJZHMuaGFzKGlkKSkge1xuICAgICAgdXBkYXRlZC5wdXNoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGNoYW5nZXM6IGVudGl0eVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZGVkLnB1c2goZW50aXR5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFthZGRlZCwgdXBkYXRlZCwgZXhpc3RpbmdJZHNBcnJheV07XG59XG5cbi8vIHNyYy9lbnRpdGllcy91bnNvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCkge1xuICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICBjb25zdCBrZXkgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xuICAgIGlmIChrZXkgaW4gc3RhdGUuZW50aXRpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RhdGUuaWRzLnB1c2goa2V5KTtcbiAgICBzdGF0ZS5lbnRpdGllc1trZXldID0gZW50aXR5O1xuICB9XG4gIGZ1bmN0aW9uIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgbmV3RW50aXRpZXMpIHtcbiAgICAgIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIGNvbnN0IGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XG4gICAgaWYgKCEoa2V5IGluIHN0YXRlLmVudGl0aWVzKSkge1xuICAgICAgc3RhdGUuaWRzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgO1xuICAgIHN0YXRlLmVudGl0aWVzW2tleV0gPSBlbnRpdHk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBuZXdFbnRpdGllcykge1xuICAgICAgc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0QWxsTXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIHN0YXRlLmlkcyA9IFtdO1xuICAgIHN0YXRlLmVudGl0aWVzID0ge307XG4gICAgYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVPbmVNdXRhYmx5KGtleSwgc3RhdGUpIHtcbiAgICByZXR1cm4gcmVtb3ZlTWFueU11dGFibHkoW2tleV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVNYW55TXV0YWJseShrZXlzLCBzdGF0ZSkge1xuICAgIGxldCBkaWRNdXRhdGUgPSBmYWxzZTtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNba2V5XTtcbiAgICAgICAgZGlkTXV0YXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZGlkTXV0YXRlKSB7XG4gICAgICBzdGF0ZS5pZHMgPSBzdGF0ZS5pZHMuZmlsdGVyKChpZCkgPT4gaWQgaW4gc3RhdGUuZW50aXRpZXMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZW1vdmVBbGxNdXRhYmx5KHN0YXRlKSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZSwge1xuICAgICAgaWRzOiBbXSxcbiAgICAgIGVudGl0aWVzOiB7fVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHRha2VOZXdLZXkoa2V5cywgdXBkYXRlLCBzdGF0ZSkge1xuICAgIGNvbnN0IG9yaWdpbmFsMyA9IHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XG4gICAgaWYgKG9yaWdpbmFsMyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZWQgPSBPYmplY3QuYXNzaWduKHt9LCBvcmlnaW5hbDMsIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICBjb25zdCBuZXdLZXkgPSBzZWxlY3RJZFZhbHVlKHVwZGF0ZWQsIHNlbGVjdElkKTtcbiAgICBjb25zdCBoYXNOZXdLZXkgPSBuZXdLZXkgIT09IHVwZGF0ZS5pZDtcbiAgICBpZiAoaGFzTmV3S2V5KSB7XG4gICAgICBrZXlzW3VwZGF0ZS5pZF0gPSBuZXdLZXk7XG4gICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcbiAgICB9XG4gICAgO1xuICAgIHN0YXRlLmVudGl0aWVzW25ld0tleV0gPSB1cGRhdGVkO1xuICAgIHJldHVybiBoYXNOZXdLZXk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlT25lTXV0YWJseSh1cGRhdGUsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZU1hbnlNdXRhYmx5KFt1cGRhdGVdLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlTWFueU11dGFibHkodXBkYXRlcywgc3RhdGUpIHtcbiAgICBjb25zdCBuZXdLZXlzID0ge307XG4gICAgY29uc3QgdXBkYXRlc1BlckVudGl0eSA9IHt9O1xuICAgIHVwZGF0ZXMuZm9yRWFjaCgodXBkYXRlKSA9PiB7XG4gICAgICBpZiAodXBkYXRlLmlkIGluIHN0YXRlLmVudGl0aWVzKSB7XG4gICAgICAgIHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXSA9IHtcbiAgICAgICAgICBpZDogdXBkYXRlLmlkLFxuICAgICAgICAgIC8vIFNwcmVhZHMgaWdub3JlIGZhbHN5IHZhbHVlcywgc28gdGhpcyB3b3JrcyBldmVuIGlmIHRoZXJlIGlzbid0XG4gICAgICAgICAgLy8gYW4gZXhpc3RpbmcgdXBkYXRlIGFscmVhZHkgYXQgdGhpcyBrZXlcbiAgICAgICAgICBjaGFuZ2VzOiB7XG4gICAgICAgICAgICAuLi51cGRhdGVzUGVyRW50aXR5W3VwZGF0ZS5pZF0/LmNoYW5nZXMsXG4gICAgICAgICAgICAuLi51cGRhdGUuY2hhbmdlc1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1cGRhdGVzID0gT2JqZWN0LnZhbHVlcyh1cGRhdGVzUGVyRW50aXR5KTtcbiAgICBjb25zdCBkaWRNdXRhdGVFbnRpdGllcyA9IHVwZGF0ZXMubGVuZ3RoID4gMDtcbiAgICBpZiAoZGlkTXV0YXRlRW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IGRpZE11dGF0ZUlkcyA9IHVwZGF0ZXMuZmlsdGVyKCh1cGRhdGUpID0+IHRha2VOZXdLZXkobmV3S2V5cywgdXBkYXRlLCBzdGF0ZSkpLmxlbmd0aCA+IDA7XG4gICAgICBpZiAoZGlkTXV0YXRlSWRzKSB7XG4gICAgICAgIHN0YXRlLmlkcyA9IE9iamVjdC52YWx1ZXMoc3RhdGUuZW50aXRpZXMpLm1hcCgoZSkgPT4gc2VsZWN0SWRWYWx1ZShlLCBzZWxlY3RJZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cHNlcnRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBzZXJ0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cHNlcnRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBjb25zdCBbYWRkZWQsIHVwZGF0ZWRdID0gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKTtcbiAgICB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVkLCBzdGF0ZSk7XG4gICAgYWRkTWFueU11dGFibHkoYWRkZWQsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlbW92ZUFsbDogY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yKHJlbW92ZUFsbE11dGFibHkpLFxuICAgIGFkZE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRPbmVNdXRhYmx5KSxcbiAgICBhZGRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE1hbnlNdXRhYmx5KSxcbiAgICBzZXRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0T25lTXV0YWJseSksXG4gICAgc2V0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRNYW55TXV0YWJseSksXG4gICAgc2V0QWxsOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldEFsbE11dGFibHkpLFxuICAgIHVwZGF0ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVPbmVNdXRhYmx5KSxcbiAgICB1cGRhdGVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU1hbnlNdXRhYmx5KSxcbiAgICB1cHNlcnRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0T25lTXV0YWJseSksXG4gICAgdXBzZXJ0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRNYW55TXV0YWJseSksXG4gICAgcmVtb3ZlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHJlbW92ZU9uZU11dGFibHkpLFxuICAgIHJlbW92ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IocmVtb3ZlTWFueU11dGFibHkpXG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy9zb3J0ZWRfc3RhdGVfYWRhcHRlci50c1xuZnVuY3Rpb24gZmluZEluc2VydEluZGV4KHNvcnRlZEl0ZW1zLCBpdGVtLCBjb21wYXJpc29uRnVuY3Rpb24pIHtcbiAgbGV0IGxvd0luZGV4ID0gMDtcbiAgbGV0IGhpZ2hJbmRleCA9IHNvcnRlZEl0ZW1zLmxlbmd0aDtcbiAgd2hpbGUgKGxvd0luZGV4IDwgaGlnaEluZGV4KSB7XG4gICAgbGV0IG1pZGRsZUluZGV4ID0gbG93SW5kZXggKyBoaWdoSW5kZXggPj4+IDE7XG4gICAgY29uc3QgY3VycmVudEl0ZW0gPSBzb3J0ZWRJdGVtc1ttaWRkbGVJbmRleF07XG4gICAgY29uc3QgcmVzID0gY29tcGFyaXNvbkZ1bmN0aW9uKGl0ZW0sIGN1cnJlbnRJdGVtKTtcbiAgICBpZiAocmVzID49IDApIHtcbiAgICAgIGxvd0luZGV4ID0gbWlkZGxlSW5kZXggKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaWdoSW5kZXggPSBtaWRkbGVJbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxvd0luZGV4O1xufVxuZnVuY3Rpb24gaW5zZXJ0KHNvcnRlZEl0ZW1zLCBpdGVtLCBjb21wYXJpc29uRnVuY3Rpb24pIHtcbiAgY29uc3QgaW5zZXJ0QXRJbmRleCA9IGZpbmRJbnNlcnRJbmRleChzb3J0ZWRJdGVtcywgaXRlbSwgY29tcGFyaXNvbkZ1bmN0aW9uKTtcbiAgc29ydGVkSXRlbXMuc3BsaWNlKGluc2VydEF0SW5kZXgsIDAsIGl0ZW0pO1xuICByZXR1cm4gc29ydGVkSXRlbXM7XG59XG5mdW5jdGlvbiBjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQsIGNvbXBhcmVyKSB7XG4gIGNvbnN0IHtcbiAgICByZW1vdmVPbmUsXG4gICAgcmVtb3ZlTWFueSxcbiAgICByZW1vdmVBbGxcbiAgfSA9IGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKTtcbiAgZnVuY3Rpb24gYWRkT25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XG4gICAgcmV0dXJuIGFkZE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlLCBleGlzdGluZ0lkcykge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgY29uc3QgZXhpc3RpbmdLZXlzID0gbmV3IFNldChleGlzdGluZ0lkcyA/PyBnZXRDdXJyZW50KHN0YXRlLmlkcykpO1xuICAgIGNvbnN0IG1vZGVscyA9IG5ld0VudGl0aWVzLmZpbHRlcigobW9kZWwpID0+ICFleGlzdGluZ0tleXMuaGFzKHNlbGVjdElkVmFsdWUobW9kZWwsIHNlbGVjdElkKSkpO1xuICAgIGlmIChtb2RlbHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICBtZXJnZUZ1bmN0aW9uKHN0YXRlLCBtb2RlbHMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gc2V0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiBzZXRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIGlmIChuZXdFbnRpdGllcy5sZW5ndGggIT09IDApIHtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBuZXdFbnRpdGllcykge1xuICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNbc2VsZWN0SWQoaXRlbSldO1xuICAgICAgfVxuICAgICAgbWVyZ2VGdW5jdGlvbihzdGF0ZSwgbmV3RW50aXRpZXMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRBbGxNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgc3RhdGUuZW50aXRpZXMgPSB7fTtcbiAgICBzdGF0ZS5pZHMgPSBbXTtcbiAgICBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUsIFtdKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVzLCBzdGF0ZSkge1xuICAgIGxldCBhcHBsaWVkVXBkYXRlcyA9IGZhbHNlO1xuICAgIGxldCByZXBsYWNlZElkcyA9IGZhbHNlO1xuICAgIGZvciAobGV0IHVwZGF0ZSBvZiB1cGRhdGVzKSB7XG4gICAgICBjb25zdCBlbnRpdHkgPSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xuICAgICAgaWYgKCFlbnRpdHkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBhcHBsaWVkVXBkYXRlcyA9IHRydWU7XG4gICAgICBPYmplY3QuYXNzaWduKGVudGl0eSwgdXBkYXRlLmNoYW5nZXMpO1xuICAgICAgY29uc3QgbmV3SWQgPSBzZWxlY3RJZChlbnRpdHkpO1xuICAgICAgaWYgKHVwZGF0ZS5pZCAhPT0gbmV3SWQpIHtcbiAgICAgICAgcmVwbGFjZWRJZHMgPSB0cnVlO1xuICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcbiAgICAgICAgY29uc3Qgb2xkSW5kZXggPSBzdGF0ZS5pZHMuaW5kZXhPZih1cGRhdGUuaWQpO1xuICAgICAgICBzdGF0ZS5pZHNbb2xkSW5kZXhdID0gbmV3SWQ7XG4gICAgICAgIHN0YXRlLmVudGl0aWVzW25ld0lkXSA9IGVudGl0eTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFwcGxpZWRVcGRhdGVzKSB7XG4gICAgICBtZXJnZUZ1bmN0aW9uKHN0YXRlLCBbXSwgYXBwbGllZFVwZGF0ZXMsIHJlcGxhY2VkSWRzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBzZXJ0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XG4gICAgcmV0dXJuIHVwc2VydE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBzZXJ0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgY29uc3QgW2FkZGVkLCB1cGRhdGVkLCBleGlzdGluZ0lkc0FycmF5XSA9IHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSk7XG4gICAgaWYgKHVwZGF0ZWQubGVuZ3RoKSB7XG4gICAgICB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVkLCBzdGF0ZSk7XG4gICAgfVxuICAgIGlmIChhZGRlZC5sZW5ndGgpIHtcbiAgICAgIGFkZE1hbnlNdXRhYmx5KGFkZGVkLCBzdGF0ZSwgZXhpc3RpbmdJZHNBcnJheSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFyZUFycmF5c0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gPT09IGJbaV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IG1lcmdlRnVuY3Rpb24gPSAoc3RhdGUsIGFkZGVkSXRlbXMsIGFwcGxpZWRVcGRhdGVzLCByZXBsYWNlZElkcykgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRFbnRpdGllcyA9IGdldEN1cnJlbnQoc3RhdGUuZW50aXRpZXMpO1xuICAgIGNvbnN0IGN1cnJlbnRJZHMgPSBnZXRDdXJyZW50KHN0YXRlLmlkcyk7XG4gICAgY29uc3Qgc3RhdGVFbnRpdGllcyA9IHN0YXRlLmVudGl0aWVzO1xuICAgIGxldCBpZHMgPSBjdXJyZW50SWRzO1xuICAgIGlmIChyZXBsYWNlZElkcykge1xuICAgICAgaWRzID0gbmV3IFNldChjdXJyZW50SWRzKTtcbiAgICB9XG4gICAgbGV0IHNvcnRlZEVudGl0aWVzID0gW107XG4gICAgZm9yIChjb25zdCBpZCBvZiBpZHMpIHtcbiAgICAgIGNvbnN0IGVudGl0eSA9IGN1cnJlbnRFbnRpdGllc1tpZF07XG4gICAgICBpZiAoZW50aXR5KSB7XG4gICAgICAgIHNvcnRlZEVudGl0aWVzLnB1c2goZW50aXR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgd2FzUHJldmlvdXNseUVtcHR5ID0gc29ydGVkRW50aXRpZXMubGVuZ3RoID09PSAwO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhZGRlZEl0ZW1zKSB7XG4gICAgICBzdGF0ZUVudGl0aWVzW3NlbGVjdElkKGl0ZW0pXSA9IGl0ZW07XG4gICAgICBpZiAoIXdhc1ByZXZpb3VzbHlFbXB0eSkge1xuICAgICAgICBpbnNlcnQoc29ydGVkRW50aXRpZXMsIGl0ZW0sIGNvbXBhcmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdhc1ByZXZpb3VzbHlFbXB0eSkge1xuICAgICAgc29ydGVkRW50aXRpZXMgPSBhZGRlZEl0ZW1zLnNsaWNlKCkuc29ydChjb21wYXJlcik7XG4gICAgfSBlbHNlIGlmIChhcHBsaWVkVXBkYXRlcykge1xuICAgICAgc29ydGVkRW50aXRpZXMuc29ydChjb21wYXJlcik7XG4gICAgfVxuICAgIGNvbnN0IG5ld1NvcnRlZElkcyA9IHNvcnRlZEVudGl0aWVzLm1hcChzZWxlY3RJZCk7XG4gICAgaWYgKCFhcmVBcnJheXNFcXVhbChjdXJyZW50SWRzLCBuZXdTb3J0ZWRJZHMpKSB7XG4gICAgICBzdGF0ZS5pZHMgPSBuZXdTb3J0ZWRJZHM7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIHJlbW92ZU9uZSxcbiAgICByZW1vdmVNYW55LFxuICAgIHJlbW92ZUFsbCxcbiAgICBhZGRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkT25lTXV0YWJseSksXG4gICAgdXBkYXRlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU9uZU11dGFibHkpLFxuICAgIHVwc2VydE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRPbmVNdXRhYmx5KSxcbiAgICBzZXRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0T25lTXV0YWJseSksXG4gICAgc2V0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRNYW55TXV0YWJseSksXG4gICAgc2V0QWxsOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldEFsbE11dGFibHkpLFxuICAgIGFkZE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkTWFueU11dGFibHkpLFxuICAgIHVwZGF0ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlTWFueU11dGFibHkpLFxuICAgIHVwc2VydE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0TWFueU11dGFibHkpXG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy9jcmVhdGVfYWRhcHRlci50c1xuZnVuY3Rpb24gY3JlYXRlRW50aXR5QWRhcHRlcihvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHNlbGVjdElkLFxuICAgIHNvcnRDb21wYXJlclxuICB9ID0ge1xuICAgIHNvcnRDb21wYXJlcjogZmFsc2UsXG4gICAgc2VsZWN0SWQ6IChpbnN0YW5jZSkgPT4gaW5zdGFuY2UuaWQsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBzdGF0ZUFkYXB0ZXIgPSBzb3J0Q29tcGFyZXIgPyBjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQsIHNvcnRDb21wYXJlcikgOiBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCk7XG4gIGNvbnN0IHN0YXRlRmFjdG9yeSA9IGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3Rvcnkoc3RhdGVBZGFwdGVyKTtcbiAgY29uc3Qgc2VsZWN0b3JzRmFjdG9yeSA9IGNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkoKTtcbiAgcmV0dXJuIHtcbiAgICBzZWxlY3RJZCxcbiAgICBzb3J0Q29tcGFyZXIsXG4gICAgLi4uc3RhdGVGYWN0b3J5LFxuICAgIC4uLnNlbGVjdG9yc0ZhY3RvcnksXG4gICAgLi4uc3RhdGVBZGFwdGVyXG4gIH07XG59XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvaW5kZXgudHNcbmltcG9ydCB7IGlzQWN0aW9uIGFzIGlzQWN0aW9uMyB9IGZyb20gXCJyZWR1eFwiO1xuXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL2V4Y2VwdGlvbnMudHNcbnZhciB0YXNrID0gXCJ0YXNrXCI7XG52YXIgbGlzdGVuZXIgPSBcImxpc3RlbmVyXCI7XG52YXIgY29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcbnZhciBjYW5jZWxsZWQgPSBcImNhbmNlbGxlZFwiO1xudmFyIHRhc2tDYW5jZWxsZWQgPSBgdGFzay0ke2NhbmNlbGxlZH1gO1xudmFyIHRhc2tDb21wbGV0ZWQgPSBgdGFzay0ke2NvbXBsZXRlZH1gO1xudmFyIGxpc3RlbmVyQ2FuY2VsbGVkID0gYCR7bGlzdGVuZXJ9LSR7Y2FuY2VsbGVkfWA7XG52YXIgbGlzdGVuZXJDb21wbGV0ZWQgPSBgJHtsaXN0ZW5lcn0tJHtjb21wbGV0ZWR9YDtcbnZhciBUYXNrQWJvcnRFcnJvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29kZSkge1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5tZXNzYWdlID0gYCR7dGFza30gJHtjYW5jZWxsZWR9IChyZWFzb246ICR7Y29kZX0pYDtcbiAgfVxuICBuYW1lID0gXCJUYXNrQWJvcnRFcnJvclwiO1xuICBtZXNzYWdlO1xufTtcblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS91dGlscy50c1xudmFyIGFzc2VydEZ1bmN0aW9uID0gKGZ1bmMsIGV4cGVjdGVkKSA9PiB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMyKSA6IGAke2V4cGVjdGVkfSBpcyBub3QgYSBmdW5jdGlvbmApO1xuICB9XG59O1xudmFyIG5vb3AyID0gKCkgPT4ge1xufTtcbnZhciBjYXRjaFJlamVjdGlvbiA9IChwcm9taXNlLCBvbkVycm9yID0gbm9vcDIpID0+IHtcbiAgcHJvbWlzZS5jYXRjaChvbkVycm9yKTtcbiAgcmV0dXJuIHByb21pc2U7XG59O1xudmFyIGFkZEFib3J0U2lnbmFsTGlzdGVuZXIgPSAoYWJvcnRTaWduYWwsIGNhbGxiYWNrKSA9PiB7XG4gIGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYWxsYmFjaywge1xuICAgIG9uY2U6IHRydWVcbiAgfSk7XG4gIHJldHVybiAoKSA9PiBhYm9ydFNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgY2FsbGJhY2spO1xufTtcbnZhciBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uID0gKGFib3J0Q29udHJvbGxlciwgcmVhc29uKSA9PiB7XG4gIGNvbnN0IHNpZ25hbCA9IGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIShcInJlYXNvblwiIGluIHNpZ25hbCkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2lnbmFsLCBcInJlYXNvblwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHJlYXNvbixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgO1xuICBhYm9ydENvbnRyb2xsZXIuYWJvcnQocmVhc29uKTtcbn07XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvdGFzay50c1xudmFyIHZhbGlkYXRlQWN0aXZlID0gKHNpZ25hbCkgPT4ge1xuICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICByZWFzb25cbiAgICB9ID0gc2lnbmFsO1xuICAgIHRocm93IG5ldyBUYXNrQWJvcnRFcnJvcihyZWFzb24pO1xuICB9XG59O1xuZnVuY3Rpb24gcmFjZVdpdGhTaWduYWwoc2lnbmFsLCBwcm9taXNlKSB7XG4gIGxldCBjbGVhbnVwID0gbm9vcDI7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgbm90aWZ5UmVqZWN0aW9uID0gKCkgPT4gcmVqZWN0KG5ldyBUYXNrQWJvcnRFcnJvcihzaWduYWwucmVhc29uKSk7XG4gICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBub3RpZnlSZWplY3Rpb24oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYW51cCA9IGFkZEFib3J0U2lnbmFsTGlzdGVuZXIoc2lnbmFsLCBub3RpZnlSZWplY3Rpb24pO1xuICAgIHByb21pc2UuZmluYWxseSgoKSA9PiBjbGVhbnVwKCkpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgY2xlYW51cCA9IG5vb3AyO1xuICB9KTtcbn1cbnZhciBydW5UYXNrID0gYXN5bmMgKHRhc2syLCBjbGVhblVwKSA9PiB7XG4gIHRyeSB7XG4gICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0YXNrMigpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IFwib2tcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiBlcnJvciBpbnN0YW5jZW9mIFRhc2tBYm9ydEVycm9yID8gXCJjYW5jZWxsZWRcIiA6IFwicmVqZWN0ZWRcIixcbiAgICAgIGVycm9yXG4gICAgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjbGVhblVwPy4oKTtcbiAgfVxufTtcbnZhciBjcmVhdGVQYXVzZSA9IChzaWduYWwpID0+IHtcbiAgcmV0dXJuIChwcm9taXNlKSA9PiB7XG4gICAgcmV0dXJuIGNhdGNoUmVqZWN0aW9uKHJhY2VXaXRoU2lnbmFsKHNpZ25hbCwgcHJvbWlzZSkudGhlbigob3V0cHV0KSA9PiB7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShzaWduYWwpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KSk7XG4gIH07XG59O1xudmFyIGNyZWF0ZURlbGF5ID0gKHNpZ25hbCkgPT4ge1xuICBjb25zdCBwYXVzZSA9IGNyZWF0ZVBhdXNlKHNpZ25hbCk7XG4gIHJldHVybiAodGltZW91dE1zKSA9PiB7XG4gICAgcmV0dXJuIHBhdXNlKG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXRNcykpKTtcbiAgfTtcbn07XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvaW5kZXgudHNcbnZhciB7XG4gIGFzc2lnblxufSA9IE9iamVjdDtcbnZhciBJTlRFUk5BTF9OSUxfVE9LRU4gPSB7fTtcbnZhciBhbG0gPSBcImxpc3RlbmVyTWlkZGxld2FyZVwiO1xudmFyIGNyZWF0ZUZvcmsgPSAocGFyZW50QWJvcnRTaWduYWwsIHBhcmVudEJsb2NraW5nUHJvbWlzZXMpID0+IHtcbiAgY29uc3QgbGlua0NvbnRyb2xsZXJzID0gKGNvbnRyb2xsZXIpID0+IGFkZEFib3J0U2lnbmFsTGlzdGVuZXIocGFyZW50QWJvcnRTaWduYWwsICgpID0+IGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY29udHJvbGxlciwgcGFyZW50QWJvcnRTaWduYWwucmVhc29uKSk7XG4gIHJldHVybiAodGFza0V4ZWN1dG9yLCBvcHRzKSA9PiB7XG4gICAgYXNzZXJ0RnVuY3Rpb24odGFza0V4ZWN1dG9yLCBcInRhc2tFeGVjdXRvclwiKTtcbiAgICBjb25zdCBjaGlsZEFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsaW5rQ29udHJvbGxlcnMoY2hpbGRBYm9ydENvbnRyb2xsZXIpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHJ1blRhc2soYXN5bmMgKCkgPT4ge1xuICAgICAgdmFsaWRhdGVBY3RpdmUocGFyZW50QWJvcnRTaWduYWwpO1xuICAgICAgdmFsaWRhdGVBY3RpdmUoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCB0YXNrRXhlY3V0b3Ioe1xuICAgICAgICBwYXVzZTogY3JlYXRlUGF1c2UoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgZGVsYXk6IGNyZWF0ZURlbGF5KGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbCksXG4gICAgICAgIHNpZ25hbDogY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9LCAoKSA9PiBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNoaWxkQWJvcnRDb250cm9sbGVyLCB0YXNrQ29tcGxldGVkKSk7XG4gICAgaWYgKG9wdHM/LmF1dG9Kb2luKSB7XG4gICAgICBwYXJlbnRCbG9ja2luZ1Byb21pc2VzLnB1c2gocmVzdWx0LmNhdGNoKG5vb3AyKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IGNyZWF0ZVBhdXNlKHBhcmVudEFib3J0U2lnbmFsKShyZXN1bHQpLFxuICAgICAgY2FuY2VsKCkge1xuICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNoaWxkQWJvcnRDb250cm9sbGVyLCB0YXNrQ2FuY2VsbGVkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufTtcbnZhciBjcmVhdGVUYWtlUGF0dGVybiA9IChzdGFydExpc3RlbmluZywgc2lnbmFsKSA9PiB7XG4gIGNvbnN0IHRha2UgPSBhc3luYyAocHJlZGljYXRlLCB0aW1lb3V0KSA9PiB7XG4gICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcbiAgICBsZXQgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgfTtcbiAgICBjb25zdCB0dXBsZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgc3RvcExpc3RlbmluZyA9IHN0YXJ0TGlzdGVuaW5nKHtcbiAgICAgICAgcHJlZGljYXRlLFxuICAgICAgICBlZmZlY3Q6IChhY3Rpb24sIGxpc3RlbmVyQXBpKSA9PiB7XG4gICAgICAgICAgbGlzdGVuZXJBcGkudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICByZXNvbHZlKFthY3Rpb24sIGxpc3RlbmVyQXBpLmdldFN0YXRlKCksIGxpc3RlbmVyQXBpLmdldE9yaWdpbmFsU3RhdGUoKV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgICBzdG9wTGlzdGVuaW5nKCk7XG4gICAgICAgIHJlamVjdCgpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBwcm9taXNlcyA9IFt0dXBsZVByb21pc2VdO1xuICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgIHByb21pc2VzLnB1c2gobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCwgbnVsbCkpKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHJhY2VXaXRoU2lnbmFsKHNpZ25hbCwgUHJvbWlzZS5yYWNlKHByb21pc2VzKSk7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShzaWduYWwpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiAocHJlZGljYXRlLCB0aW1lb3V0KSA9PiBjYXRjaFJlamVjdGlvbih0YWtlKHByZWRpY2F0ZSwgdGltZW91dCkpO1xufTtcbnZhciBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tID0gKG9wdGlvbnMpID0+IHtcbiAgbGV0IHtcbiAgICB0eXBlLFxuICAgIGFjdGlvbkNyZWF0b3IsXG4gICAgbWF0Y2hlcixcbiAgICBwcmVkaWNhdGUsXG4gICAgZWZmZWN0XG4gIH0gPSBvcHRpb25zO1xuICBpZiAodHlwZSkge1xuICAgIHByZWRpY2F0ZSA9IGNyZWF0ZUFjdGlvbih0eXBlKS5tYXRjaDtcbiAgfSBlbHNlIGlmIChhY3Rpb25DcmVhdG9yKSB7XG4gICAgdHlwZSA9IGFjdGlvbkNyZWF0b3IudHlwZTtcbiAgICBwcmVkaWNhdGUgPSBhY3Rpb25DcmVhdG9yLm1hdGNoO1xuICB9IGVsc2UgaWYgKG1hdGNoZXIpIHtcbiAgICBwcmVkaWNhdGUgPSBtYXRjaGVyO1xuICB9IGVsc2UgaWYgKHByZWRpY2F0ZSkge1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIxKSA6IFwiQ3JlYXRpbmcgb3IgcmVtb3ZpbmcgYSBsaXN0ZW5lciByZXF1aXJlcyBvbmUgb2YgdGhlIGtub3duIGZpZWxkcyBmb3IgbWF0Y2hpbmcgYW4gYWN0aW9uXCIpO1xuICB9XG4gIGFzc2VydEZ1bmN0aW9uKGVmZmVjdCwgXCJvcHRpb25zLmxpc3RlbmVyXCIpO1xuICByZXR1cm4ge1xuICAgIHByZWRpY2F0ZSxcbiAgICB0eXBlLFxuICAgIGVmZmVjdFxuICB9O1xufTtcbnZhciBjcmVhdGVMaXN0ZW5lckVudHJ5ID0gLyogQF9fUFVSRV9fICovIGFzc2lnbigob3B0aW9ucykgPT4ge1xuICBjb25zdCB7XG4gICAgdHlwZSxcbiAgICBwcmVkaWNhdGUsXG4gICAgZWZmZWN0XG4gIH0gPSBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tKG9wdGlvbnMpO1xuICBjb25zdCBlbnRyeSA9IHtcbiAgICBpZDogbmFub2lkKCksXG4gICAgZWZmZWN0LFxuICAgIHR5cGUsXG4gICAgcHJlZGljYXRlLFxuICAgIHBlbmRpbmc6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIyKSA6IFwiVW5zdWJzY3JpYmUgbm90IGluaXRpYWxpemVkXCIpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGVudHJ5O1xufSwge1xuICB3aXRoVHlwZXM6ICgpID0+IGNyZWF0ZUxpc3RlbmVyRW50cnlcbn0pO1xudmFyIGZpbmRMaXN0ZW5lckVudHJ5ID0gKGxpc3RlbmVyTWFwLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIGVmZmVjdCxcbiAgICBwcmVkaWNhdGVcbiAgfSA9IGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20ob3B0aW9ucyk7XG4gIHJldHVybiBBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKS5maW5kKChlbnRyeSkgPT4ge1xuICAgIGNvbnN0IG1hdGNoUHJlZGljYXRlT3JUeXBlID0gdHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIgPyBlbnRyeS50eXBlID09PSB0eXBlIDogZW50cnkucHJlZGljYXRlID09PSBwcmVkaWNhdGU7XG4gICAgcmV0dXJuIG1hdGNoUHJlZGljYXRlT3JUeXBlICYmIGVudHJ5LmVmZmVjdCA9PT0gZWZmZWN0O1xuICB9KTtcbn07XG52YXIgY2FuY2VsQWN0aXZlTGlzdGVuZXJzID0gKGVudHJ5KSA9PiB7XG4gIGVudHJ5LnBlbmRpbmcuZm9yRWFjaCgoY29udHJvbGxlcikgPT4ge1xuICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY29udHJvbGxlciwgbGlzdGVuZXJDYW5jZWxsZWQpO1xuICB9KTtcbn07XG52YXIgY3JlYXRlQ2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSAobGlzdGVuZXJNYXApID0+IHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsaXN0ZW5lck1hcC5mb3JFYWNoKGNhbmNlbEFjdGl2ZUxpc3RlbmVycyk7XG4gICAgbGlzdGVuZXJNYXAuY2xlYXIoKTtcbiAgfTtcbn07XG52YXIgc2FmZWx5Tm90aWZ5RXJyb3IgPSAoZXJyb3JIYW5kbGVyLCBlcnJvclRvTm90aWZ5LCBlcnJvckluZm8pID0+IHtcbiAgdHJ5IHtcbiAgICBlcnJvckhhbmRsZXIoZXJyb3JUb05vdGlmeSwgZXJyb3JJbmZvKTtcbiAgfSBjYXRjaCAoZXJyb3JIYW5kbGVyRXJyb3IpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRocm93IGVycm9ySGFuZGxlckVycm9yO1xuICAgIH0sIDApO1xuICB9XG59O1xudmFyIGFkZExpc3RlbmVyID0gLyogQF9fUFVSRV9fICovIGFzc2lnbigvKiBAX19QVVJFX18gKi8gY3JlYXRlQWN0aW9uKGAke2FsbX0vYWRkYCksIHtcbiAgd2l0aFR5cGVzOiAoKSA9PiBhZGRMaXN0ZW5lclxufSk7XG52YXIgY2xlYXJBbGxMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQWN0aW9uKGAke2FsbX0vcmVtb3ZlQWxsYCk7XG52YXIgcmVtb3ZlTGlzdGVuZXIgPSAvKiBAX19QVVJFX18gKi8gYXNzaWduKC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVBY3Rpb24oYCR7YWxtfS9yZW1vdmVgKSwge1xuICB3aXRoVHlwZXM6ICgpID0+IHJlbW92ZUxpc3RlbmVyXG59KTtcbnZhciBkZWZhdWx0RXJyb3JIYW5kbGVyID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc29sZS5lcnJvcihgJHthbG19L2Vycm9yYCwgLi4uYXJncyk7XG59O1xudmFyIGNyZWF0ZUxpc3RlbmVyTWlkZGxld2FyZSA9IChtaWRkbGV3YXJlT3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IGxpc3RlbmVyTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3Qge1xuICAgIGV4dHJhLFxuICAgIG9uRXJyb3IgPSBkZWZhdWx0RXJyb3JIYW5kbGVyXG4gIH0gPSBtaWRkbGV3YXJlT3B0aW9ucztcbiAgYXNzZXJ0RnVuY3Rpb24ob25FcnJvciwgXCJvbkVycm9yXCIpO1xuICBjb25zdCBpbnNlcnRFbnRyeSA9IChlbnRyeSkgPT4ge1xuICAgIGVudHJ5LnVuc3Vic2NyaWJlID0gKCkgPT4gbGlzdGVuZXJNYXAuZGVsZXRlKGVudHJ5LmlkKTtcbiAgICBsaXN0ZW5lck1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcbiAgICByZXR1cm4gKGNhbmNlbE9wdGlvbnMpID0+IHtcbiAgICAgIGVudHJ5LnVuc3Vic2NyaWJlKCk7XG4gICAgICBpZiAoY2FuY2VsT3B0aW9ucz8uY2FuY2VsQWN0aXZlKSB7XG4gICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVycyhlbnRyeSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgY29uc3Qgc3RhcnRMaXN0ZW5pbmcgPSAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGVudHJ5ID0gZmluZExpc3RlbmVyRW50cnkobGlzdGVuZXJNYXAsIG9wdGlvbnMpID8/IGNyZWF0ZUxpc3RlbmVyRW50cnkob3B0aW9ucyk7XG4gICAgcmV0dXJuIGluc2VydEVudHJ5KGVudHJ5KTtcbiAgfTtcbiAgYXNzaWduKHN0YXJ0TGlzdGVuaW5nLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiBzdGFydExpc3RlbmluZ1xuICB9KTtcbiAgY29uc3Qgc3RvcExpc3RlbmluZyA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgZW50cnkgPSBmaW5kTGlzdGVuZXJFbnRyeShsaXN0ZW5lck1hcCwgb3B0aW9ucyk7XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS51bnN1YnNjcmliZSgpO1xuICAgICAgaWYgKG9wdGlvbnMuY2FuY2VsQWN0aXZlKSB7XG4gICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVycyhlbnRyeSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhIWVudHJ5O1xuICB9O1xuICBhc3NpZ24oc3RvcExpc3RlbmluZywge1xuICAgIHdpdGhUeXBlczogKCkgPT4gc3RvcExpc3RlbmluZ1xuICB9KTtcbiAgY29uc3Qgbm90aWZ5TGlzdGVuZXIgPSBhc3luYyAoZW50cnksIGFjdGlvbiwgYXBpLCBnZXRPcmlnaW5hbFN0YXRlKSA9PiB7XG4gICAgY29uc3QgaW50ZXJuYWxUYXNrQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCB0YWtlID0gY3JlYXRlVGFrZVBhdHRlcm4oc3RhcnRMaXN0ZW5pbmcsIGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICBjb25zdCBhdXRvSm9pblByb21pc2VzID0gW107XG4gICAgdHJ5IHtcbiAgICAgIGVudHJ5LnBlbmRpbmcuYWRkKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKGVudHJ5LmVmZmVjdChcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICAvLyBVc2UgYXNzaWduKCkgcmF0aGVyIHRoYW4gLi4uIHRvIGF2b2lkIGV4dHJhIGhlbHBlciBmdW5jdGlvbnMgYWRkZWQgdG8gYnVuZGxlXG4gICAgICAgIGFzc2lnbih7fSwgYXBpLCB7XG4gICAgICAgICAgZ2V0T3JpZ2luYWxTdGF0ZSxcbiAgICAgICAgICBjb25kaXRpb246IChwcmVkaWNhdGUsIHRpbWVvdXQpID0+IHRha2UocHJlZGljYXRlLCB0aW1lb3V0KS50aGVuKEJvb2xlYW4pLFxuICAgICAgICAgIHRha2UsXG4gICAgICAgICAgZGVsYXk6IGNyZWF0ZURlbGF5KGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgICBwYXVzZTogY3JlYXRlUGF1c2UoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICAgIGV4dHJhLFxuICAgICAgICAgIHNpZ25hbDogaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgZm9yazogY3JlYXRlRm9yayhpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCwgYXV0b0pvaW5Qcm9taXNlcyksXG4gICAgICAgICAgdW5zdWJzY3JpYmU6IGVudHJ5LnVuc3Vic2NyaWJlLFxuICAgICAgICAgIHN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXJNYXAuc2V0KGVudHJ5LmlkLCBlbnRyeSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnM6ICgpID0+IHtcbiAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZm9yRWFjaCgoY29udHJvbGxlciwgXywgc2V0KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChjb250cm9sbGVyICE9PSBpbnRlcm5hbFRhc2tDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XG4gICAgICAgICAgICAgICAgc2V0LmRlbGV0ZShjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oaW50ZXJuYWxUYXNrQ29udHJvbGxlciwgbGlzdGVuZXJDYW5jZWxsZWQpO1xuICAgICAgICAgICAgZW50cnkucGVuZGluZy5kZWxldGUoaW50ZXJuYWxUYXNrQ29udHJvbGxlcik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkOiAoKSA9PiB7XG4gICAgICAgICAgICB2YWxpZGF0ZUFjdGl2ZShpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKSk7XG4gICAgfSBjYXRjaCAobGlzdGVuZXJFcnJvcikge1xuICAgICAgaWYgKCEobGlzdGVuZXJFcnJvciBpbnN0YW5jZW9mIFRhc2tBYm9ydEVycm9yKSkge1xuICAgICAgICBzYWZlbHlOb3RpZnlFcnJvcihvbkVycm9yLCBsaXN0ZW5lckVycm9yLCB7XG4gICAgICAgICAgcmFpc2VkQnk6IFwiZWZmZWN0XCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGF1dG9Kb2luUHJvbWlzZXMpO1xuICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihpbnRlcm5hbFRhc2tDb250cm9sbGVyLCBsaXN0ZW5lckNvbXBsZXRlZCk7XG4gICAgICBlbnRyeS5wZW5kaW5nLmRlbGV0ZShpbnRlcm5hbFRhc2tDb250cm9sbGVyKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlID0gY3JlYXRlQ2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUobGlzdGVuZXJNYXApO1xuICBjb25zdCBtaWRkbGV3YXJlID0gKGFwaSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICBpZiAoIWlzQWN0aW9uMyhhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgIH1cbiAgICBpZiAoYWRkTGlzdGVuZXIubWF0Y2goYWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHN0YXJ0TGlzdGVuaW5nKGFjdGlvbi5wYXlsb2FkKTtcbiAgICB9XG4gICAgaWYgKGNsZWFyQWxsTGlzdGVuZXJzLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZW1vdmVMaXN0ZW5lci5tYXRjaChhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gc3RvcExpc3RlbmluZyhhY3Rpb24ucGF5bG9hZCk7XG4gICAgfVxuICAgIGxldCBvcmlnaW5hbFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgY29uc3QgZ2V0T3JpZ2luYWxTdGF0ZSA9ICgpID0+IHtcbiAgICAgIGlmIChvcmlnaW5hbFN0YXRlID09PSBJTlRFUk5BTF9OSUxfVE9LRU4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjMpIDogYCR7YWxtfTogZ2V0T3JpZ2luYWxTdGF0ZSBjYW4gb25seSBiZSBjYWxsZWQgc3luY2hyb25vdXNseWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsU3RhdGU7XG4gICAgfTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBuZXh0KGFjdGlvbik7XG4gICAgICBpZiAobGlzdGVuZXJNYXAuc2l6ZSA+IDApIHtcbiAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyRW50cmllcyA9IEFycmF5LmZyb20obGlzdGVuZXJNYXAudmFsdWVzKCkpO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGxpc3RlbmVyRW50cmllcykge1xuICAgICAgICAgIGxldCBydW5MaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBydW5MaXN0ZW5lciA9IGVudHJ5LnByZWRpY2F0ZShhY3Rpb24sIGN1cnJlbnRTdGF0ZSwgb3JpZ2luYWxTdGF0ZSk7XG4gICAgICAgICAgfSBjYXRjaCAocHJlZGljYXRlRXJyb3IpIHtcbiAgICAgICAgICAgIHJ1bkxpc3RlbmVyID0gZmFsc2U7XG4gICAgICAgICAgICBzYWZlbHlOb3RpZnlFcnJvcihvbkVycm9yLCBwcmVkaWNhdGVFcnJvciwge1xuICAgICAgICAgICAgICByYWlzZWRCeTogXCJwcmVkaWNhdGVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcnVuTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub3RpZnlMaXN0ZW5lcihlbnRyeSwgYWN0aW9uLCBhcGksIGdldE9yaWdpbmFsU3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIG9yaWdpbmFsU3RhdGUgPSBJTlRFUk5BTF9OSUxfVE9LRU47XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbWlkZGxld2FyZSxcbiAgICBzdGFydExpc3RlbmluZyxcbiAgICBzdG9wTGlzdGVuaW5nLFxuICAgIGNsZWFyTGlzdGVuZXJzOiBjbGVhckxpc3RlbmVyTWlkZGxld2FyZVxuICB9O1xufTtcblxuLy8gc3JjL2R5bmFtaWNNaWRkbGV3YXJlL2luZGV4LnRzXG5pbXBvcnQgeyBjb21wb3NlIGFzIGNvbXBvc2UzIH0gZnJvbSBcInJlZHV4XCI7XG52YXIgY3JlYXRlTWlkZGxld2FyZUVudHJ5ID0gKG1pZGRsZXdhcmUpID0+ICh7XG4gIG1pZGRsZXdhcmUsXG4gIGFwcGxpZWQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbn0pO1xudmFyIG1hdGNoSW5zdGFuY2UgPSAoaW5zdGFuY2VJZCkgPT4gKGFjdGlvbikgPT4gYWN0aW9uPy5tZXRhPy5pbnN0YW5jZUlkID09PSBpbnN0YW5jZUlkO1xudmFyIGNyZWF0ZUR5bmFtaWNNaWRkbGV3YXJlID0gKCkgPT4ge1xuICBjb25zdCBpbnN0YW5jZUlkID0gbmFub2lkKCk7XG4gIGNvbnN0IG1pZGRsZXdhcmVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCB3aXRoTWlkZGxld2FyZSA9IE9iamVjdC5hc3NpZ24oY3JlYXRlQWN0aW9uKFwiZHluYW1pY01pZGRsZXdhcmUvYWRkXCIsICguLi5taWRkbGV3YXJlcykgPT4gKHtcbiAgICBwYXlsb2FkOiBtaWRkbGV3YXJlcyxcbiAgICBtZXRhOiB7XG4gICAgICBpbnN0YW5jZUlkXG4gICAgfVxuICB9KSksIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHdpdGhNaWRkbGV3YXJlXG4gIH0pO1xuICBjb25zdCBhZGRNaWRkbGV3YXJlID0gT2JqZWN0LmFzc2lnbihmdW5jdGlvbiBhZGRNaWRkbGV3YXJlMiguLi5taWRkbGV3YXJlcykge1xuICAgIG1pZGRsZXdhcmVzLmZvckVhY2goKG1pZGRsZXdhcmUyKSA9PiB7XG4gICAgICBnZXRPckluc2VydENvbXB1dGVkKG1pZGRsZXdhcmVNYXAsIG1pZGRsZXdhcmUyLCBjcmVhdGVNaWRkbGV3YXJlRW50cnkpO1xuICAgIH0pO1xuICB9LCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiBhZGRNaWRkbGV3YXJlXG4gIH0pO1xuICBjb25zdCBnZXRGaW5hbE1pZGRsZXdhcmUgPSAoYXBpKSA9PiB7XG4gICAgY29uc3QgYXBwbGllZE1pZGRsZXdhcmUgPSBBcnJheS5mcm9tKG1pZGRsZXdhcmVNYXAudmFsdWVzKCkpLm1hcCgoZW50cnkpID0+IGdldE9ySW5zZXJ0Q29tcHV0ZWQoZW50cnkuYXBwbGllZCwgYXBpLCBlbnRyeS5taWRkbGV3YXJlKSk7XG4gICAgcmV0dXJuIGNvbXBvc2UzKC4uLmFwcGxpZWRNaWRkbGV3YXJlKTtcbiAgfTtcbiAgY29uc3QgaXNXaXRoTWlkZGxld2FyZSA9IGlzQWxsT2Yod2l0aE1pZGRsZXdhcmUsIG1hdGNoSW5zdGFuY2UoaW5zdGFuY2VJZCkpO1xuICBjb25zdCBtaWRkbGV3YXJlID0gKGFwaSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICBpZiAoaXNXaXRoTWlkZGxld2FyZShhY3Rpb24pKSB7XG4gICAgICBhZGRNaWRkbGV3YXJlKC4uLmFjdGlvbi5wYXlsb2FkKTtcbiAgICAgIHJldHVybiBhcGkuZGlzcGF0Y2g7XG4gICAgfVxuICAgIHJldHVybiBnZXRGaW5hbE1pZGRsZXdhcmUoYXBpKShuZXh0KShhY3Rpb24pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmUsXG4gICAgYWRkTWlkZGxld2FyZSxcbiAgICB3aXRoTWlkZGxld2FyZSxcbiAgICBpbnN0YW5jZUlkXG4gIH07XG59O1xuXG4vLyBzcmMvY29tYmluZVNsaWNlcy50c1xuaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIGFzIGNvbWJpbmVSZWR1Y2VyczIgfSBmcm9tIFwicmVkdXhcIjtcbnZhciBpc1NsaWNlTGlrZSA9IChtYXliZVNsaWNlTGlrZSkgPT4gXCJyZWR1Y2VyUGF0aFwiIGluIG1heWJlU2xpY2VMaWtlICYmIHR5cGVvZiBtYXliZVNsaWNlTGlrZS5yZWR1Y2VyUGF0aCA9PT0gXCJzdHJpbmdcIjtcbnZhciBnZXRSZWR1Y2VycyA9IChzbGljZXMpID0+IHNsaWNlcy5mbGF0TWFwKChzbGljZU9yTWFwKSA9PiBpc1NsaWNlTGlrZShzbGljZU9yTWFwKSA/IFtbc2xpY2VPck1hcC5yZWR1Y2VyUGF0aCwgc2xpY2VPck1hcC5yZWR1Y2VyXV0gOiBPYmplY3QuZW50cmllcyhzbGljZU9yTWFwKSk7XG52YXIgT1JJR0lOQUxfU1RBVEUgPSBTeW1ib2wuZm9yKFwicnRrLXN0YXRlLXByb3h5LW9yaWdpbmFsXCIpO1xudmFyIGlzU3RhdGVQcm94eSA9ICh2YWx1ZSkgPT4gISF2YWx1ZSAmJiAhIXZhbHVlW09SSUdJTkFMX1NUQVRFXTtcbnZhciBzdGF0ZVByb3h5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgY3JlYXRlU3RhdGVQcm94eSA9IChzdGF0ZSwgcmVkdWNlck1hcCkgPT4gZ2V0T3JJbnNlcnRDb21wdXRlZChzdGF0ZVByb3h5TWFwLCBzdGF0ZSwgKCkgPT4gbmV3IFByb3h5KHN0YXRlLCB7XG4gIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICBpZiAocHJvcCA9PT0gT1JJR0lOQUxfU1RBVEUpIHJldHVybiB0YXJnZXQ7XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNvbnN0IHJlZHVjZXIgPSByZWR1Y2VyTWFwW3Byb3AudG9TdHJpbmcoKV07XG4gICAgICBpZiAocmVkdWNlcikge1xuICAgICAgICBjb25zdCByZWR1Y2VyUmVzdWx0ID0gcmVkdWNlcih2b2lkIDAsIHtcbiAgICAgICAgICB0eXBlOiBuYW5vaWQoKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiByZWR1Y2VyUmVzdWx0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjQpIDogYFRoZSBzbGljZSByZWR1Y2VyIGZvciBrZXkgXCIke3Byb3AudG9TdHJpbmcoKX1cIiByZXR1cm5lZCB1bmRlZmluZWQgd2hlbiBjYWxsZWQgZm9yIHNlbGVjdG9yKCkuIElmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlIHJlZHVjZXIgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IG5vdCBiZSB1bmRlZmluZWQuIElmIHlvdSBkb24ndCB3YW50IHRvIHNldCBhIHZhbHVlIGZvciB0aGlzIHJlZHVjZXIsIHlvdSBjYW4gdXNlIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZHVjZXJSZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pKTtcbnZhciBvcmlnaW5hbCA9IChzdGF0ZSkgPT4ge1xuICBpZiAoIWlzU3RhdGVQcm94eShzdGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNSkgOiBcIm9yaWdpbmFsIG11c3QgYmUgdXNlZCBvbiBzdGF0ZSBQcm94eVwiKTtcbiAgfVxuICByZXR1cm4gc3RhdGVbT1JJR0lOQUxfU1RBVEVdO1xufTtcbnZhciBub29wUmVkdWNlciA9IChzdGF0ZSA9IHt9KSA9PiBzdGF0ZTtcbmZ1bmN0aW9uIGNvbWJpbmVTbGljZXMoLi4uc2xpY2VzKSB7XG4gIGNvbnN0IHJlZHVjZXJNYXAgPSBPYmplY3QuZnJvbUVudHJpZXMoZ2V0UmVkdWNlcnMoc2xpY2VzKSk7XG4gIGNvbnN0IGdldFJlZHVjZXIgPSAoKSA9PiBPYmplY3Qua2V5cyhyZWR1Y2VyTWFwKS5sZW5ndGggPyBjb21iaW5lUmVkdWNlcnMyKHJlZHVjZXJNYXApIDogbm9vcFJlZHVjZXI7XG4gIGxldCByZWR1Y2VyID0gZ2V0UmVkdWNlcigpO1xuICBmdW5jdGlvbiBjb21iaW5lZFJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIHJldHVybiByZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xuICB9XG4gIGNvbWJpbmVkUmVkdWNlci53aXRoTGF6eUxvYWRlZFNsaWNlcyA9ICgpID0+IGNvbWJpbmVkUmVkdWNlcjtcbiAgY29uc3QgaW5qZWN0ID0gKHNsaWNlLCBjb25maWcgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlZHVjZXJQYXRoLFxuICAgICAgcmVkdWNlcjogcmVkdWNlclRvSW5qZWN0XG4gICAgfSA9IHNsaWNlO1xuICAgIGNvbnN0IGN1cnJlbnRSZWR1Y2VyID0gcmVkdWNlck1hcFtyZWR1Y2VyUGF0aF07XG4gICAgaWYgKCFjb25maWcub3ZlcnJpZGVFeGlzdGluZyAmJiBjdXJyZW50UmVkdWNlciAmJiBjdXJyZW50UmVkdWNlciAhPT0gcmVkdWNlclRvSW5qZWN0KSB7XG4gICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBjYWxsZWQgXFxgaW5qZWN0XFxgIHRvIG92ZXJyaWRlIGFscmVhZHktZXhpc3RpbmcgcmVkdWNlciAke3JlZHVjZXJQYXRofSB3aXRob3V0IHNwZWNpZnlpbmcgXFxgb3ZlcnJpZGVFeGlzdGluZzogdHJ1ZVxcYGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbWJpbmVkUmVkdWNlcjtcbiAgICB9XG4gICAgcmVkdWNlck1hcFtyZWR1Y2VyUGF0aF0gPSByZWR1Y2VyVG9JbmplY3Q7XG4gICAgcmVkdWNlciA9IGdldFJlZHVjZXIoKTtcbiAgICByZXR1cm4gY29tYmluZWRSZWR1Y2VyO1xuICB9O1xuICBjb25zdCBzZWxlY3RvciA9IE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gbWFrZVNlbGVjdG9yKHNlbGVjdG9yRm4sIHNlbGVjdFN0YXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNlbGVjdG9yMihzdGF0ZSwgLi4uYXJncykge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yRm4oY3JlYXRlU3RhdGVQcm94eShzZWxlY3RTdGF0ZSA/IHNlbGVjdFN0YXRlKHN0YXRlLCAuLi5hcmdzKSA6IHN0YXRlLCByZWR1Y2VyTWFwKSwgLi4uYXJncyk7XG4gICAgfTtcbiAgfSwge1xuICAgIG9yaWdpbmFsXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihjb21iaW5lZFJlZHVjZXIsIHtcbiAgICBpbmplY3QsXG4gICAgc2VsZWN0b3JcbiAgfSk7XG59XG5cbi8vIHNyYy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlLnRzXG5mdW5jdGlvbiBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKGNvZGUpIHtcbiAgcmV0dXJuIGBNaW5pZmllZCBSZWR1eCBUb29sa2l0IGVycm9yICMke2NvZGV9OyB2aXNpdCBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL0Vycm9ycz9jb2RlPSR7Y29kZX0gZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycy4gYDtcbn1cbmV4cG9ydCB7XG4gIFJlZHVjZXJUeXBlLFxuICBTSE9VTERfQVVUT0JBVENILFxuICBUYXNrQWJvcnRFcnJvcixcbiAgVHVwbGUsXG4gIGFkZExpc3RlbmVyLFxuICBhc3luY1RodW5rQ3JlYXRvcixcbiAgYXV0b0JhdGNoRW5oYW5jZXIsXG4gIGJ1aWxkQ3JlYXRlU2xpY2UsXG4gIGNsZWFyQWxsTGlzdGVuZXJzLFxuICBjb21iaW5lU2xpY2VzLFxuICBjb25maWd1cmVTdG9yZSxcbiAgY3JlYXRlQWN0aW9uLFxuICBjcmVhdGVBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZSxcbiAgY3JlYXRlQXN5bmNUaHVuayxcbiAgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IsXG4gIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvcixcbiAgY3JlYXRlRHluYW1pY01pZGRsZXdhcmUsXG4gIGNyZWF0ZUVudGl0eUFkYXB0ZXIsXG4gIGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSxcbiAgY3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlLFxuICBwcm9kdWNlIGFzIGNyZWF0ZU5leHRTdGF0ZSxcbiAgY3JlYXRlUmVkdWNlcixcbiAgY3JlYXRlU2VsZWN0b3IsXG4gIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcjIgYXMgY3JlYXRlU2VsZWN0b3JDcmVhdG9yLFxuICBjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUsXG4gIGNyZWF0ZVNsaWNlLFxuICBjdXJyZW50MyBhcyBjdXJyZW50LFxuICBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUsXG4gIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UsXG4gIGZyZWV6ZSxcbiAgaXNBY3Rpb25DcmVhdG9yLFxuICBpc0FsbE9mLFxuICBpc0FueU9mLFxuICBpc0FzeW5jVGh1bmtBY3Rpb24sXG4gIGlzRHJhZnQ1IGFzIGlzRHJhZnQsXG4gIGlzRlNBIGFzIGlzRmx1eFN0YW5kYXJkQWN0aW9uLFxuICBpc0Z1bGZpbGxlZCxcbiAgaXNJbW11dGFibGVEZWZhdWx0LFxuICBpc1BlbmRpbmcsXG4gIGlzUGxhaW4sXG4gIGlzUmVqZWN0ZWQsXG4gIGlzUmVqZWN0ZWRXaXRoVmFsdWUsXG4gIGxydU1lbW9pemUsXG4gIG1pbmlTZXJpYWxpemVFcnJvcixcbiAgbmFub2lkLFxuICBvcmlnaW5hbDIgYXMgb3JpZ2luYWwsXG4gIHByZXBhcmVBdXRvQmF0Y2hlZCxcbiAgcmVtb3ZlTGlzdGVuZXIsXG4gIHVud3JhcFJlc3VsdCxcbiAgd2Vha01hcE1lbW9pemUyIGFzIHdlYWtNYXBNZW1vaXplXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdXgtdG9vbGtpdC5tb2Rlcm4ubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/node_modules/redux-thunk/dist/redux-thunk.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/node_modules/redux-thunk/dist/redux-thunk.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   thunk: () => (/* binding */ thunk),\n/* harmony export */   withExtraArgument: () => (/* binding */ withExtraArgument)\n/* harmony export */ });\n// src/index.ts\nfunction createThunkMiddleware(extraArgument) {\n  const middleware = ({ dispatch, getState }) => (next) => (action) => {\n    if (typeof action === \"function\") {\n      return action(dispatch, getState, extraArgument);\n    }\n    return next(action);\n  };\n  return middleware;\n}\nvar thunk = createThunkMiddleware();\nvar withExtraArgument = createThunkMiddleware;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9ub2RlX21vZHVsZXMvcmVkdXgtdGh1bmsvZGlzdC9yZWR1eC10aHVuay5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxUTGV2ZWwgLSBPcmVcXGZsb3dkZXNrXFxjbGllbnRcXG5vZGVfbW9kdWxlc1xcQHJlZHV4anNcXHRvb2xraXRcXG5vZGVfbW9kdWxlc1xccmVkdXgtdGh1bmtcXGRpc3RcXHJlZHV4LXRodW5rLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmZ1bmN0aW9uIGNyZWF0ZVRodW5rTWlkZGxld2FyZShleHRyYUFyZ3VtZW50KSB7XG4gIGNvbnN0IG1pZGRsZXdhcmUgPSAoeyBkaXNwYXRjaCwgZ2V0U3RhdGUgfSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYWN0aW9uKGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmFBcmd1bWVudCk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gIH07XG4gIHJldHVybiBtaWRkbGV3YXJlO1xufVxudmFyIHRodW5rID0gY3JlYXRlVGh1bmtNaWRkbGV3YXJlKCk7XG52YXIgd2l0aEV4dHJhQXJndW1lbnQgPSBjcmVhdGVUaHVua01pZGRsZXdhcmU7XG5leHBvcnQge1xuICB0aHVuayxcbiAgd2l0aEV4dHJhQXJndW1lbnRcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/node_modules/redux-thunk/dist/redux-thunk.mjs\n");

/***/ })

};
;